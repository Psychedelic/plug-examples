{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\n// tslint:disable:no-bitwise\nvar alphabet = 'abcdefghijklmnopqrstuvwxyz234567'; // Build a lookup table for decoding.\n\nvar lookupTable = Object.create(null);\n\nfor (var i = 0; i < alphabet.length; i++) {\n  lookupTable[alphabet[i]] = i;\n} // Add aliases for rfc4648.\n\n\nlookupTable['0'] = lookupTable.o;\nlookupTable['1'] = lookupTable.i;\n/**\n * @param input The input array to encode.\n * @returns A Base32 string encoding the input.\n */\n\nexport function encode(input) {\n  // How many bits will we skip from the first byte.\n  var skip = 0; // 5 high bits, carry from one byte to the next.\n\n  var bits = 0; // The output string in base32.\n\n  var output = '';\n\n  function encodeByte(byte) {\n    if (skip < 0) {\n      // we have a carry from the previous byte\n      bits |= byte >> -skip;\n    } else {\n      // no carry\n      bits = byte << skip & 248;\n    }\n\n    if (skip > 3) {\n      // Not enough data to produce a character, get us another one\n      skip -= 8;\n      return 1;\n    }\n\n    if (skip < 4) {\n      // produce a character\n      output += alphabet[bits >> 3];\n      skip += 5;\n    }\n\n    return 0;\n  }\n\n  for (var _i = 0; _i < input.length;) {\n    _i += encodeByte(input[_i]);\n  }\n\n  return output + (skip < 0 ? alphabet[bits >> 3] : '');\n}\n/**\n * @param input The base32 encoded string to decode.\n */\n\nexport function decode(input) {\n  // how many bits we have from the previous character.\n  var skip = 0; // current byte we're producing.\n\n  var byte = 0;\n  var output = new Uint8Array(input.length * 4 / 3 | 0);\n  var o = 0;\n\n  function decodeChar(char) {\n    // Consume a character from the stream, store\n    // the output in this.output. As before, better\n    // to use update().\n    var val = lookupTable[char.toLowerCase()];\n\n    if (val === undefined) {\n      throw new Error(\"Invalid character: \".concat(JSON.stringify(char)));\n    } // move to the high bits\n\n\n    val <<= 3;\n    byte |= val >>> skip;\n    skip += 5;\n\n    if (skip >= 8) {\n      // We have enough bytes to produce an output\n      output[o++] = byte;\n      skip -= 8;\n\n      if (skip > 0) {\n        byte = val << 5 - skip & 255;\n      } else {\n        byte = 0;\n      }\n    }\n  }\n\n  var _iterator = _createForOfIteratorHelper(input),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var c = _step.value;\n      decodeChar(c);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return output.slice(0, o);\n}","map":{"version":3,"sources":["../../../src/utils/base32.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// tslint:disable:no-bitwise\nconst alphabet = 'abcdefghijklmnopqrstuvwxyz234567';\n// Build a lookup table for decoding.\nconst lookupTable = Object.create(null);\nfor (let i = 0; i < alphabet.length; i++) {\n    lookupTable[alphabet[i]] = i;\n}\n// Add aliases for rfc4648.\nlookupTable['0'] = lookupTable.o;\nlookupTable['1'] = lookupTable.i;\n/**\n * @param input The input array to encode.\n * @returns A Base32 string encoding the input.\n */\nexport function encode(input) {\n    // How many bits will we skip from the first byte.\n    let skip = 0;\n    // 5 high bits, carry from one byte to the next.\n    let bits = 0;\n    // The output string in base32.\n    let output = '';\n    function encodeByte(byte) {\n        if (skip < 0) {\n            // we have a carry from the previous byte\n            bits |= byte >> -skip;\n        }\n        else {\n            // no carry\n            bits = (byte << skip) & 248;\n        }\n        if (skip > 3) {\n            // Not enough data to produce a character, get us another one\n            skip -= 8;\n            return 1;\n        }\n        if (skip < 4) {\n            // produce a character\n            output += alphabet[bits >> 3];\n            skip += 5;\n        }\n        return 0;\n    }\n    for (let i = 0; i < input.length;) {\n        i += encodeByte(input[i]);\n    }\n    return output + (skip < 0 ? alphabet[bits >> 3] : '');\n}\n/**\n * @param input The base32 encoded string to decode.\n */\nexport function decode(input) {\n    // how many bits we have from the previous character.\n    let skip = 0;\n    // current byte we're producing.\n    let byte = 0;\n    const output = new Uint8Array(((input.length * 4) / 3) | 0);\n    let o = 0;\n    function decodeChar(char) {\n        // Consume a character from the stream, store\n        // the output in this.output. As before, better\n        // to use update().\n        let val = lookupTable[char.toLowerCase()];\n        if (val === undefined) {\n            throw new Error(`Invalid character: ${JSON.stringify(char)}`);\n        }\n        // move to the high bits\n        val <<= 3;\n        byte |= val >>> skip;\n        skip += 5;\n        if (skip >= 8) {\n            // We have enough bytes to produce an output\n            output[o++] = byte;\n            skip -= 8;\n            if (skip > 0) {\n                byte = (val << (5 - skip)) & 255;\n            }\n            else {\n                byte = 0;\n            }\n        }\n    }\n    for (const c of input) {\n        decodeChar(c);\n    }\n    return output.slice(0, o);\n}\n//# sourceMappingURL=base32.js.map"]},"metadata":{},"sourceType":"module"}