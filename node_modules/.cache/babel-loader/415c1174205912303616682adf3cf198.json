{"ast":null,"code":"/**\n * Concatenate multiple array buffers.\n * @param buffers The buffers to concatenate.\n */\nexport function concat(...buffers) {\n  const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));\n  let index = 0;\n\n  for (const b of buffers) {\n    result.set(new Uint8Array(b), index);\n    index += b.byteLength;\n  }\n\n  return result.buffer;\n}\n/**\n * Transforms a buffer to an hexadecimal string. This will use the buffer as an Uint8Array.\n * @param buffer The buffer to return the hexadecimal string of.\n */\n\nexport function toHex(buffer) {\n  return [...new Uint8Array(buffer)].map(x => x.toString(16).padStart(2, '0')).join('');\n}\nconst hexRe = /^([0-9A-F]{2})*$/i.compile();\n/**\n * Transforms a hexadecimal string into an array buffer.\n * @param hex The hexadecimal string to use.\n */\n\nexport function fromHex(hex) {\n  if (!hexRe.test(hex)) {\n    throw new Error('Invalid hexadecimal string.');\n  }\n\n  const buffer = [...hex].reduce((acc, curr, i) => {\n    // tslint:disable-next-line:no-bitwise\n    acc[i / 2 | 0] = (acc[i / 2 | 0] || '') + curr;\n    return acc;\n  }, []).map(x => Number.parseInt(x, 16));\n  return new Uint8Array(buffer).buffer;\n}\nexport function compare(b1, b2) {\n  if (b1.byteLength !== b2.byteLength) {\n    return b1.byteLength - b2.byteLength;\n  }\n\n  const u1 = new Uint8Array(b1);\n  const u2 = new Uint8Array(b2);\n\n  for (let i = 0; i < u1.length; i++) {\n    if (u1[i] !== u2[i]) {\n      return u1[i] - u2[i];\n    }\n  }\n\n  return 0;\n}","map":{"version":3,"sources":["../../../src/utils/buffer.ts"],"names":[],"mappings":"AAAA;;;AAGG;AACH,OAAM,SAAU,MAAV,CAAiB,GAAG,OAApB,EAA0C;AAC9C,QAAM,MAAM,GAAG,IAAI,UAAJ,CAAe,OAAO,CAAC,MAAR,CAAe,CAAC,GAAD,EAAM,IAAN,KAAe,GAAG,GAAG,IAAI,CAAC,UAAzC,EAAqD,CAArD,CAAf,CAAf;AACA,MAAI,KAAK,GAAG,CAAZ;;AACA,OAAK,MAAM,CAAX,IAAgB,OAAhB,EAAyB;AACvB,IAAA,MAAM,CAAC,GAAP,CAAW,IAAI,UAAJ,CAAe,CAAf,CAAX,EAA8B,KAA9B;AACA,IAAA,KAAK,IAAI,CAAC,CAAC,UAAX;AACD;;AACD,SAAO,MAAM,CAAC,MAAd;AACD;AAED;;;AAGG;;AACH,OAAM,SAAU,KAAV,CAAgB,MAAhB,EAAmC;AACvC,SAAO,CAAC,GAAG,IAAI,UAAJ,CAAe,MAAf,CAAJ,EAA4B,GAA5B,CAAgC,CAAC,IAAI,CAAC,CAAC,QAAF,CAAW,EAAX,EAAe,QAAf,CAAwB,CAAxB,EAA2B,GAA3B,CAArC,EAAsE,IAAtE,CAA2E,EAA3E,CAAP;AACD;AAED,MAAM,KAAK,GAAG,oBAAoB,OAApB,EAAd;AAEA;;;AAGG;;AACH,OAAM,SAAU,OAAV,CAAkB,GAAlB,EAA6B;AACjC,MAAI,CAAC,KAAK,CAAC,IAAN,CAAW,GAAX,CAAL,EAAsB;AACpB,UAAM,IAAI,KAAJ,CAAU,6BAAV,CAAN;AACD;;AACD,QAAM,MAAM,GAAG,CAAC,GAAG,GAAJ,EACZ,MADY,CACL,CAAC,GAAD,EAAM,IAAN,EAAY,CAAZ,KAAiB;AACvB;AACA,IAAA,GAAG,CAAE,CAAC,GAAG,CAAL,GAAU,CAAX,CAAH,GAAmB,CAAC,GAAG,CAAE,CAAC,GAAG,CAAL,GAAU,CAAX,CAAH,IAAoB,EAArB,IAA2B,IAA9C;AACA,WAAO,GAAP;AACD,GALY,EAKV,EALU,EAMZ,GANY,CAMR,CAAC,IAAI,MAAM,CAAC,QAAP,CAAgB,CAAhB,EAAmB,EAAnB,CANG,CAAf;AAQA,SAAO,IAAI,UAAJ,CAAe,MAAf,EAAuB,MAA9B;AACD;AAED,OAAM,SAAU,OAAV,CAAkB,EAAlB,EAAmC,EAAnC,EAAkD;AACtD,MAAI,EAAE,CAAC,UAAH,KAAkB,EAAE,CAAC,UAAzB,EAAqC;AACnC,WAAO,EAAE,CAAC,UAAH,GAAgB,EAAE,CAAC,UAA1B;AACD;;AAED,QAAM,EAAE,GAAG,IAAI,UAAJ,CAAe,EAAf,CAAX;AACA,QAAM,EAAE,GAAG,IAAI,UAAJ,CAAe,EAAf,CAAX;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,EAAE,CAAC,MAAvB,EAA+B,CAAC,EAAhC,EAAoC;AAClC,QAAI,EAAE,CAAC,CAAD,CAAF,KAAU,EAAE,CAAC,CAAD,CAAhB,EAAqB;AACnB,aAAO,EAAE,CAAC,CAAD,CAAF,GAAQ,EAAE,CAAC,CAAD,CAAjB;AACD;AACF;;AACD,SAAO,CAAP;AACD","sourceRoot":"","sourcesContent":["/**\n * Concatenate multiple array buffers.\n * @param buffers The buffers to concatenate.\n */\nexport function concat(...buffers) {\n    const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));\n    let index = 0;\n    for (const b of buffers) {\n        result.set(new Uint8Array(b), index);\n        index += b.byteLength;\n    }\n    return result.buffer;\n}\n/**\n * Transforms a buffer to an hexadecimal string. This will use the buffer as an Uint8Array.\n * @param buffer The buffer to return the hexadecimal string of.\n */\nexport function toHex(buffer) {\n    return [...new Uint8Array(buffer)].map(x => x.toString(16).padStart(2, '0')).join('');\n}\nconst hexRe = /^([0-9A-F]{2})*$/i.compile();\n/**\n * Transforms a hexadecimal string into an array buffer.\n * @param hex The hexadecimal string to use.\n */\nexport function fromHex(hex) {\n    if (!hexRe.test(hex)) {\n        throw new Error('Invalid hexadecimal string.');\n    }\n    const buffer = [...hex]\n        .reduce((acc, curr, i) => {\n        // tslint:disable-next-line:no-bitwise\n        acc[(i / 2) | 0] = (acc[(i / 2) | 0] || '') + curr;\n        return acc;\n    }, [])\n        .map(x => Number.parseInt(x, 16));\n    return new Uint8Array(buffer).buffer;\n}\nexport function compare(b1, b2) {\n    if (b1.byteLength !== b2.byteLength) {\n        return b1.byteLength - b2.byteLength;\n    }\n    const u1 = new Uint8Array(b1);\n    const u2 = new Uint8Array(b2);\n    for (let i = 0; i < u1.length; i++) {\n        if (u1[i] !== u2[i]) {\n            return u1[i] - u2[i];\n        }\n    }\n    return 0;\n}\n//# sourceMappingURL=buffer.js.map"]},"metadata":{},"sourceType":"module"}