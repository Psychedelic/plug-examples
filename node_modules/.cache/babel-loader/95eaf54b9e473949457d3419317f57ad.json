{"ast":null,"code":"import _regeneratorRuntime from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { lebEncode } from '@dfinity/candid';\nimport * as cbor from 'simple-cbor';\nimport { makeNonce } from './types';\nvar NANOSECONDS_PER_MILLISECONDS = BigInt(1000000);\nvar REPLICA_PERMITTED_DRIFT_MILLISECONDS = BigInt(60 * 1000);\nexport var Expiry = /*#__PURE__*/function () {\n  function Expiry(deltaInMSec) {\n    _classCallCheck(this, Expiry);\n\n    // Use bigint because it can overflow the maximum number allowed in a double float.\n    this._value = (BigInt(Date.now()) + BigInt(deltaInMSec) - REPLICA_PERMITTED_DRIFT_MILLISECONDS) * NANOSECONDS_PER_MILLISECONDS;\n  }\n\n  _createClass(Expiry, [{\n    key: \"toCBOR\",\n    value: function toCBOR() {\n      // TODO: change this to take the minimum amount of space (it always takes 8 bytes now).\n      return cbor.value.u64(this._value.toString(16), 16);\n    }\n  }, {\n    key: \"toHash\",\n    value: function toHash() {\n      return lebEncode(this._value);\n    }\n  }]);\n\n  return Expiry;\n}();\n/**\n * Create a Nonce transform, which takes a function that returns a Buffer, and adds it\n * as the nonce to every call requests.\n * @param nonceFn A function that returns a buffer. By default uses a semi-random method.\n */\n\nexport function makeNonceTransform() {\n  var nonceFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : makeNonce;\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(request) {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // Nonce are only useful for async calls, to prevent replay attacks. Other types of\n              // calls don't need Nonce so we just skip creating one.\n              if (request.endpoint === \"call\"\n              /* Call */\n              ) {\n                  request.body.nonce = nonceFn();\n                }\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\n/**\n * Create a transform that adds a delay (by default 5 minutes) to the expiry.\n *\n * @param delayInMilliseconds The delay to add to the call time, in milliseconds.\n */\n\nexport function makeExpiryTransform(delayInMilliseconds) {\n  return /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(request) {\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              request.body.ingress_expiry = new Expiry(delayInMilliseconds);\n\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function (_x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n}","map":{"version":3,"sources":["../../../../src/agent/http/transforms.ts"],"names":[],"mappings":";;;;AAAA,SAAS,SAAT,QAA0B,iBAA1B;AACA,OAAO,KAAK,IAAZ,MAAsB,aAAtB;AACA,SAAkE,SAAlE,QAA0F,SAA1F;AAEA,IAAM,4BAA4B,GAAG,MAAM,CAAC,OAAD,CAA3C;AAEA,IAAM,oCAAoC,GAAG,MAAM,CAAC,KAAK,IAAN,CAAnD;AAEA,WAAa,MAAb;AAGE,kBAAY,WAAZ,EAA+B;AAAA;;AAC7B;AACA,SAAK,MAAL,GACE,CAAC,MAAM,CAAC,IAAI,CAAC,GAAL,EAAD,CAAN,GAAqB,MAAM,CAAC,WAAD,CAA3B,GAA2C,oCAA5C,IACA,4BAFF;AAGD;;AARH;AAAA;AAAA,WAUS,kBAAM;AACX;AACA,aAAO,IAAI,CAAC,KAAL,CAAW,GAAX,CAAe,KAAK,MAAL,CAAY,QAAZ,CAAqB,EAArB,CAAf,EAAyC,EAAzC,CAAP;AACD;AAbH;AAAA;AAAA,WAeS,kBAAM;AACX,aAAO,SAAS,CAAC,KAAK,MAAN,CAAhB;AACD;AAjBH;;AAAA;AAAA;AAoBA;;;;AAIG;;AACH,OAAM,SAAU,kBAAV,GAA6D;AAAA,MAAhC,OAAgC,uEAAT,SAAS;AACjE;AAAA,wEAAO,iBAAO,OAAP;AAAA;AAAA;AAAA;AAAA;AACL;AACA;AACA,kBAAI,OAAO,CAAC,QAAR,KAAgB;AAAA;AAApB,gBAAwC;AACtC,kBAAA,OAAO,CAAC,IAAR,CAAa,KAAb,GAAqB,OAAO,EAA5B;AACD;;AALI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAP;;AAAA;AAAA;AAAA;AAAA;AAOD;AAED;;;;AAIG;;AACH,OAAM,SAAU,mBAAV,CAA8B,mBAA9B,EAAyD;AAC7D;AAAA,yEAAO,kBAAO,OAAP;AAAA;AAAA;AAAA;AAAA;AACL,cAAA,OAAO,CAAC,IAAR,CAAa,cAAb,GAA8B,IAAI,MAAJ,CAAW,mBAAX,CAA9B;;AADK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAP;;AAAA;AAAA;AAAA;AAAA;AAGD","sourceRoot":"","sourcesContent":["import { lebEncode } from '@dfinity/candid';\nimport * as cbor from 'simple-cbor';\nimport { makeNonce } from './types';\nconst NANOSECONDS_PER_MILLISECONDS = BigInt(1000000);\nconst REPLICA_PERMITTED_DRIFT_MILLISECONDS = BigInt(60 * 1000);\nexport class Expiry {\n    constructor(deltaInMSec) {\n        // Use bigint because it can overflow the maximum number allowed in a double float.\n        this._value =\n            (BigInt(Date.now()) + BigInt(deltaInMSec) - REPLICA_PERMITTED_DRIFT_MILLISECONDS) *\n                NANOSECONDS_PER_MILLISECONDS;\n    }\n    toCBOR() {\n        // TODO: change this to take the minimum amount of space (it always takes 8 bytes now).\n        return cbor.value.u64(this._value.toString(16), 16);\n    }\n    toHash() {\n        return lebEncode(this._value);\n    }\n}\n/**\n * Create a Nonce transform, which takes a function that returns a Buffer, and adds it\n * as the nonce to every call requests.\n * @param nonceFn A function that returns a buffer. By default uses a semi-random method.\n */\nexport function makeNonceTransform(nonceFn = makeNonce) {\n    return async (request) => {\n        // Nonce are only useful for async calls, to prevent replay attacks. Other types of\n        // calls don't need Nonce so we just skip creating one.\n        if (request.endpoint === \"call\" /* Call */) {\n            request.body.nonce = nonceFn();\n        }\n    };\n}\n/**\n * Create a transform that adds a delay (by default 5 minutes) to the expiry.\n *\n * @param delayInMilliseconds The delay to add to the call time, in milliseconds.\n */\nexport function makeExpiryTransform(delayInMilliseconds) {\n    return async (request) => {\n        request.body.ingress_expiry = new Expiry(delayInMilliseconds);\n    };\n}\n//# sourceMappingURL=transforms.js.map"]},"metadata":{},"sourceType":"module"}