{"ast":null,"code":"import { decode, encode } from './utils/base32';\nimport { getCrc32 } from './utils/getCrc';\nimport { sha224 } from './utils/sha224';\nconst SELF_AUTHENTICATING_SUFFIX = 2;\nconst ANONYMOUS_SUFFIX = 4;\n\nconst fromHexString = hexString => {\n  var _a;\n\n  return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== void 0 ? _a : []).map(byte => parseInt(byte, 16)));\n};\n\nconst toHexString = bytes => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n\nexport class Principal {\n  constructor(_arr) {\n    this._arr = _arr;\n    this._isPrincipal = true;\n  }\n\n  static anonymous() {\n    return new this(new Uint8Array([ANONYMOUS_SUFFIX]));\n  }\n\n  static selfAuthenticating(publicKey) {\n    const sha = sha224(publicKey);\n    return new this(new Uint8Array([...sha, SELF_AUTHENTICATING_SUFFIX]));\n  }\n\n  static from(other) {\n    if (typeof other === 'string') {\n      return Principal.fromText(other);\n    } else if (typeof other === 'object' && other !== null && other._isPrincipal === true) {\n      return new Principal(other._arr);\n    }\n\n    throw new Error(`Impossible to convert ${JSON.stringify(other)} to Principal.`);\n  }\n\n  static fromHex(hex) {\n    return new this(fromHexString(hex));\n  }\n\n  static fromText(text) {\n    const canisterIdNoDash = text.toLowerCase().replace(/-/g, '');\n    let arr = decode(canisterIdNoDash);\n    arr = arr.slice(4, arr.length);\n    const principal = new this(arr);\n\n    if (principal.toText() !== text) {\n      throw new Error(`Principal \"${principal.toText()}\" does not have a valid checksum.`);\n    }\n\n    return principal;\n  }\n\n  static fromUint8Array(arr) {\n    return new this(arr);\n  }\n\n  isAnonymous() {\n    return this._arr.byteLength === 1 && this._arr[0] === ANONYMOUS_SUFFIX;\n  }\n\n  toUint8Array() {\n    return this._arr;\n  }\n\n  toHex() {\n    return toHexString(this._arr).toUpperCase();\n  }\n\n  toText() {\n    const checksumArrayBuf = new ArrayBuffer(4);\n    const view = new DataView(checksumArrayBuf);\n    view.setUint32(0, getCrc32(this._arr));\n    const checksum = new Uint8Array(checksumArrayBuf);\n    const bytes = Uint8Array.from(this._arr);\n    const array = new Uint8Array([...checksum, ...bytes]);\n    const result = encode(array);\n    const matches = result.match(/.{1,5}/g);\n\n    if (!matches) {\n      // This should only happen if there's no character, which is unreachable.\n      throw new Error();\n    }\n\n    return matches.join('-');\n  }\n\n  toString() {\n    return this.toText();\n  }\n\n}","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { decode, encode } from './utils/base32';\nimport { getCrc32 } from './utils/getCrc';\nimport { sha224 } from './utils/sha224';\nconst SELF_AUTHENTICATING_SUFFIX = 2;\nconst ANONYMOUS_SUFFIX = 4;\nconst fromHexString = (hexString) => { var _a; return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== void 0 ? _a : []).map(byte => parseInt(byte, 16))); };\nconst toHexString = (bytes) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\nexport class Principal {\n    constructor(_arr) {\n        this._arr = _arr;\n        this._isPrincipal = true;\n    }\n    static anonymous() {\n        return new this(new Uint8Array([ANONYMOUS_SUFFIX]));\n    }\n    static selfAuthenticating(publicKey) {\n        const sha = sha224(publicKey);\n        return new this(new Uint8Array([...sha, SELF_AUTHENTICATING_SUFFIX]));\n    }\n    static from(other) {\n        if (typeof other === 'string') {\n            return Principal.fromText(other);\n        }\n        else if (typeof other === 'object' &&\n            other !== null &&\n            other._isPrincipal === true) {\n            return new Principal(other._arr);\n        }\n        throw new Error(`Impossible to convert ${JSON.stringify(other)} to Principal.`);\n    }\n    static fromHex(hex) {\n        return new this(fromHexString(hex));\n    }\n    static fromText(text) {\n        const canisterIdNoDash = text.toLowerCase().replace(/-/g, '');\n        let arr = decode(canisterIdNoDash);\n        arr = arr.slice(4, arr.length);\n        const principal = new this(arr);\n        if (principal.toText() !== text) {\n            throw new Error(`Principal \"${principal.toText()}\" does not have a valid checksum.`);\n        }\n        return principal;\n    }\n    static fromUint8Array(arr) {\n        return new this(arr);\n    }\n    isAnonymous() {\n        return this._arr.byteLength === 1 && this._arr[0] === ANONYMOUS_SUFFIX;\n    }\n    toUint8Array() {\n        return this._arr;\n    }\n    toHex() {\n        return toHexString(this._arr).toUpperCase();\n    }\n    toText() {\n        const checksumArrayBuf = new ArrayBuffer(4);\n        const view = new DataView(checksumArrayBuf);\n        view.setUint32(0, getCrc32(this._arr));\n        const checksum = new Uint8Array(checksumArrayBuf);\n        const bytes = Uint8Array.from(this._arr);\n        const array = new Uint8Array([...checksum, ...bytes]);\n        const result = encode(array);\n        const matches = result.match(/.{1,5}/g);\n        if (!matches) {\n            // This should only happen if there's no character, which is unreachable.\n            throw new Error();\n        }\n        return matches.join('-');\n    }\n    toString() {\n        return this.toText();\n    }\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}