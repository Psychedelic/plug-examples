{"ast":null,"code":"// tslint:disable:max-classes-per-file\n// This file is based on:\n// tslint:disable-next-line: max-line-length\n// https://github.com/dfinity-lab/dfinity/blob/9bca65f8edd65701ea6bdb00e0752f9186bbc893/docs/spec/public/index.adoc#cbor-encoding-of-requests-and-responses\nimport borc from 'borc';\nimport * as cbor from 'simple-cbor';\nimport { SelfDescribeCborSerializer } from 'simple-cbor';\nimport { concat, fromHex } from './utils/buffer'; // We are using hansl/simple-cbor for CBOR serialization, to avoid issues with\n// encoding the uint64 values that the HTTP handler of the client expects for\n// canister IDs. However, simple-cbor does not yet provide deserialization so\n// we are using `Uint8Array` so that we can use the dignifiedquire/borc CBOR\n// decoder.\n\nclass PrincipalEncoder {\n  get name() {\n    return 'Principal';\n  }\n\n  get priority() {\n    return 0;\n  }\n\n  match(value) {\n    return value && value._isPrincipal === true;\n  }\n\n  encode(v) {\n    return cbor.value.bytes(v.toUint8Array());\n  }\n\n}\n\nclass BufferEncoder {\n  get name() {\n    return 'Buffer';\n  }\n\n  get priority() {\n    return 1;\n  }\n\n  match(value) {\n    return value instanceof ArrayBuffer || ArrayBuffer.isView(value);\n  }\n\n  encode(v) {\n    return cbor.value.bytes(new Uint8Array(v));\n  }\n\n}\n\nclass BigIntEncoder {\n  get name() {\n    return 'BigInt';\n  }\n\n  get priority() {\n    return 1;\n  }\n\n  match(value) {\n    return typeof value === `bigint`;\n  }\n\n  encode(v) {\n    // Always use a bigint encoding.\n    if (v > BigInt(0)) {\n      return cbor.value.tagged(2, cbor.value.bytes(fromHex(v.toString(16))));\n    } else {\n      return cbor.value.tagged(3, cbor.value.bytes(fromHex((BigInt('-1') * v).toString(16))));\n    }\n  }\n\n}\n\nconst serializer = SelfDescribeCborSerializer.withDefaultEncoders(true);\nserializer.addEncoder(new PrincipalEncoder());\nserializer.addEncoder(new BufferEncoder());\nserializer.addEncoder(new BigIntEncoder());\nexport var CborTag;\n\n(function (CborTag) {\n  CborTag[CborTag[\"Uint64LittleEndian\"] = 71] = \"Uint64LittleEndian\";\n  CborTag[CborTag[\"Semantic\"] = 55799] = \"Semantic\";\n})(CborTag || (CborTag = {}));\n/**\n * Encode a JavaScript value into CBOR.\n */\n\n\nexport function encode(value) {\n  return serializer.serialize(value);\n}\n\nfunction decodePositiveBigInt(buf) {\n  const len = buf.byteLength;\n  let res = BigInt(0);\n\n  for (let i = 0; i < len; i++) {\n    // tslint:disable-next-line:no-bitwise\n    res = res * BigInt(0x100) + BigInt(buf[i]);\n  }\n\n  return res;\n} // A BORC subclass that decodes byte strings to ArrayBuffer instead of the Buffer class.\n\n\nclass Uint8ArrayDecoder extends borc.Decoder {\n  createByteString(raw) {\n    return concat(...raw);\n  }\n\n  createByteStringFromHeap(start, end) {\n    if (start === end) {\n      return new ArrayBuffer(0);\n    }\n\n    return new Uint8Array(this._heap.slice(start, end));\n  }\n\n}\n\nexport function decode(input) {\n  const buffer = new Uint8Array(input);\n  const decoder = new Uint8ArrayDecoder({\n    size: buffer.byteLength,\n    tags: {\n      // Override tags 2 and 3 for BigInt support (borc supports only BigNumber).\n      2: val => decodePositiveBigInt(val),\n      3: val => -decodePositiveBigInt(val),\n      [CborTag.Semantic]: value => value\n    }\n  });\n  return decoder.decodeFirst(buffer);\n}","map":{"version":3,"sources":["../../src/cbor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// tslint:disable:max-classes-per-file\n// This file is based on:\n// tslint:disable-next-line: max-line-length\n// https://github.com/dfinity-lab/dfinity/blob/9bca65f8edd65701ea6bdb00e0752f9186bbc893/docs/spec/public/index.adoc#cbor-encoding-of-requests-and-responses\nimport borc from 'borc';\nimport * as cbor from 'simple-cbor';\nimport { SelfDescribeCborSerializer } from 'simple-cbor';\nimport { concat, fromHex } from './utils/buffer';\n// We are using hansl/simple-cbor for CBOR serialization, to avoid issues with\n// encoding the uint64 values that the HTTP handler of the client expects for\n// canister IDs. However, simple-cbor does not yet provide deserialization so\n// we are using `Uint8Array` so that we can use the dignifiedquire/borc CBOR\n// decoder.\nclass PrincipalEncoder {\n    get name() {\n        return 'Principal';\n    }\n    get priority() {\n        return 0;\n    }\n    match(value) {\n        return value && value._isPrincipal === true;\n    }\n    encode(v) {\n        return cbor.value.bytes(v.toUint8Array());\n    }\n}\nclass BufferEncoder {\n    get name() {\n        return 'Buffer';\n    }\n    get priority() {\n        return 1;\n    }\n    match(value) {\n        return value instanceof ArrayBuffer || ArrayBuffer.isView(value);\n    }\n    encode(v) {\n        return cbor.value.bytes(new Uint8Array(v));\n    }\n}\nclass BigIntEncoder {\n    get name() {\n        return 'BigInt';\n    }\n    get priority() {\n        return 1;\n    }\n    match(value) {\n        return typeof value === `bigint`;\n    }\n    encode(v) {\n        // Always use a bigint encoding.\n        if (v > BigInt(0)) {\n            return cbor.value.tagged(2, cbor.value.bytes(fromHex(v.toString(16))));\n        }\n        else {\n            return cbor.value.tagged(3, cbor.value.bytes(fromHex((BigInt('-1') * v).toString(16))));\n        }\n    }\n}\nconst serializer = SelfDescribeCborSerializer.withDefaultEncoders(true);\nserializer.addEncoder(new PrincipalEncoder());\nserializer.addEncoder(new BufferEncoder());\nserializer.addEncoder(new BigIntEncoder());\nexport var CborTag;\n(function (CborTag) {\n    CborTag[CborTag[\"Uint64LittleEndian\"] = 71] = \"Uint64LittleEndian\";\n    CborTag[CborTag[\"Semantic\"] = 55799] = \"Semantic\";\n})(CborTag || (CborTag = {}));\n/**\n * Encode a JavaScript value into CBOR.\n */\nexport function encode(value) {\n    return serializer.serialize(value);\n}\nfunction decodePositiveBigInt(buf) {\n    const len = buf.byteLength;\n    let res = BigInt(0);\n    for (let i = 0; i < len; i++) {\n        // tslint:disable-next-line:no-bitwise\n        res = res * BigInt(0x100) + BigInt(buf[i]);\n    }\n    return res;\n}\n// A BORC subclass that decodes byte strings to ArrayBuffer instead of the Buffer class.\nclass Uint8ArrayDecoder extends borc.Decoder {\n    createByteString(raw) {\n        return concat(...raw);\n    }\n    createByteStringFromHeap(start, end) {\n        if (start === end) {\n            return new ArrayBuffer(0);\n        }\n        return new Uint8Array(this._heap.slice(start, end));\n    }\n}\nexport function decode(input) {\n    const buffer = new Uint8Array(input);\n    const decoder = new Uint8ArrayDecoder({\n        size: buffer.byteLength,\n        tags: {\n            // Override tags 2 and 3 for BigInt support (borc supports only BigNumber).\n            2: val => decodePositiveBigInt(val),\n            3: val => -decodePositiveBigInt(val),\n            [CborTag.Semantic]: (value) => value,\n        },\n    });\n    return decoder.decodeFirst(buffer);\n}\n//# sourceMappingURL=cbor.js.map"]},"metadata":{},"sourceType":"module"}