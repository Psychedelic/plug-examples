{"ast":null,"code":"import { getDefaultAgent } from './agent';\nimport * as cbor from './cbor';\nimport { AgentError } from './errors';\nimport { hash } from './request_id';\nimport { blsVerify } from './utils/bls';\nimport { concat, fromHex, toHex } from './utils/buffer';\n/**\n * A certificate needs to be verified (using {@link Certificate.prototype.verify})\n * before it can be used.\n */\n\nexport class UnverifiedCertificateError extends AgentError {\n  constructor() {\n    super(`Cannot lookup unverified certificate. Call 'verify()' first.`);\n  }\n\n}\n/**\n * Make a human readable string out of a hash tree.\n * @param tree\n */\n\nexport function hashTreeToString(tree) {\n  const indent = s => s.split('\\n').map(x => '  ' + x).join('\\n');\n\n  function labelToString(label) {\n    const decoder = new TextDecoder(undefined, {\n      fatal: true\n    });\n\n    try {\n      return JSON.stringify(decoder.decode(label));\n    } catch (e) {\n      return `data(...${label.byteLength} bytes)`;\n    }\n  }\n\n  switch (tree[0]) {\n    case 0\n    /* Empty */\n    :\n      return '()';\n\n    case 1\n    /* Fork */\n    :\n      {\n        const left = hashTreeToString(tree[1]);\n        const right = hashTreeToString(tree[2]);\n        return `sub(\\n left:\\n${indent(left)}\\n---\\n right:\\n${indent(right)}\\n)`;\n      }\n\n    case 2\n    /* Labeled */\n    :\n      {\n        const label = labelToString(tree[1]);\n        const sub = hashTreeToString(tree[2]);\n        return `label(\\n label:\\n${indent(label)}\\n sub:\\n${indent(sub)}\\n)`;\n      }\n\n    case 3\n    /* Leaf */\n    :\n      {\n        return `leaf(...${tree[1].byteLength} bytes)`;\n      }\n\n    case 4\n    /* Pruned */\n    :\n      {\n        return `pruned(${toHex(new Uint8Array(tree[1]))}`;\n      }\n\n    default:\n      {\n        return `unknown(${JSON.stringify(tree[0])})`;\n      }\n  }\n}\n\nfunction isBufferEqual(a, b) {\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n\n  const a8 = new Uint8Array(a);\n  const b8 = new Uint8Array(b);\n\n  for (let i = 0; i < a8.length; i++) {\n    if (a8[i] !== b8[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport class Certificate {\n  constructor(response, _agent = getDefaultAgent()) {\n    this._agent = _agent;\n    this.verified = false;\n    this._rootKey = null;\n    this.cert = cbor.decode(new Uint8Array(response.certificate));\n  }\n\n  lookup(path) {\n    this.checkState();\n    return lookup_path(path, this.cert.tree);\n  }\n\n  async verify() {\n    const rootHash = await reconstruct(this.cert.tree);\n    const derKey = await this._checkDelegation(this.cert.delegation);\n    const sig = this.cert.signature;\n    const key = extractDER(derKey);\n    const msg = concat(domain_sep('ic-state-root'), rootHash);\n    const res = await blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));\n    this.verified = res;\n    return res;\n  }\n\n  checkState() {\n    if (!this.verified) {\n      throw new UnverifiedCertificateError();\n    }\n  }\n\n  async _checkDelegation(d) {\n    if (!d) {\n      if (!this._rootKey) {\n        if (this._agent.rootKey) {\n          this._rootKey = this._agent.rootKey;\n          return this._rootKey;\n        }\n\n        throw new Error(`Agent does not have a rootKey. Do you need to call 'fetchRootKey'?`);\n      }\n\n      return this._rootKey;\n    }\n\n    const cert = new Certificate(d, this._agent);\n\n    if (!(await cert.verify())) {\n      throw new Error('fail to verify delegation certificate');\n    }\n\n    const lookup = cert.lookup(['subnet', d.subnet_id, 'public_key']);\n\n    if (!lookup) {\n      throw new Error(`Could not find subnet key for subnet 0x${toHex(d.subnet_id)}`);\n    }\n\n    return lookup;\n  }\n\n}\nconst DER_PREFIX = fromHex('308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100');\nconst KEY_LENGTH = 96;\n\nfunction extractDER(buf) {\n  const expectedLength = DER_PREFIX.byteLength + KEY_LENGTH;\n\n  if (buf.byteLength !== expectedLength) {\n    throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);\n  }\n\n  const prefix = buf.slice(0, DER_PREFIX.byteLength);\n\n  if (!isBufferEqual(prefix, DER_PREFIX)) {\n    throw new TypeError(`BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX}, but get ${prefix}`);\n  }\n\n  return buf.slice(DER_PREFIX.byteLength);\n}\n/**\n * @param t\n */\n\n\nexport async function reconstruct(t) {\n  switch (t[0]) {\n    case 0\n    /* Empty */\n    :\n      return hash(domain_sep('ic-hashtree-empty'));\n\n    case 4\n    /* Pruned */\n    :\n      return t[1];\n\n    case 3\n    /* Leaf */\n    :\n      return hash(concat(domain_sep('ic-hashtree-leaf'), t[1]));\n\n    case 2\n    /* Labeled */\n    :\n      return hash(concat(domain_sep('ic-hashtree-labeled'), t[1], await reconstruct(t[2])));\n\n    case 1\n    /* Fork */\n    :\n      return hash(concat(domain_sep('ic-hashtree-fork'), await reconstruct(t[1]), await reconstruct(t[2])));\n\n    default:\n      throw new Error('unreachable');\n  }\n}\n\nfunction domain_sep(s) {\n  const len = new Uint8Array([s.length]);\n  const str = new TextEncoder().encode(s);\n  return concat(len, str);\n}\n/**\n * @param path\n * @param tree\n */\n\n\nexport function lookup_path(path, tree) {\n  if (path.length === 0) {\n    switch (tree[0]) {\n      case 3\n      /* Leaf */\n      :\n        {\n          return new Uint8Array(tree[1]).buffer;\n        }\n\n      default:\n        {\n          return undefined;\n        }\n    }\n  }\n\n  const label = typeof path[0] === 'string' ? new TextEncoder().encode(path[0]) : path[0];\n  const t = find_label(label, flatten_forks(tree));\n\n  if (t) {\n    return lookup_path(path.slice(1), t);\n  }\n}\n\nfunction flatten_forks(t) {\n  switch (t[0]) {\n    case 0\n    /* Empty */\n    :\n      return [];\n\n    case 1\n    /* Fork */\n    :\n      return flatten_forks(t[1]).concat(flatten_forks(t[2]));\n\n    default:\n      return [t];\n  }\n}\n\nfunction find_label(l, trees) {\n  if (trees.length === 0) {\n    return undefined;\n  }\n\n  for (const t of trees) {\n    if (t[0] === 2\n    /* Labeled */\n    ) {\n        const p = t[1];\n\n        if (isBufferEqual(l, p)) {\n          return t[2];\n        }\n      }\n  }\n}","map":{"version":3,"sources":["../../src/certificate.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { getDefaultAgent } from './agent';\nimport * as cbor from './cbor';\nimport { AgentError } from './errors';\nimport { hash } from './request_id';\nimport { blsVerify } from './utils/bls';\nimport { concat, fromHex, toHex } from './utils/buffer';\n/**\n * A certificate needs to be verified (using {@link Certificate.prototype.verify})\n * before it can be used.\n */\nexport class UnverifiedCertificateError extends AgentError {\n    constructor() {\n        super(`Cannot lookup unverified certificate. Call 'verify()' first.`);\n    }\n}\n/**\n * Make a human readable string out of a hash tree.\n * @param tree\n */\nexport function hashTreeToString(tree) {\n    const indent = (s) => s\n        .split('\\n')\n        .map(x => '  ' + x)\n        .join('\\n');\n    function labelToString(label) {\n        const decoder = new TextDecoder(undefined, { fatal: true });\n        try {\n            return JSON.stringify(decoder.decode(label));\n        }\n        catch (e) {\n            return `data(...${label.byteLength} bytes)`;\n        }\n    }\n    switch (tree[0]) {\n        case 0 /* Empty */:\n            return '()';\n        case 1 /* Fork */: {\n            const left = hashTreeToString(tree[1]);\n            const right = hashTreeToString(tree[2]);\n            return `sub(\\n left:\\n${indent(left)}\\n---\\n right:\\n${indent(right)}\\n)`;\n        }\n        case 2 /* Labeled */: {\n            const label = labelToString(tree[1]);\n            const sub = hashTreeToString(tree[2]);\n            return `label(\\n label:\\n${indent(label)}\\n sub:\\n${indent(sub)}\\n)`;\n        }\n        case 3 /* Leaf */: {\n            return `leaf(...${tree[1].byteLength} bytes)`;\n        }\n        case 4 /* Pruned */: {\n            return `pruned(${toHex(new Uint8Array(tree[1]))}`;\n        }\n        default: {\n            return `unknown(${JSON.stringify(tree[0])})`;\n        }\n    }\n}\nfunction isBufferEqual(a, b) {\n    if (a.byteLength !== b.byteLength) {\n        return false;\n    }\n    const a8 = new Uint8Array(a);\n    const b8 = new Uint8Array(b);\n    for (let i = 0; i < a8.length; i++) {\n        if (a8[i] !== b8[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport class Certificate {\n    constructor(response, _agent = getDefaultAgent()) {\n        this._agent = _agent;\n        this.verified = false;\n        this._rootKey = null;\n        this.cert = cbor.decode(new Uint8Array(response.certificate));\n    }\n    lookup(path) {\n        this.checkState();\n        return lookup_path(path, this.cert.tree);\n    }\n    async verify() {\n        const rootHash = await reconstruct(this.cert.tree);\n        const derKey = await this._checkDelegation(this.cert.delegation);\n        const sig = this.cert.signature;\n        const key = extractDER(derKey);\n        const msg = concat(domain_sep('ic-state-root'), rootHash);\n        const res = await blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));\n        this.verified = res;\n        return res;\n    }\n    checkState() {\n        if (!this.verified) {\n            throw new UnverifiedCertificateError();\n        }\n    }\n    async _checkDelegation(d) {\n        if (!d) {\n            if (!this._rootKey) {\n                if (this._agent.rootKey) {\n                    this._rootKey = this._agent.rootKey;\n                    return this._rootKey;\n                }\n                throw new Error(`Agent does not have a rootKey. Do you need to call 'fetchRootKey'?`);\n            }\n            return this._rootKey;\n        }\n        const cert = new Certificate(d, this._agent);\n        if (!(await cert.verify())) {\n            throw new Error('fail to verify delegation certificate');\n        }\n        const lookup = cert.lookup(['subnet', d.subnet_id, 'public_key']);\n        if (!lookup) {\n            throw new Error(`Could not find subnet key for subnet 0x${toHex(d.subnet_id)}`);\n        }\n        return lookup;\n    }\n}\nconst DER_PREFIX = fromHex('308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100');\nconst KEY_LENGTH = 96;\nfunction extractDER(buf) {\n    const expectedLength = DER_PREFIX.byteLength + KEY_LENGTH;\n    if (buf.byteLength !== expectedLength) {\n        throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);\n    }\n    const prefix = buf.slice(0, DER_PREFIX.byteLength);\n    if (!isBufferEqual(prefix, DER_PREFIX)) {\n        throw new TypeError(`BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX}, but get ${prefix}`);\n    }\n    return buf.slice(DER_PREFIX.byteLength);\n}\n/**\n * @param t\n */\nexport async function reconstruct(t) {\n    switch (t[0]) {\n        case 0 /* Empty */:\n            return hash(domain_sep('ic-hashtree-empty'));\n        case 4 /* Pruned */:\n            return t[1];\n        case 3 /* Leaf */:\n            return hash(concat(domain_sep('ic-hashtree-leaf'), t[1]));\n        case 2 /* Labeled */:\n            return hash(concat(domain_sep('ic-hashtree-labeled'), t[1], await reconstruct(t[2])));\n        case 1 /* Fork */:\n            return hash(concat(domain_sep('ic-hashtree-fork'), await reconstruct(t[1]), await reconstruct(t[2])));\n        default:\n            throw new Error('unreachable');\n    }\n}\nfunction domain_sep(s) {\n    const len = new Uint8Array([s.length]);\n    const str = new TextEncoder().encode(s);\n    return concat(len, str);\n}\n/**\n * @param path\n * @param tree\n */\nexport function lookup_path(path, tree) {\n    if (path.length === 0) {\n        switch (tree[0]) {\n            case 3 /* Leaf */: {\n                return new Uint8Array(tree[1]).buffer;\n            }\n            default: {\n                return undefined;\n            }\n        }\n    }\n    const label = typeof path[0] === 'string' ? new TextEncoder().encode(path[0]) : path[0];\n    const t = find_label(label, flatten_forks(tree));\n    if (t) {\n        return lookup_path(path.slice(1), t);\n    }\n}\nfunction flatten_forks(t) {\n    switch (t[0]) {\n        case 0 /* Empty */:\n            return [];\n        case 1 /* Fork */:\n            return flatten_forks(t[1]).concat(flatten_forks(t[2]));\n        default:\n            return [t];\n    }\n}\nfunction find_label(l, trees) {\n    if (trees.length === 0) {\n        return undefined;\n    }\n    for (const t of trees) {\n        if (t[0] === 2 /* Labeled */) {\n            const p = t[1];\n            if (isBufferEqual(l, p)) {\n                return t[2];\n            }\n        }\n    }\n}\n//# sourceMappingURL=certificate.js.map"]},"metadata":{},"sourceType":"module"}