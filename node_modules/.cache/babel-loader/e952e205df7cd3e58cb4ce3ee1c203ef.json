{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _regeneratorRuntime from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { toHex } from '../utils/buffer';\nvar FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n/**\n * A best practices polling strategy: wait 2 seconds before the first poll, then 1 second\n * with an exponential backoff factor of 1.2. Timeout after 5 minutes.\n */\n\nexport function defaultStrategy() {\n  return chain(conditionalDelay(once(), 1000), backoff(1000, 1.2), timeout(FIVE_MINUTES_IN_MSEC));\n}\n/**\n * Predicate that returns true once.\n */\n\nexport function once() {\n  var first = true;\n  return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!first) {\n              _context.next = 3;\n              break;\n            }\n\n            first = false;\n            return _context.abrupt(\"return\", true);\n\n          case 3:\n            return _context.abrupt(\"return\", false);\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n/**\n * Delay the polling once.\n * @param condition A predicate that indicates when to delay.\n * @param timeInMsec The amount of time to delay.\n */\n\nexport function conditionalDelay(condition, timeInMsec) {\n  return /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(canisterId, requestId, status) {\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return condition(canisterId, requestId, status);\n\n            case 2:\n              if (!_context2.sent) {\n                _context2.next = 4;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", new Promise(function (resolve) {\n                return setTimeout(resolve, timeInMsec);\n              }));\n\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function (_x, _x2, _x3) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n}\n/**\n * Error out after a maximum number of polling has been done.\n * @param count The maximum attempts to poll.\n */\n\nexport function maxAttempts(count) {\n  var attempts = count;\n  return /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(canisterId, requestId, status) {\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!(--attempts <= 0)) {\n                _context3.next = 2;\n                break;\n              }\n\n              throw new Error(\"Failed to retrieve a reply for request after \".concat(count, \" attempts:\\n\") + \"  Request ID: \".concat(toHex(requestId), \"\\n\") + \"  Request status: \".concat(status, \"\\n\"));\n\n            case 2:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    return function (_x4, _x5, _x6) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n}\n/**\n * Throttle polling.\n * @param throttleInMsec Amount in millisecond to wait between each polling.\n */\n\nexport function throttle(throttleInMsec) {\n  return function () {\n    return new Promise(function (resolve) {\n      return setTimeout(resolve, throttleInMsec);\n    });\n  };\n}\n/**\n * Reject a call after a certain amount of time.\n * @param timeInMsec Time in milliseconds before the polling should be rejected.\n */\n\nexport function timeout(timeInMsec) {\n  var end = Date.now() + timeInMsec;\n  return /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(canisterId, requestId, status) {\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              if (!(Date.now() > end)) {\n                _context4.next = 2;\n                break;\n              }\n\n              throw new Error(\"Request timed out after \".concat(timeInMsec, \" msec:\\n\") + \"  Request ID: \".concat(toHex(requestId), \"\\n\") + \"  Request status: \".concat(status, \"\\n\"));\n\n            case 2:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    return function (_x7, _x8, _x9) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n}\n/**\n * A strategy that throttle, but using an exponential backoff strategy.\n * @param startingThrottleInMsec The throttle in milliseconds to start with.\n * @param backoffFactor The factor to multiple the throttle time between every poll. For\n *   example if using 2, the throttle will double between every run.\n */\n\nexport function backoff(startingThrottleInMsec, backoffFactor) {\n  var currentThrottling = startingThrottleInMsec;\n  return function () {\n    return new Promise(function (resolve) {\n      return setTimeout(function () {\n        currentThrottling *= backoffFactor;\n        resolve();\n      }, currentThrottling);\n    });\n  };\n}\n/**\n * Chain multiple polling strategy. This _chains_ the strategies, so if you pass in,\n * say, two throttling strategy of 1 second, it will result in a throttle of 2 seconds.\n * @param strategies A strategy list to chain.\n */\n\nexport function chain() {\n  for (var _len = arguments.length, strategies = new Array(_len), _key = 0; _key < _len; _key++) {\n    strategies[_key] = arguments[_key];\n  }\n\n  return /*#__PURE__*/function () {\n    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(canisterId, requestId, status) {\n      var _iterator, _step, a;\n\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              _iterator = _createForOfIteratorHelper(strategies);\n              _context5.prev = 1;\n\n              _iterator.s();\n\n            case 3:\n              if ((_step = _iterator.n()).done) {\n                _context5.next = 9;\n                break;\n              }\n\n              a = _step.value;\n              _context5.next = 7;\n              return a(canisterId, requestId, status);\n\n            case 7:\n              _context5.next = 3;\n              break;\n\n            case 9:\n              _context5.next = 14;\n              break;\n\n            case 11:\n              _context5.prev = 11;\n              _context5.t0 = _context5[\"catch\"](1);\n\n              _iterator.e(_context5.t0);\n\n            case 14:\n              _context5.prev = 14;\n\n              _iterator.f();\n\n              return _context5.finish(14);\n\n            case 17:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5, null, [[1, 11, 14, 17]]);\n    }));\n\n    return function (_x10, _x11, _x12) {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n}","map":{"version":3,"sources":["../../../src/polling/strategy.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { toHex } from '../utils/buffer';\nconst FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n/**\n * A best practices polling strategy: wait 2 seconds before the first poll, then 1 second\n * with an exponential backoff factor of 1.2. Timeout after 5 minutes.\n */\nexport function defaultStrategy() {\n    return chain(conditionalDelay(once(), 1000), backoff(1000, 1.2), timeout(FIVE_MINUTES_IN_MSEC));\n}\n/**\n * Predicate that returns true once.\n */\nexport function once() {\n    let first = true;\n    return async () => {\n        if (first) {\n            first = false;\n            return true;\n        }\n        return false;\n    };\n}\n/**\n * Delay the polling once.\n * @param condition A predicate that indicates when to delay.\n * @param timeInMsec The amount of time to delay.\n */\nexport function conditionalDelay(condition, timeInMsec) {\n    return async (canisterId, requestId, status) => {\n        if (await condition(canisterId, requestId, status)) {\n            return new Promise(resolve => setTimeout(resolve, timeInMsec));\n        }\n    };\n}\n/**\n * Error out after a maximum number of polling has been done.\n * @param count The maximum attempts to poll.\n */\nexport function maxAttempts(count) {\n    let attempts = count;\n    return async (canisterId, requestId, status) => {\n        if (--attempts <= 0) {\n            throw new Error(`Failed to retrieve a reply for request after ${count} attempts:\\n` +\n                `  Request ID: ${toHex(requestId)}\\n` +\n                `  Request status: ${status}\\n`);\n        }\n    };\n}\n/**\n * Throttle polling.\n * @param throttleInMsec Amount in millisecond to wait between each polling.\n */\nexport function throttle(throttleInMsec) {\n    return () => new Promise(resolve => setTimeout(resolve, throttleInMsec));\n}\n/**\n * Reject a call after a certain amount of time.\n * @param timeInMsec Time in milliseconds before the polling should be rejected.\n */\nexport function timeout(timeInMsec) {\n    const end = Date.now() + timeInMsec;\n    return async (canisterId, requestId, status) => {\n        if (Date.now() > end) {\n            throw new Error(`Request timed out after ${timeInMsec} msec:\\n` +\n                `  Request ID: ${toHex(requestId)}\\n` +\n                `  Request status: ${status}\\n`);\n        }\n    };\n}\n/**\n * A strategy that throttle, but using an exponential backoff strategy.\n * @param startingThrottleInMsec The throttle in milliseconds to start with.\n * @param backoffFactor The factor to multiple the throttle time between every poll. For\n *   example if using 2, the throttle will double between every run.\n */\nexport function backoff(startingThrottleInMsec, backoffFactor) {\n    let currentThrottling = startingThrottleInMsec;\n    return () => new Promise(resolve => setTimeout(() => {\n        currentThrottling *= backoffFactor;\n        resolve();\n    }, currentThrottling));\n}\n/**\n * Chain multiple polling strategy. This _chains_ the strategies, so if you pass in,\n * say, two throttling strategy of 1 second, it will result in a throttle of 2 seconds.\n * @param strategies A strategy list to chain.\n */\nexport function chain(...strategies) {\n    return async (canisterId, requestId, status) => {\n        for (const a of strategies) {\n            await a(canisterId, requestId, status);\n        }\n    };\n}\n//# sourceMappingURL=strategy.js.map"]},"metadata":{},"sourceType":"module"}