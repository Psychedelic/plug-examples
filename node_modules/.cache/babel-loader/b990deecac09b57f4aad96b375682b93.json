{"ast":null,"code":"/* eslint-disable no-constant-condition */\n// tslint:disable:no-bitwise\n// Note: this file uses buffer-pipe, which on Node only, uses the Node Buffer\n//       implementation, which isn't compatible with the NPM buffer package\n//       which we use everywhere else. This means that we have to transform\n//       one into the other, hence why every function that returns a Buffer\n//       actually return `new Buffer(pipe.buffer)`.\n// TODO: The best solution would be to have our own buffer type around\n//       Uint8Array which is standard.\nimport { PipeArrayBuffer as Pipe } from './buffer';\n\nfunction eob() {\n  throw new Error('unexpected end of buffer');\n}\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param num number\n * @returns Buffer\n */\n\n\nexport function safeRead(pipe, num) {\n  if (pipe.byteLength < num) {\n    eob();\n  }\n\n  return pipe.read(num);\n}\n/**\n * @param pipe\n */\n\nexport function safeReadUint8(pipe) {\n  var byte = pipe.readUint8();\n\n  if (byte === undefined) {\n    eob();\n  }\n\n  return byte;\n}\n/**\n * Encode a positive number (or bigint) into a Buffer. The number will be floored to the\n * nearest integer.\n * @param value The number to encode.\n */\n\nexport function lebEncode(value) {\n  if (typeof value === 'number') {\n    value = BigInt(value);\n  }\n\n  if (value < BigInt(0)) {\n    throw new Error('Cannot leb encode negative values.');\n  }\n\n  var byteLength = (value === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value)))) + 1;\n  var pipe = new Pipe(new ArrayBuffer(byteLength), 0);\n\n  while (true) {\n    var i = Number(value & BigInt(0x7f));\n    value /= BigInt(0x80);\n\n    if (value === BigInt(0)) {\n      pipe.write(new Uint8Array([i]));\n      break;\n    } else {\n      pipe.write(new Uint8Array([i | 0x80]));\n    }\n  }\n\n  return pipe.buffer;\n}\n/**\n * Decode a leb encoded buffer into a bigint. The number will always be positive (does not\n * support signed leb encoding).\n * @param pipe A Buffer containing the leb encoded bits.\n */\n\nexport function lebDecode(pipe) {\n  var weight = BigInt(1);\n  var value = BigInt(0);\n  var byte;\n\n  do {\n    byte = safeReadUint8(pipe);\n    value += BigInt(byte & 0x7f).valueOf() * weight;\n    weight *= BigInt(128);\n  } while (byte >= 0x80);\n\n  return value;\n}\n/**\n * Encode a number (or bigint) into a Buffer, with support for negative numbers. The number\n * will be floored to the nearest integer.\n * @param value The number to encode.\n */\n\nexport function slebEncode(value) {\n  if (typeof value === 'number') {\n    value = BigInt(value);\n  }\n\n  var isNeg = value < BigInt(0);\n\n  if (isNeg) {\n    value = -value - BigInt(1);\n  }\n\n  var byteLength = (value === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value)))) + 1;\n  var pipe = new Pipe(new ArrayBuffer(byteLength), 0);\n\n  while (true) {\n    var i = getLowerBytes(value);\n    value /= BigInt(0x80); // prettier-ignore\n\n    if (isNeg && value === BigInt(0) && (i & 0x40) !== 0 || !isNeg && value === BigInt(0) && (i & 0x40) === 0) {\n      pipe.write(new Uint8Array([i]));\n      break;\n    } else {\n      pipe.write(new Uint8Array([i | 0x80]));\n    }\n  }\n\n  function getLowerBytes(num) {\n    var bytes = num % BigInt(0x80);\n\n    if (isNeg) {\n      // We swap the bits here again, and remove 1 to do two's complement.\n      return Number(BigInt(0x80) - bytes - BigInt(1));\n    } else {\n      return Number(bytes);\n    }\n  }\n\n  return pipe.buffer;\n}\n/**\n * Decode a leb encoded buffer into a bigint. The number is decoded with support for negative\n * signed-leb encoding.\n * @param pipe A Buffer containing the signed leb encoded bits.\n */\n\nexport function slebDecode(pipe) {\n  // Get the size of the buffer, then cut a buffer of that size.\n  var pipeView = new Uint8Array(pipe.buffer);\n  var len = 0;\n\n  for (; len < pipeView.byteLength; len++) {\n    if (pipeView[len] < 0x80) {\n      // If it's a positive number, we reuse lebDecode.\n      if ((pipeView[len] & 0x40) === 0) {\n        return lebDecode(pipe);\n      }\n\n      break;\n    }\n  }\n\n  var bytes = new Uint8Array(safeRead(pipe, len + 1));\n  var value = BigInt(0);\n\n  for (var i = bytes.byteLength - 1; i >= 0; i--) {\n    value = value * BigInt(0x80) + BigInt(0x80 - (bytes[i] & 0x7f) - 1);\n  }\n\n  return -value - BigInt(1);\n}\n/**\n *\n * @param value bigint or number\n * @param byteLength number\n * @returns Buffer\n */\n\nexport function writeUIntLE(value, byteLength) {\n  if (BigInt(value) < BigInt(0)) {\n    throw new Error('Cannot write negative values.');\n  }\n\n  return writeIntLE(value, byteLength);\n}\n/**\n *\n * @param value\n * @param byteLength\n */\n\nexport function writeIntLE(value, byteLength) {\n  value = BigInt(value);\n  var pipe = new Pipe(new ArrayBuffer(Math.min(1, byteLength)), 0);\n  var i = 0;\n  var mul = BigInt(256);\n  var sub = BigInt(0);\n  var byte = Number(value % mul);\n  pipe.write(new Uint8Array([byte]));\n\n  while (++i < byteLength) {\n    if (value < 0 && sub === BigInt(0) && byte !== 0) {\n      sub = BigInt(1);\n    }\n\n    byte = Number((value / mul - sub) % BigInt(256));\n    pipe.write(new Uint8Array([byte]));\n    mul *= BigInt(256);\n  }\n\n  return pipe.buffer;\n}\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param byteLength number\n * @returns bigint\n */\n\nexport function readUIntLE(pipe, byteLength) {\n  var val = BigInt(safeReadUint8(pipe));\n  var mul = BigInt(1);\n  var i = 0;\n\n  while (++i < byteLength) {\n    mul *= BigInt(256);\n    var byte = BigInt(safeReadUint8(pipe));\n    val = val + mul * byte;\n  }\n\n  return val;\n}\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param byteLength number\n * @returns bigint\n */\n\nexport function readIntLE(pipe, byteLength) {\n  var val = readUIntLE(pipe, byteLength);\n  var mul = Math.pow(BigInt(2), BigInt(8) * BigInt(byteLength - 1) + BigInt(7));\n\n  if (val >= mul) {\n    val -= mul * BigInt(2);\n  }\n\n  return val;\n}","map":{"version":3,"sources":["../../../src/utils/leb128.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/* eslint-disable no-constant-condition */\n// tslint:disable:no-bitwise\n// Note: this file uses buffer-pipe, which on Node only, uses the Node Buffer\n//       implementation, which isn't compatible with the NPM buffer package\n//       which we use everywhere else. This means that we have to transform\n//       one into the other, hence why every function that returns a Buffer\n//       actually return `new Buffer(pipe.buffer)`.\n// TODO: The best solution would be to have our own buffer type around\n//       Uint8Array which is standard.\nimport { PipeArrayBuffer as Pipe } from './buffer';\nfunction eob() {\n    throw new Error('unexpected end of buffer');\n}\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param num number\n * @returns Buffer\n */\nexport function safeRead(pipe, num) {\n    if (pipe.byteLength < num) {\n        eob();\n    }\n    return pipe.read(num);\n}\n/**\n * @param pipe\n */\nexport function safeReadUint8(pipe) {\n    const byte = pipe.readUint8();\n    if (byte === undefined) {\n        eob();\n    }\n    return byte;\n}\n/**\n * Encode a positive number (or bigint) into a Buffer. The number will be floored to the\n * nearest integer.\n * @param value The number to encode.\n */\nexport function lebEncode(value) {\n    if (typeof value === 'number') {\n        value = BigInt(value);\n    }\n    if (value < BigInt(0)) {\n        throw new Error('Cannot leb encode negative values.');\n    }\n    const byteLength = (value === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value)))) + 1;\n    const pipe = new Pipe(new ArrayBuffer(byteLength), 0);\n    while (true) {\n        const i = Number(value & BigInt(0x7f));\n        value /= BigInt(0x80);\n        if (value === BigInt(0)) {\n            pipe.write(new Uint8Array([i]));\n            break;\n        }\n        else {\n            pipe.write(new Uint8Array([i | 0x80]));\n        }\n    }\n    return pipe.buffer;\n}\n/**\n * Decode a leb encoded buffer into a bigint. The number will always be positive (does not\n * support signed leb encoding).\n * @param pipe A Buffer containing the leb encoded bits.\n */\nexport function lebDecode(pipe) {\n    let weight = BigInt(1);\n    let value = BigInt(0);\n    let byte;\n    do {\n        byte = safeReadUint8(pipe);\n        value += BigInt(byte & 0x7f).valueOf() * weight;\n        weight *= BigInt(128);\n    } while (byte >= 0x80);\n    return value;\n}\n/**\n * Encode a number (or bigint) into a Buffer, with support for negative numbers. The number\n * will be floored to the nearest integer.\n * @param value The number to encode.\n */\nexport function slebEncode(value) {\n    if (typeof value === 'number') {\n        value = BigInt(value);\n    }\n    const isNeg = value < BigInt(0);\n    if (isNeg) {\n        value = -value - BigInt(1);\n    }\n    const byteLength = (value === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value)))) + 1;\n    const pipe = new Pipe(new ArrayBuffer(byteLength), 0);\n    while (true) {\n        const i = getLowerBytes(value);\n        value /= BigInt(0x80);\n        // prettier-ignore\n        if ((isNeg && value === BigInt(0) && (i & 0x40) !== 0)\n            || (!isNeg && value === BigInt(0) && (i & 0x40) === 0)) {\n            pipe.write(new Uint8Array([i]));\n            break;\n        }\n        else {\n            pipe.write(new Uint8Array([i | 0x80]));\n        }\n    }\n    function getLowerBytes(num) {\n        const bytes = num % BigInt(0x80);\n        if (isNeg) {\n            // We swap the bits here again, and remove 1 to do two's complement.\n            return Number(BigInt(0x80) - bytes - BigInt(1));\n        }\n        else {\n            return Number(bytes);\n        }\n    }\n    return pipe.buffer;\n}\n/**\n * Decode a leb encoded buffer into a bigint. The number is decoded with support for negative\n * signed-leb encoding.\n * @param pipe A Buffer containing the signed leb encoded bits.\n */\nexport function slebDecode(pipe) {\n    // Get the size of the buffer, then cut a buffer of that size.\n    const pipeView = new Uint8Array(pipe.buffer);\n    let len = 0;\n    for (; len < pipeView.byteLength; len++) {\n        if (pipeView[len] < 0x80) {\n            // If it's a positive number, we reuse lebDecode.\n            if ((pipeView[len] & 0x40) === 0) {\n                return lebDecode(pipe);\n            }\n            break;\n        }\n    }\n    const bytes = new Uint8Array(safeRead(pipe, len + 1));\n    let value = BigInt(0);\n    for (let i = bytes.byteLength - 1; i >= 0; i--) {\n        value = value * BigInt(0x80) + BigInt(0x80 - (bytes[i] & 0x7f) - 1);\n    }\n    return -value - BigInt(1);\n}\n/**\n *\n * @param value bigint or number\n * @param byteLength number\n * @returns Buffer\n */\nexport function writeUIntLE(value, byteLength) {\n    if (BigInt(value) < BigInt(0)) {\n        throw new Error('Cannot write negative values.');\n    }\n    return writeIntLE(value, byteLength);\n}\n/**\n *\n * @param value\n * @param byteLength\n */\nexport function writeIntLE(value, byteLength) {\n    value = BigInt(value);\n    const pipe = new Pipe(new ArrayBuffer(Math.min(1, byteLength)), 0);\n    let i = 0;\n    let mul = BigInt(256);\n    let sub = BigInt(0);\n    let byte = Number(value % mul);\n    pipe.write(new Uint8Array([byte]));\n    while (++i < byteLength) {\n        if (value < 0 && sub === BigInt(0) && byte !== 0) {\n            sub = BigInt(1);\n        }\n        byte = Number((value / mul - sub) % BigInt(256));\n        pipe.write(new Uint8Array([byte]));\n        mul *= BigInt(256);\n    }\n    return pipe.buffer;\n}\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param byteLength number\n * @returns bigint\n */\nexport function readUIntLE(pipe, byteLength) {\n    let val = BigInt(safeReadUint8(pipe));\n    let mul = BigInt(1);\n    let i = 0;\n    while (++i < byteLength) {\n        mul *= BigInt(256);\n        const byte = BigInt(safeReadUint8(pipe));\n        val = val + mul * byte;\n    }\n    return val;\n}\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param byteLength number\n * @returns bigint\n */\nexport function readIntLE(pipe, byteLength) {\n    let val = readUIntLE(pipe, byteLength);\n    const mul = BigInt(2) ** (BigInt(8) * BigInt(byteLength - 1) + BigInt(7));\n    if (val >= mul) {\n        val -= mul * BigInt(2);\n    }\n    return val;\n}\n//# sourceMappingURL=leb128.js.map"]},"metadata":{},"sourceType":"module"}