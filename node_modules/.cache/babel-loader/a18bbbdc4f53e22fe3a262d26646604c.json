{"ast":null,"code":"import { RequestStatusResponseStatus } from '../agent';\nimport { Certificate } from '../certificate';\nimport { toHex } from '../utils/buffer';\nimport * as _strategy from './strategy';\nexport { _strategy as strategy };\nexport { defaultStrategy } from './strategy';\n/**\n * Polls the IC to check the status of the given request then\n * returns the response bytes once the request has been processed.\n * @param agent The agent to use to poll read_state.\n * @param canisterId The effective canister ID.\n * @param requestId The Request ID to poll status for.\n * @param strategy A polling strategy.\n */\n\nexport async function pollForResponse(agent, canisterId, requestId, strategy) {\n  const path = [new TextEncoder().encode('request_status'), requestId];\n  const state = await agent.readState(canisterId, {\n    paths: [path]\n  });\n  const cert = new Certificate(state, agent);\n  const verified = await cert.verify();\n\n  if (!verified) {\n    throw new Error('Fail to verify certificate');\n  }\n\n  const maybeBuf = cert.lookup([...path, new TextEncoder().encode('status')]);\n  let status;\n\n  if (typeof maybeBuf === 'undefined') {\n    // Missing requestId means we need to wait\n    status = RequestStatusResponseStatus.Unknown;\n  } else {\n    status = new TextDecoder().decode(maybeBuf);\n  }\n\n  switch (status) {\n    case RequestStatusResponseStatus.Replied:\n      {\n        return cert.lookup([...path, 'reply']);\n      }\n\n    case RequestStatusResponseStatus.Received:\n    case RequestStatusResponseStatus.Unknown:\n    case RequestStatusResponseStatus.Processing:\n      // Execute the polling strategy, then retry.\n      await strategy(canisterId, requestId, status);\n      return pollForResponse(agent, canisterId, requestId, strategy);\n\n    case RequestStatusResponseStatus.Rejected:\n      {\n        const rejectCode = new Uint8Array(cert.lookup([...path, 'reject_code']))[0];\n        const rejectMessage = new TextDecoder().decode(cert.lookup([...path, 'reject_message']));\n        throw new Error(`Call was rejected:\\n` + `  Request ID: ${toHex(requestId)}\\n` + `  Reject code: ${rejectCode}\\n` + `  Reject text: ${rejectMessage}\\n`);\n      }\n\n    case RequestStatusResponseStatus.Done:\n      // This is _technically_ not an error, but we still didn't see the `Replied` status so\n      // we don't know the result and cannot decode it.\n      throw new Error(`Call was marked as done but we never saw the reply:\\n` + `  Request ID: ${toHex(requestId)}\\n`);\n  }\n\n  throw new Error('unreachable');\n}","map":{"version":3,"sources":["../../../src/polling/index.ts"],"names":[],"mappings":"AACA,SAAgB,2BAAhB,QAAmD,UAAnD;AACA,SAAS,WAAT,QAA4B,gBAA5B;AAEA,SAAS,KAAT,QAAsB,iBAAtB;2BAE0B,Y;sBAAd,Q;AACZ,SAAS,eAAT,QAAgC,YAAhC;AAQA;;;;;;;AAOG;;AACH,OAAO,eAAe,eAAf,CACL,KADK,EAEL,UAFK,EAGL,SAHK,EAIL,QAJK,EAIiB;AAEtB,QAAM,IAAI,GAAG,CAAC,IAAI,WAAJ,GAAkB,MAAlB,CAAyB,gBAAzB,CAAD,EAA6C,SAA7C,CAAb;AACA,QAAM,KAAK,GAAG,MAAM,KAAK,CAAC,SAAN,CAAgB,UAAhB,EAA4B;AAAE,IAAA,KAAK,EAAE,CAAC,IAAD;AAAT,GAA5B,CAApB;AACA,QAAM,IAAI,GAAG,IAAI,WAAJ,CAAgB,KAAhB,EAAuB,KAAvB,CAAb;AACA,QAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,MAAL,EAAvB;;AACA,MAAI,CAAC,QAAL,EAAe;AACb,UAAM,IAAI,KAAJ,CAAU,4BAAV,CAAN;AACD;;AACD,QAAM,QAAQ,GAAG,IAAI,CAAC,MAAL,CAAY,CAAC,GAAG,IAAJ,EAAU,IAAI,WAAJ,GAAkB,MAAlB,CAAyB,QAAzB,CAAV,CAAZ,CAAjB;AACA,MAAI,MAAJ;;AACA,MAAI,OAAO,QAAP,KAAoB,WAAxB,EAAqC;AACnC;AACA,IAAA,MAAM,GAAG,2BAA2B,CAAC,OAArC;AACD,GAHD,MAGO;AACL,IAAA,MAAM,GAAG,IAAI,WAAJ,GAAkB,MAAlB,CAAyB,QAAzB,CAAT;AACD;;AAED,UAAQ,MAAR;AACE,SAAK,2BAA2B,CAAC,OAAjC;AAA0C;AACxC,eAAO,IAAI,CAAC,MAAL,CAAY,CAAC,GAAG,IAAJ,EAAU,OAAV,CAAZ,CAAP;AACD;;AAED,SAAK,2BAA2B,CAAC,QAAjC;AACA,SAAK,2BAA2B,CAAC,OAAjC;AACA,SAAK,2BAA2B,CAAC,UAAjC;AACE;AACA,YAAM,QAAQ,CAAC,UAAD,EAAa,SAAb,EAAwB,MAAxB,CAAd;AACA,aAAO,eAAe,CAAC,KAAD,EAAQ,UAAR,EAAoB,SAApB,EAA+B,QAA/B,CAAtB;;AAEF,SAAK,2BAA2B,CAAC,QAAjC;AAA2C;AACzC,cAAM,UAAU,GAAG,IAAI,UAAJ,CAAe,IAAI,CAAC,MAAL,CAAY,CAAC,GAAG,IAAJ,EAAU,aAAV,CAAZ,CAAf,EAAuD,CAAvD,CAAnB;AACA,cAAM,aAAa,GAAG,IAAI,WAAJ,GAAkB,MAAlB,CAAyB,IAAI,CAAC,MAAL,CAAY,CAAC,GAAG,IAAJ,EAAU,gBAAV,CAAZ,CAAzB,CAAtB;AACA,cAAM,IAAI,KAAJ,CACJ,sBAAA,GACE,iBAAiB,KAAK,CAAC,SAAD,CAAW,IADnC,GAEE,kBAAkB,UAAU,IAF9B,GAGE,kBAAkB,aAAa,IAJ7B,CAAN;AAMD;;AAED,SAAK,2BAA2B,CAAC,IAAjC;AACE;AACA;AACA,YAAM,IAAI,KAAJ,CACJ,uDAAA,GACE,iBAAiB,KAAK,CAAC,SAAD,CAAW,IAF/B,CAAN;AA1BJ;;AA+BA,QAAM,IAAI,KAAJ,CAAU,aAAV,CAAN;AACD","sourceRoot":"","sourcesContent":["import { RequestStatusResponseStatus } from '../agent';\nimport { Certificate } from '../certificate';\nimport { toHex } from '../utils/buffer';\nexport * as strategy from './strategy';\nexport { defaultStrategy } from './strategy';\n/**\n * Polls the IC to check the status of the given request then\n * returns the response bytes once the request has been processed.\n * @param agent The agent to use to poll read_state.\n * @param canisterId The effective canister ID.\n * @param requestId The Request ID to poll status for.\n * @param strategy A polling strategy.\n */\nexport async function pollForResponse(agent, canisterId, requestId, strategy) {\n    const path = [new TextEncoder().encode('request_status'), requestId];\n    const state = await agent.readState(canisterId, { paths: [path] });\n    const cert = new Certificate(state, agent);\n    const verified = await cert.verify();\n    if (!verified) {\n        throw new Error('Fail to verify certificate');\n    }\n    const maybeBuf = cert.lookup([...path, new TextEncoder().encode('status')]);\n    let status;\n    if (typeof maybeBuf === 'undefined') {\n        // Missing requestId means we need to wait\n        status = RequestStatusResponseStatus.Unknown;\n    }\n    else {\n        status = new TextDecoder().decode(maybeBuf);\n    }\n    switch (status) {\n        case RequestStatusResponseStatus.Replied: {\n            return cert.lookup([...path, 'reply']);\n        }\n        case RequestStatusResponseStatus.Received:\n        case RequestStatusResponseStatus.Unknown:\n        case RequestStatusResponseStatus.Processing:\n            // Execute the polling strategy, then retry.\n            await strategy(canisterId, requestId, status);\n            return pollForResponse(agent, canisterId, requestId, strategy);\n        case RequestStatusResponseStatus.Rejected: {\n            const rejectCode = new Uint8Array(cert.lookup([...path, 'reject_code']))[0];\n            const rejectMessage = new TextDecoder().decode(cert.lookup([...path, 'reject_message']));\n            throw new Error(`Call was rejected:\\n` +\n                `  Request ID: ${toHex(requestId)}\\n` +\n                `  Reject code: ${rejectCode}\\n` +\n                `  Reject text: ${rejectMessage}\\n`);\n        }\n        case RequestStatusResponseStatus.Done:\n            // This is _technically_ not an error, but we still didn't see the `Replied` status so\n            // we don't know the result and cannot decode it.\n            throw new Error(`Call was marked as done but we never saw the reply:\\n` +\n                `  Request ID: ${toHex(requestId)}\\n`);\n    }\n    throw new Error('unreachable');\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}