{"ast":null,"code":"import _regeneratorRuntime from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { Principal } from '@dfinity/principal';\nimport { requestIdOf } from './request_id';\nimport { concat, toHex } from './utils/buffer';\nvar domainSeparator = new TextEncoder().encode('\\x0Aic-request');\n/**\n * An Identity that can sign blobs.\n */\n\nexport var SignIdentity = /*#__PURE__*/function () {\n  function SignIdentity() {\n    _classCallCheck(this, SignIdentity);\n  }\n\n  _createClass(SignIdentity, [{\n    key: \"getPrincipal\",\n    value:\n    /**\n     * Get the principal represented by this identity. Normally should be a\n     * `Principal.selfAuthenticating()`.\n     */\n    function getPrincipal() {\n      if (!this._principal) {\n        this._principal = Principal.selfAuthenticating(new Uint8Array(this.getPublicKey().toDer()));\n      }\n\n      return this._principal;\n    }\n    /**\n     * Transform a request into a signed version of the request. This is done last\n     * after the transforms on the body of a request. The returned object can be\n     * anything, but must be serializable to CBOR.\n     * @param request - internet computer request to transform\n     */\n\n  }, {\n    key: \"transformRequest\",\n    value: function () {\n      var _transformRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(request) {\n        var body, fields, requestId;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                body = request.body, fields = __rest(request, [\"body\"]);\n                _context.next = 3;\n                return requestIdOf(body);\n\n              case 3:\n                requestId = _context.sent;\n                _context.t0 = Object;\n                _context.t1 = Object.assign({}, fields);\n                _context.t2 = body;\n                _context.t3 = this.getPublicKey().toDer();\n                _context.next = 10;\n                return this.sign(concat(domainSeparator, requestId));\n\n              case 10:\n                _context.t4 = _context.sent;\n                _context.t5 = {\n                  content: _context.t2,\n                  sender_pubkey: _context.t3,\n                  sender_sig: _context.t4\n                };\n                _context.t6 = {\n                  body: _context.t5\n                };\n                return _context.abrupt(\"return\", _context.t0.assign.call(_context.t0, _context.t1, _context.t6));\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function transformRequest(_x) {\n        return _transformRequest.apply(this, arguments);\n      }\n\n      return transformRequest;\n    }()\n  }]);\n\n  return SignIdentity;\n}();\nexport var AnonymousIdentity = /*#__PURE__*/function () {\n  function AnonymousIdentity() {\n    _classCallCheck(this, AnonymousIdentity);\n  }\n\n  _createClass(AnonymousIdentity, [{\n    key: \"getPrincipal\",\n    value: function getPrincipal() {\n      return Principal.anonymous();\n    }\n  }, {\n    key: \"transformRequest\",\n    value: function () {\n      var _transformRequest2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(request) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", Object.assign(Object.assign({}, request), {\n                  body: {\n                    content: request.body\n                  }\n                }));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function transformRequest(_x2) {\n        return _transformRequest2.apply(this, arguments);\n      }\n\n      return transformRequest;\n    }()\n  }]);\n\n  return AnonymousIdentity;\n}();\n/**\n * Create an IdentityDescriptor from a @dfinity/authentication Identity\n * @param identity - identity describe in returned descriptor\n */\n\nexport function createIdentityDescriptor(identity) {\n  var identityIndicator = 'getPublicKey' in identity ? {\n    type: 'PublicKeyIdentity',\n    publicKey: toHex(identity.getPublicKey().toDer())\n  } : {\n    type: 'AnonymousIdentity'\n  };\n  return identityIndicator;\n}","map":{"version":3,"sources":["../../src/auth.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,SAAS,SAAT,QAA0B,oBAA1B;AAEA,SAAS,WAAT,QAA4B,cAA5B;AACA,SAAS,MAAT,EAAiB,KAAjB,QAA8B,gBAA9B;AAEA,IAAM,eAAe,GAAG,IAAI,WAAJ,GAAkB,MAAlB,CAAyB,gBAAzB,CAAxB;AA+CA;;AAEG;;AACH,WAAsB,YAAtB;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAaE;;;AAGG;AACI,4BAAY;AACjB,UAAI,CAAC,KAAK,UAAV,EAAsB;AACpB,aAAK,UAAL,GAAkB,SAAS,CAAC,kBAAV,CAA6B,IAAI,UAAJ,CAAe,KAAK,YAAL,GAAoB,KAApB,EAAf,CAA7B,CAAlB;AACD;;AACD,aAAO,KAAK,UAAZ;AACD;AAED;;;;;AAKG;;AA7BL;AAAA;AAAA;AAAA,uFA8BS,iBAAuB,OAAvB;AAAA;AAAA;AAAA;AAAA;AAAA;AACG,gBAAA,IADH,GACuB,OADvB,CACG,IADH,EACY,MADZ,GACkB,MAAA,CAAK,OAAL,EAAjB,CAAA,MAAA,CAAiB,CADlB;AAAA;AAAA,uBAEmB,WAAW,CAAC,IAAD,CAF9B;;AAAA;AAEC,gBAAA,SAFD;AAAA,8BAGL,MAHK;AAAA,8BAGL,MAAA,CAAA,MAAA,CAAA,EAAA,EACK,MADL,CAHK;AAAA,8BAMQ,IANR;AAAA,8BAOc,KAAK,YAAL,GAAoB,KAApB,EAPd;AAAA;AAAA,uBAQiB,KAAK,IAAL,CAAU,MAAM,CAAC,eAAD,EAAkB,SAAlB,CAAhB,CARjB;;AAAA;AAAA;AAAA;AAMD,kBAAA,OANC;AAOD,kBAAA,aAPC;AAQD,kBAAA,UARC;AAAA;AAAA;AAKH,kBAAA,IALG;AAAA;AAAA,6DAGL,MAHK;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OA9BT;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AA4CA,WAAa,iBAAb;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,WACS,wBAAY;AACjB,aAAO,SAAS,CAAC,SAAV,EAAP;AACD;AAHH;AAAA;AAAA;AAAA,wFAKS,kBAAuB,OAAvB;AAAA;AAAA;AAAA;AAAA;AAAA,kDACL,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACK,OADL,CAAA,EACY;AACV,kBAAA,IAAI,EAAE;AAAE,oBAAA,OAAO,EAAE,OAAO,CAAC;AAAnB;AADI,iBADZ,CADK;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OALT;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAkCA;;;AAGG;;AACH,OAAM,SAAU,wBAAV,CACJ,QADI,EACsC;AAE1C,MAAM,iBAAiB,GACrB,kBAAkB,QAAlB,GACI;AAAE,IAAA,IAAI,EAAE,mBAAR;AAA6B,IAAA,SAAS,EAAE,KAAK,CAAC,QAAQ,CAAC,YAAT,GAAwB,KAAxB,EAAD;AAA7C,GADJ,GAEI;AAAE,IAAA,IAAI,EAAE;AAAR,GAHN;AAIA,SAAO,iBAAP;AACD","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { Principal } from '@dfinity/principal';\nimport { requestIdOf } from './request_id';\nimport { concat, toHex } from './utils/buffer';\nconst domainSeparator = new TextEncoder().encode('\\x0Aic-request');\n/**\n * An Identity that can sign blobs.\n */\nexport class SignIdentity {\n    /**\n     * Get the principal represented by this identity. Normally should be a\n     * `Principal.selfAuthenticating()`.\n     */\n    getPrincipal() {\n        if (!this._principal) {\n            this._principal = Principal.selfAuthenticating(new Uint8Array(this.getPublicKey().toDer()));\n        }\n        return this._principal;\n    }\n    /**\n     * Transform a request into a signed version of the request. This is done last\n     * after the transforms on the body of a request. The returned object can be\n     * anything, but must be serializable to CBOR.\n     * @param request - internet computer request to transform\n     */\n    async transformRequest(request) {\n        const { body } = request, fields = __rest(request, [\"body\"]);\n        const requestId = await requestIdOf(body);\n        return Object.assign(Object.assign({}, fields), { body: {\n                content: body,\n                sender_pubkey: this.getPublicKey().toDer(),\n                sender_sig: await this.sign(concat(domainSeparator, requestId)),\n            } });\n    }\n}\nexport class AnonymousIdentity {\n    getPrincipal() {\n        return Principal.anonymous();\n    }\n    async transformRequest(request) {\n        return Object.assign(Object.assign({}, request), { body: { content: request.body } });\n    }\n}\n/**\n * Create an IdentityDescriptor from a @dfinity/authentication Identity\n * @param identity - identity describe in returned descriptor\n */\nexport function createIdentityDescriptor(identity) {\n    const identityIndicator = 'getPublicKey' in identity\n        ? { type: 'PublicKeyIdentity', publicKey: toHex(identity.getPublicKey().toDer()) }\n        : { type: 'AnonymousIdentity' };\n    return identityIndicator;\n}\n//# sourceMappingURL=auth.js.map"]},"metadata":{},"sourceType":"module"}