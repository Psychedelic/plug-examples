{"ast":null,"code":"import { Principal } from '@dfinity/principal';\nimport { AnonymousIdentity } from '../../auth';\nimport * as cbor from '../../cbor';\nimport { requestIdOf } from '../../request_id';\nimport { fromHex } from '../../utils/buffer';\nimport { Expiry } from './transforms';\nimport { SubmitRequestType } from './types';\nexport * from './transforms';\nexport { makeNonce } from './types';\nexport var RequestStatusResponseStatus;\n\n(function (RequestStatusResponseStatus) {\n  RequestStatusResponseStatus[\"Received\"] = \"received\";\n  RequestStatusResponseStatus[\"Processing\"] = \"processing\";\n  RequestStatusResponseStatus[\"Replied\"] = \"replied\";\n  RequestStatusResponseStatus[\"Rejected\"] = \"rejected\";\n  RequestStatusResponseStatus[\"Unknown\"] = \"unknown\";\n  RequestStatusResponseStatus[\"Done\"] = \"done\";\n})(RequestStatusResponseStatus || (RequestStatusResponseStatus = {})); // Default delta for ingress expiry is 5 minutes.\n\n\nconst DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS = 5 * 60 * 1000; // Root public key for the IC, encoded as hex\n\nconst IC_ROOT_KEY = '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814' + 'c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d968' + '5f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484' + 'b01291091c5f87b98883463f98091a0baaae';\n\nfunction getDefaultFetch() {\n  const result = typeof window === 'undefined' ? typeof global === 'undefined' ? typeof self === 'undefined' ? undefined : self.fetch.bind(self) : global.fetch.bind(global) : window.fetch.bind(window);\n\n  if (!result) {\n    throw new Error('Could not find default `fetch` implementation.');\n  }\n\n  return result;\n} // A HTTP agent allows users to interact with a client of the internet computer\n// using the available methods. It exposes an API that closely follows the\n// public view of the internet computer, and is not intended to be exposed\n// directly to the majority of users due to its low-level interface.\n//\n// There is a pipeline to apply transformations to the request before sending\n// it to the client. This is to decouple signature, nonce generation and\n// other computations so that this class can stay as simple as possible while\n// allowing extensions.\n\n\nexport class HttpAgent {\n  constructor(options = {}) {\n    this.rootKey = fromHex(IC_ROOT_KEY);\n    this._pipeline = [];\n    this._rootKeyFetched = false;\n\n    if (options.source) {\n      if (!(options.source instanceof HttpAgent)) {\n        throw new Error(\"An Agent's source can only be another HttpAgent\");\n      }\n\n      this._pipeline = [...options.source._pipeline];\n      this._identity = options.source._identity;\n      this._fetch = options.source._fetch;\n      this._host = options.source._host;\n      this._credentials = options.source._credentials;\n    } else {\n      this._fetch = options.fetch || getDefaultFetch() || fetch.bind(global);\n    }\n\n    if (options.host !== undefined) {\n      if (!options.host.match(/^[a-z]+:/) && typeof window !== 'undefined') {\n        this._host = new URL(window.location.protocol + '//' + options.host);\n      } else {\n        this._host = new URL(options.host);\n      }\n    } else if (options.source !== undefined) {\n      // Safe to ignore here.\n      this._host = options.source._host;\n    } else {\n      const location = typeof window !== 'undefined' ? window.location : undefined;\n\n      if (!location) {\n        throw new Error('Must specify a host to connect to.');\n      }\n\n      this._host = new URL(location + '');\n    }\n\n    if (options.credentials) {\n      const {\n        name,\n        password\n      } = options.credentials;\n      this._credentials = `${name}${password ? ':' + password : ''}`;\n    }\n\n    this._identity = Promise.resolve(options.identity || new AnonymousIdentity());\n  }\n\n  addTransform(fn, priority = fn.priority || 0) {\n    // Keep the pipeline sorted at all time, by priority.\n    const i = this._pipeline.findIndex(x => (x.priority || 0) < priority);\n\n    this._pipeline.splice(i >= 0 ? i : this._pipeline.length, 0, Object.assign(fn, {\n      priority\n    }));\n  }\n\n  async getPrincipal() {\n    return (await this._identity).getPrincipal();\n  }\n\n  async call(canisterId, options, identity) {\n    const id = await (identity !== undefined ? await identity : await this._identity);\n    const canister = Principal.from(canisterId);\n    const ecid = options.effectiveCanisterId ? Principal.from(options.effectiveCanisterId) : canister;\n    const sender = id.getPrincipal() || Principal.anonymous();\n    const submit = {\n      request_type: SubmitRequestType.Call,\n      canister_id: canister,\n      method_name: options.methodName,\n      arg: options.arg,\n      sender,\n      ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS)\n    }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    let transformedRequest = await this._transform({\n      request: {\n        body: null,\n        method: 'POST',\n        headers: Object.assign({\n          'Content-Type': 'application/cbor'\n        }, this._credentials ? {\n          Authorization: 'Basic ' + btoa(this._credentials)\n        } : {})\n      },\n      endpoint: \"call\"\n      /* Call */\n      ,\n      body: submit\n    }); // Apply transform for identity.\n\n    transformedRequest = await id.transformRequest(transformedRequest);\n    const body = cbor.encode(transformedRequest.body); // Run both in parallel. The fetch is quite expensive, so we have plenty of time to\n    // calculate the requestId locally.\n\n    const [response, requestId] = await Promise.all([this._fetch('' + new URL(`/api/v2/canister/${ecid.toText()}/call`, this._host), Object.assign(Object.assign({}, transformedRequest.request), {\n      body\n    })), requestIdOf(submit)]);\n\n    if (!response.ok) {\n      throw new Error(`Server returned an error:\\n` + `  Code: ${response.status} (${response.statusText})\\n` + `  Body: ${await response.text()}\\n`);\n    }\n\n    return {\n      requestId,\n      response: {\n        ok: response.ok,\n        status: response.status,\n        statusText: response.statusText\n      }\n    };\n  }\n\n  async query(canisterId, fields, identity) {\n    const id = await (identity !== undefined ? await identity : await this._identity);\n    const canister = typeof canisterId === 'string' ? Principal.fromText(canisterId) : canisterId;\n    const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || Principal.anonymous();\n    const request = {\n      request_type: \"query\"\n      /* Query */\n      ,\n      canister_id: canister,\n      method_name: fields.methodName,\n      arg: fields.arg,\n      sender,\n      ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS)\n    }; // TODO: remove this any. This can be a Signed or UnSigned request.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    let transformedRequest = await this._transform({\n      request: {\n        method: 'POST',\n        headers: Object.assign({\n          'Content-Type': 'application/cbor'\n        }, this._credentials ? {\n          Authorization: 'Basic ' + btoa(this._credentials)\n        } : {})\n      },\n      endpoint: \"read\"\n      /* Query */\n      ,\n      body: request\n    }); // Apply transform for identity.\n\n    transformedRequest = await id.transformRequest(transformedRequest);\n    const body = cbor.encode(transformedRequest.body);\n    const response = await this._fetch('' + new URL(`/api/v2/canister/${canister.toText()}/query`, this._host), Object.assign(Object.assign({}, transformedRequest.request), {\n      body\n    }));\n\n    if (!response.ok) {\n      throw new Error(`Server returned an error:\\n` + `  Code: ${response.status} (${response.statusText})\\n` + `  Body: ${await response.text()}\\n`);\n    }\n\n    return cbor.decode(await response.arrayBuffer());\n  }\n\n  async readState(canisterId, fields, identity) {\n    const canister = typeof canisterId === 'string' ? Principal.fromText(canisterId) : canisterId;\n    const id = await (identity !== undefined ? await identity : await this._identity);\n    const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || Principal.anonymous(); // TODO: remove this any. This can be a Signed or UnSigned request.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    let transformedRequest = await this._transform({\n      request: {\n        method: 'POST',\n        headers: Object.assign({\n          'Content-Type': 'application/cbor'\n        }, this._credentials ? {\n          Authorization: 'Basic ' + btoa(this._credentials)\n        } : {})\n      },\n      endpoint: \"read_state\"\n      /* ReadState */\n      ,\n      body: {\n        request_type: \"read_state\"\n        /* ReadState */\n        ,\n        paths: fields.paths,\n        sender,\n        ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS)\n      }\n    }); // Apply transform for identity.\n\n    transformedRequest = await id.transformRequest(transformedRequest);\n    const body = cbor.encode(transformedRequest.body);\n    const response = await this._fetch('' + new URL(`/api/v2/canister/${canister}/read_state`, this._host), Object.assign(Object.assign({}, transformedRequest.request), {\n      body\n    }));\n\n    if (!response.ok) {\n      throw new Error(`Server returned an error:\\n` + `  Code: ${response.status} (${response.statusText})\\n` + `  Body: ${await response.text()}\\n`);\n    }\n\n    return cbor.decode(await response.arrayBuffer());\n  }\n\n  async status() {\n    const headers = this._credentials ? {\n      Authorization: 'Basic ' + btoa(this._credentials)\n    } : {};\n    const response = await this._fetch('' + new URL(`/api/v2/status`, this._host), {\n      headers\n    });\n\n    if (!response.ok) {\n      throw new Error(`Server returned an error:\\n` + `  Code: ${response.status} (${response.statusText})\\n` + `  Body: ${await response.text()}\\n`);\n    }\n\n    return cbor.decode(await response.arrayBuffer());\n  }\n\n  async fetchRootKey() {\n    if (!this._rootKeyFetched) {\n      // Hex-encoded version of the replica root key\n      this.rootKey = (await this.status()).root_key;\n      this._rootKeyFetched = true;\n    }\n\n    return this.rootKey;\n  }\n\n  _transform(request) {\n    let p = Promise.resolve(request);\n\n    for (const fn of this._pipeline) {\n      p = p.then(r => fn(r).then(r2 => r2 || r));\n    }\n\n    return p;\n  }\n\n}","map":{"version":3,"sources":["../../../../src/agent/http/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Principal } from '@dfinity/principal';\nimport { AnonymousIdentity } from '../../auth';\nimport * as cbor from '../../cbor';\nimport { requestIdOf } from '../../request_id';\nimport { fromHex } from '../../utils/buffer';\nimport { Expiry } from './transforms';\nimport { SubmitRequestType, } from './types';\nexport * from './transforms';\nexport { makeNonce } from './types';\nexport var RequestStatusResponseStatus;\n(function (RequestStatusResponseStatus) {\n    RequestStatusResponseStatus[\"Received\"] = \"received\";\n    RequestStatusResponseStatus[\"Processing\"] = \"processing\";\n    RequestStatusResponseStatus[\"Replied\"] = \"replied\";\n    RequestStatusResponseStatus[\"Rejected\"] = \"rejected\";\n    RequestStatusResponseStatus[\"Unknown\"] = \"unknown\";\n    RequestStatusResponseStatus[\"Done\"] = \"done\";\n})(RequestStatusResponseStatus || (RequestStatusResponseStatus = {}));\n// Default delta for ingress expiry is 5 minutes.\nconst DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS = 5 * 60 * 1000;\n// Root public key for the IC, encoded as hex\nconst IC_ROOT_KEY = '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814' +\n    'c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d968' +\n    '5f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484' +\n    'b01291091c5f87b98883463f98091a0baaae';\nfunction getDefaultFetch() {\n    const result = typeof window === 'undefined'\n        ? typeof global === 'undefined'\n            ? typeof self === 'undefined'\n                ? undefined\n                : self.fetch.bind(self)\n            : global.fetch.bind(global)\n        : window.fetch.bind(window);\n    if (!result) {\n        throw new Error('Could not find default `fetch` implementation.');\n    }\n    return result;\n}\n// A HTTP agent allows users to interact with a client of the internet computer\n// using the available methods. It exposes an API that closely follows the\n// public view of the internet computer, and is not intended to be exposed\n// directly to the majority of users due to its low-level interface.\n//\n// There is a pipeline to apply transformations to the request before sending\n// it to the client. This is to decouple signature, nonce generation and\n// other computations so that this class can stay as simple as possible while\n// allowing extensions.\nexport class HttpAgent {\n    constructor(options = {}) {\n        this.rootKey = fromHex(IC_ROOT_KEY);\n        this._pipeline = [];\n        this._rootKeyFetched = false;\n        if (options.source) {\n            if (!(options.source instanceof HttpAgent)) {\n                throw new Error(\"An Agent's source can only be another HttpAgent\");\n            }\n            this._pipeline = [...options.source._pipeline];\n            this._identity = options.source._identity;\n            this._fetch = options.source._fetch;\n            this._host = options.source._host;\n            this._credentials = options.source._credentials;\n        }\n        else {\n            this._fetch = options.fetch || getDefaultFetch() || fetch.bind(global);\n        }\n        if (options.host !== undefined) {\n            if (!options.host.match(/^[a-z]+:/) && typeof window !== 'undefined') {\n                this._host = new URL(window.location.protocol + '//' + options.host);\n            }\n            else {\n                this._host = new URL(options.host);\n            }\n        }\n        else if (options.source !== undefined) {\n            // Safe to ignore here.\n            this._host = options.source._host;\n        }\n        else {\n            const location = typeof window !== 'undefined' ? window.location : undefined;\n            if (!location) {\n                throw new Error('Must specify a host to connect to.');\n            }\n            this._host = new URL(location + '');\n        }\n        if (options.credentials) {\n            const { name, password } = options.credentials;\n            this._credentials = `${name}${password ? ':' + password : ''}`;\n        }\n        this._identity = Promise.resolve(options.identity || new AnonymousIdentity());\n    }\n    addTransform(fn, priority = fn.priority || 0) {\n        // Keep the pipeline sorted at all time, by priority.\n        const i = this._pipeline.findIndex(x => (x.priority || 0) < priority);\n        this._pipeline.splice(i >= 0 ? i : this._pipeline.length, 0, Object.assign(fn, { priority }));\n    }\n    async getPrincipal() {\n        return (await this._identity).getPrincipal();\n    }\n    async call(canisterId, options, identity) {\n        const id = (await (identity !== undefined ? await identity : await this._identity));\n        const canister = Principal.from(canisterId);\n        const ecid = options.effectiveCanisterId\n            ? Principal.from(options.effectiveCanisterId)\n            : canister;\n        const sender = id.getPrincipal() || Principal.anonymous();\n        const submit = {\n            request_type: SubmitRequestType.Call,\n            canister_id: canister,\n            method_name: options.methodName,\n            arg: options.arg,\n            sender,\n            ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let transformedRequest = (await this._transform({\n            request: {\n                body: null,\n                method: 'POST',\n                headers: Object.assign({ 'Content-Type': 'application/cbor' }, (this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {})),\n            },\n            endpoint: \"call\" /* Call */,\n            body: submit,\n        }));\n        // Apply transform for identity.\n        transformedRequest = await id.transformRequest(transformedRequest);\n        const body = cbor.encode(transformedRequest.body);\n        // Run both in parallel. The fetch is quite expensive, so we have plenty of time to\n        // calculate the requestId locally.\n        const [response, requestId] = await Promise.all([\n            this._fetch('' + new URL(`/api/v2/canister/${ecid.toText()}/call`, this._host), Object.assign(Object.assign({}, transformedRequest.request), { body })),\n            requestIdOf(submit),\n        ]);\n        if (!response.ok) {\n            throw new Error(`Server returned an error:\\n` +\n                `  Code: ${response.status} (${response.statusText})\\n` +\n                `  Body: ${await response.text()}\\n`);\n        }\n        return {\n            requestId,\n            response: {\n                ok: response.ok,\n                status: response.status,\n                statusText: response.statusText,\n            },\n        };\n    }\n    async query(canisterId, fields, identity) {\n        const id = await (identity !== undefined ? await identity : await this._identity);\n        const canister = typeof canisterId === 'string' ? Principal.fromText(canisterId) : canisterId;\n        const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || Principal.anonymous();\n        const request = {\n            request_type: \"query\" /* Query */,\n            canister_id: canister,\n            method_name: fields.methodName,\n            arg: fields.arg,\n            sender,\n            ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),\n        };\n        // TODO: remove this any. This can be a Signed or UnSigned request.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let transformedRequest = await this._transform({\n            request: {\n                method: 'POST',\n                headers: Object.assign({ 'Content-Type': 'application/cbor' }, (this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {})),\n            },\n            endpoint: \"read\" /* Query */,\n            body: request,\n        });\n        // Apply transform for identity.\n        transformedRequest = await id.transformRequest(transformedRequest);\n        const body = cbor.encode(transformedRequest.body);\n        const response = await this._fetch('' + new URL(`/api/v2/canister/${canister.toText()}/query`, this._host), Object.assign(Object.assign({}, transformedRequest.request), { body }));\n        if (!response.ok) {\n            throw new Error(`Server returned an error:\\n` +\n                `  Code: ${response.status} (${response.statusText})\\n` +\n                `  Body: ${await response.text()}\\n`);\n        }\n        return cbor.decode(await response.arrayBuffer());\n    }\n    async readState(canisterId, fields, identity) {\n        const canister = typeof canisterId === 'string' ? Principal.fromText(canisterId) : canisterId;\n        const id = await (identity !== undefined ? await identity : await this._identity);\n        const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || Principal.anonymous();\n        // TODO: remove this any. This can be a Signed or UnSigned request.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let transformedRequest = await this._transform({\n            request: {\n                method: 'POST',\n                headers: Object.assign({ 'Content-Type': 'application/cbor' }, (this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {})),\n            },\n            endpoint: \"read_state\" /* ReadState */,\n            body: {\n                request_type: \"read_state\" /* ReadState */,\n                paths: fields.paths,\n                sender,\n                ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),\n            },\n        });\n        // Apply transform for identity.\n        transformedRequest = await id.transformRequest(transformedRequest);\n        const body = cbor.encode(transformedRequest.body);\n        const response = await this._fetch('' + new URL(`/api/v2/canister/${canister}/read_state`, this._host), Object.assign(Object.assign({}, transformedRequest.request), { body }));\n        if (!response.ok) {\n            throw new Error(`Server returned an error:\\n` +\n                `  Code: ${response.status} (${response.statusText})\\n` +\n                `  Body: ${await response.text()}\\n`);\n        }\n        return cbor.decode(await response.arrayBuffer());\n    }\n    async status() {\n        const headers = this._credentials\n            ? {\n                Authorization: 'Basic ' + btoa(this._credentials),\n            }\n            : {};\n        const response = await this._fetch('' + new URL(`/api/v2/status`, this._host), { headers });\n        if (!response.ok) {\n            throw new Error(`Server returned an error:\\n` +\n                `  Code: ${response.status} (${response.statusText})\\n` +\n                `  Body: ${await response.text()}\\n`);\n        }\n        return cbor.decode(await response.arrayBuffer());\n    }\n    async fetchRootKey() {\n        if (!this._rootKeyFetched) {\n            // Hex-encoded version of the replica root key\n            this.rootKey = (await this.status()).root_key;\n            this._rootKeyFetched = true;\n        }\n        return this.rootKey;\n    }\n    _transform(request) {\n        let p = Promise.resolve(request);\n        for (const fn of this._pipeline) {\n            p = p.then(r => fn(r).then(r2 => r2 || r));\n        }\n        return p;\n    }\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}