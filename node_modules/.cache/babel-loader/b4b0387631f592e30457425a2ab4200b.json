{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { Principal } from '@dfinity/principal';\nimport { requestIdOf } from './request_id';\nimport { concat, toHex } from './utils/buffer';\nconst domainSeparator = new TextEncoder().encode('\\x0Aic-request');\n/**\n * An Identity that can sign blobs.\n */\n\nexport class SignIdentity {\n  /**\n   * Get the principal represented by this identity. Normally should be a\n   * `Principal.selfAuthenticating()`.\n   */\n  getPrincipal() {\n    if (!this._principal) {\n      this._principal = Principal.selfAuthenticating(new Uint8Array(this.getPublicKey().toDer()));\n    }\n\n    return this._principal;\n  }\n  /**\n   * Transform a request into a signed version of the request. This is done last\n   * after the transforms on the body of a request. The returned object can be\n   * anything, but must be serializable to CBOR.\n   * @param request - internet computer request to transform\n   */\n\n\n  async transformRequest(request) {\n    const {\n      body\n    } = request,\n          fields = __rest(request, [\"body\"]);\n\n    const requestId = await requestIdOf(body);\n    return Object.assign(Object.assign({}, fields), {\n      body: {\n        content: body,\n        sender_pubkey: this.getPublicKey().toDer(),\n        sender_sig: await this.sign(concat(domainSeparator, requestId))\n      }\n    });\n  }\n\n}\nexport class AnonymousIdentity {\n  getPrincipal() {\n    return Principal.anonymous();\n  }\n\n  async transformRequest(request) {\n    return Object.assign(Object.assign({}, request), {\n      body: {\n        content: request.body\n      }\n    });\n  }\n\n}\n/**\n * Create an IdentityDescriptor from a @dfinity/authentication Identity\n * @param identity - identity describe in returned descriptor\n */\n\nexport function createIdentityDescriptor(identity) {\n  const identityIndicator = 'getPublicKey' in identity ? {\n    type: 'PublicKeyIdentity',\n    publicKey: toHex(identity.getPublicKey().toDer())\n  } : {\n    type: 'AnonymousIdentity'\n  };\n  return identityIndicator;\n}","map":{"version":3,"sources":["../../src/auth.ts"],"names":[],"mappings":";;;;;;;;;;;AAAA,SAAS,SAAT,QAA0B,oBAA1B;AAEA,SAAS,WAAT,QAA4B,cAA5B;AACA,SAAS,MAAT,EAAiB,KAAjB,QAA8B,gBAA9B;AAEA,MAAM,eAAe,GAAG,IAAI,WAAJ,GAAkB,MAAlB,CAAyB,gBAAzB,CAAxB;AA+CA;;AAEG;;AACH,OAAM,MAAgB,YAAhB,CAA4B;AAahC;;;AAGG;AACI,EAAA,YAAY,GAAA;AACjB,QAAI,CAAC,KAAK,UAAV,EAAsB;AACpB,WAAK,UAAL,GAAkB,SAAS,CAAC,kBAAV,CAA6B,IAAI,UAAJ,CAAe,KAAK,YAAL,GAAoB,KAApB,EAAf,CAA7B,CAAlB;AACD;;AACD,WAAO,KAAK,UAAZ;AACD;AAED;;;;;AAKG;;;AAC0B,QAAhB,gBAAgB,CAAC,OAAD,EAA0B;AACrD,UAAM;AAAE,MAAA;AAAF,QAAsB,OAA5B;AAAA,UAAiB,MAAM,GAAA,MAAA,CAAK,OAAL,EAAjB,CAAA,MAAA,CAAiB,CAAvB;;AACA,UAAM,SAAS,GAAG,MAAM,WAAW,CAAC,IAAD,CAAnC;AACA,WAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACK,MADL,CAAA,EACW;AACT,MAAA,IAAI,EAAE;AACJ,QAAA,OAAO,EAAE,IADL;AAEJ,QAAA,aAAa,EAAE,KAAK,YAAL,GAAoB,KAApB,EAFX;AAGJ,QAAA,UAAU,EAAE,MAAM,KAAK,IAAL,CAAU,MAAM,CAAC,eAAD,EAAkB,SAAlB,CAAhB;AAHd;AADG,KADX,CAAA;AAQD;;AAzC+B;AA4ClC,OAAM,MAAO,iBAAP,CAAwB;AACrB,EAAA,YAAY,GAAA;AACjB,WAAO,SAAS,CAAC,SAAV,EAAP;AACD;;AAE4B,QAAhB,gBAAgB,CAAC,OAAD,EAA0B;AACrD,WAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACK,OADL,CAAA,EACY;AACV,MAAA,IAAI,EAAE;AAAE,QAAA,OAAO,EAAE,OAAO,CAAC;AAAnB;AADI,KADZ,CAAA;AAID;;AAV2B;AAkC9B;;;AAGG;;AACH,OAAM,SAAU,wBAAV,CACJ,QADI,EACsC;AAE1C,QAAM,iBAAiB,GACrB,kBAAkB,QAAlB,GACI;AAAE,IAAA,IAAI,EAAE,mBAAR;AAA6B,IAAA,SAAS,EAAE,KAAK,CAAC,QAAQ,CAAC,YAAT,GAAwB,KAAxB,EAAD;AAA7C,GADJ,GAEI;AAAE,IAAA,IAAI,EAAE;AAAR,GAHN;AAIA,SAAO,iBAAP;AACD","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { Principal } from '@dfinity/principal';\nimport { requestIdOf } from './request_id';\nimport { concat, toHex } from './utils/buffer';\nconst domainSeparator = new TextEncoder().encode('\\x0Aic-request');\n/**\n * An Identity that can sign blobs.\n */\nexport class SignIdentity {\n    /**\n     * Get the principal represented by this identity. Normally should be a\n     * `Principal.selfAuthenticating()`.\n     */\n    getPrincipal() {\n        if (!this._principal) {\n            this._principal = Principal.selfAuthenticating(new Uint8Array(this.getPublicKey().toDer()));\n        }\n        return this._principal;\n    }\n    /**\n     * Transform a request into a signed version of the request. This is done last\n     * after the transforms on the body of a request. The returned object can be\n     * anything, but must be serializable to CBOR.\n     * @param request - internet computer request to transform\n     */\n    async transformRequest(request) {\n        const { body } = request, fields = __rest(request, [\"body\"]);\n        const requestId = await requestIdOf(body);\n        return Object.assign(Object.assign({}, fields), { body: {\n                content: body,\n                sender_pubkey: this.getPublicKey().toDer(),\n                sender_sig: await this.sign(concat(domainSeparator, requestId)),\n            } });\n    }\n}\nexport class AnonymousIdentity {\n    getPrincipal() {\n        return Principal.anonymous();\n    }\n    async transformRequest(request) {\n        return Object.assign(Object.assign({}, request), { body: { content: request.body } });\n    }\n}\n/**\n * Create an IdentityDescriptor from a @dfinity/authentication Identity\n * @param identity - identity describe in returned descriptor\n */\nexport function createIdentityDescriptor(identity) {\n    const identityIndicator = 'getPublicKey' in identity\n        ? { type: 'PublicKeyIdentity', publicKey: toHex(identity.getPublicKey().toDer()) }\n        : { type: 'AnonymousIdentity' };\n    return identityIndicator;\n}\n//# sourceMappingURL=auth.js.map"]},"metadata":{},"sourceType":"module"}