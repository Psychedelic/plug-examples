{"ast":null,"code":"import { lebEncode } from '@dfinity/candid';\nimport borc from 'borc';\nimport { sha256 as jsSha256 } from 'js-sha256';\nimport { compare, concat } from './utils/buffer';\n/**\n * sha256 hash the provided Buffer\n * @param data - input to hash function\n */\n\nexport function hash(data) {\n  return jsSha256.create().update(new Uint8Array(data)).arrayBuffer();\n}\n/**\n *\n * @param value unknown value\n * @returns ArrayBuffer\n */\n\nexport function hashValue(value) {\n  if (value instanceof borc.Tagged) {\n    return hashValue(value.value);\n  } else if (typeof value === 'string') {\n    return hashString(value);\n  } else if (typeof value === 'number') {\n    return hash(lebEncode(value));\n  } else if (value instanceof ArrayBuffer || ArrayBuffer.isView(value)) {\n    return hash(value);\n  } else if (Array.isArray(value)) {\n    const vals = value.map(hashValue);\n    return hash(concat(...vals));\n  } else if (value && typeof value === 'object' && value._isPrincipal) {\n    return hash(value.toUint8Array());\n  } else if (typeof value === 'object' && value !== null && typeof value.toHash === 'function') {\n    return hashValue(value.toHash()); // TODO This should be move to a specific async method as the webauthn flow required\n    // the flow to be synchronous to ensure Safari touch id works.\n    // } else if (value instanceof Promise) {\n    //   return value.then(x => hashValue(x));\n  } else if (typeof value === 'bigint') {\n    // Do this check much later than the other bigint check because this one is much less\n    // type-safe.\n    // So we want to try all the high-assurance type guards before this 'probable' one.\n    return hash(lebEncode(value));\n  }\n\n  throw Object.assign(new Error(`Attempt to hash a value of unsupported type: ${value}`), {\n    // include so logs/callers can understand the confusing value.\n    // (when stringified in error message, prototype info is lost)\n    value\n  });\n}\n\nconst hashString = value => {\n  const encoded = new TextEncoder().encode(value);\n  return hash(encoded);\n};\n/**\n * Get the RequestId of the provided ic-ref request.\n * RequestId is the result of the representation-independent-hash function.\n * https://sdk.dfinity.org/docs/interface-spec/index.html#hash-of-map\n * @param request - ic-ref request to hash into RequestId\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nexport function requestIdOf(request) {\n  const hashed = Object.entries(request).filter(([, value]) => value !== undefined).map(([key, value]) => {\n    const hashedKey = hashString(key);\n    const hashedValue = hashValue(value);\n    return [hashedKey, hashedValue];\n  });\n  const traversed = hashed;\n  const sorted = traversed.sort(([k1], [k2]) => {\n    return compare(k1, k2);\n  });\n  const concatenated = concat(...sorted.map(x => concat(...x)));\n  const requestId = hash(concatenated);\n  return requestId;\n}","map":{"version":3,"sources":["../../src/request_id.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { lebEncode } from '@dfinity/candid';\nimport borc from 'borc';\nimport { sha256 as jsSha256 } from 'js-sha256';\nimport { compare, concat } from './utils/buffer';\n/**\n * sha256 hash the provided Buffer\n * @param data - input to hash function\n */\nexport function hash(data) {\n    return jsSha256.create().update(new Uint8Array(data)).arrayBuffer();\n}\n/**\n *\n * @param value unknown value\n * @returns ArrayBuffer\n */\nexport function hashValue(value) {\n    if (value instanceof borc.Tagged) {\n        return hashValue(value.value);\n    }\n    else if (typeof value === 'string') {\n        return hashString(value);\n    }\n    else if (typeof value === 'number') {\n        return hash(lebEncode(value));\n    }\n    else if (value instanceof ArrayBuffer || ArrayBuffer.isView(value)) {\n        return hash(value);\n    }\n    else if (Array.isArray(value)) {\n        const vals = value.map(hashValue);\n        return hash(concat(...vals));\n    }\n    else if (value && typeof value === 'object' && value._isPrincipal) {\n        return hash(value.toUint8Array());\n    }\n    else if (typeof value === 'object' &&\n        value !== null &&\n        typeof value.toHash === 'function') {\n        return hashValue(value.toHash());\n        // TODO This should be move to a specific async method as the webauthn flow required\n        // the flow to be synchronous to ensure Safari touch id works.\n        // } else if (value instanceof Promise) {\n        //   return value.then(x => hashValue(x));\n    }\n    else if (typeof value === 'bigint') {\n        // Do this check much later than the other bigint check because this one is much less\n        // type-safe.\n        // So we want to try all the high-assurance type guards before this 'probable' one.\n        return hash(lebEncode(value));\n    }\n    throw Object.assign(new Error(`Attempt to hash a value of unsupported type: ${value}`), {\n        // include so logs/callers can understand the confusing value.\n        // (when stringified in error message, prototype info is lost)\n        value,\n    });\n}\nconst hashString = (value) => {\n    const encoded = new TextEncoder().encode(value);\n    return hash(encoded);\n};\n/**\n * Get the RequestId of the provided ic-ref request.\n * RequestId is the result of the representation-independent-hash function.\n * https://sdk.dfinity.org/docs/interface-spec/index.html#hash-of-map\n * @param request - ic-ref request to hash into RequestId\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function requestIdOf(request) {\n    const hashed = Object.entries(request)\n        .filter(([, value]) => value !== undefined)\n        .map(([key, value]) => {\n        const hashedKey = hashString(key);\n        const hashedValue = hashValue(value);\n        return [hashedKey, hashedValue];\n    });\n    const traversed = hashed;\n    const sorted = traversed.sort(([k1], [k2]) => {\n        return compare(k1, k2);\n    });\n    const concatenated = concat(...sorted.map(x => concat(...x)));\n    const requestId = hash(concatenated);\n    return requestId;\n}\n//# sourceMappingURL=request_id.js.map"]},"metadata":{},"sourceType":"module"}