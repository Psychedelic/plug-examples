{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar MAX_U64_NUMBER = 0x20000000000000;\n\nfunction _concat(a) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  var newBuffer = new Uint8Array(a.byteLength + args.reduce(function (acc, b) {\n    return acc + b.byteLength;\n  }, 0));\n  newBuffer.set(new Uint8Array(a), 0);\n  var i = a.byteLength;\n\n  for (var _i = 0, _args = args; _i < _args.length; _i++) {\n    var b = _args[_i];\n    newBuffer.set(new Uint8Array(b), i);\n    i += b.byteLength;\n  }\n\n  return newBuffer.buffer;\n}\n\nfunction _serializeValue(major, minor, value) {\n  // Remove everything that's not an hexadecimal character. These are not\n  // considered errors since the value was already validated and they might\n  // be number decimals or sign.\n  value = value.replace(/[^0-9a-fA-F]/g, \"\"); // Create the buffer from the value with left padding with 0.\n\n  var length = Math.pow(2, minor - 24\n  /* Int8 */\n  );\n  value = value.slice(-length * 2).padStart(length * 2, \"0\");\n  var bytes = [(major << 5) + minor].concat(value.match(/../g).map(function (byte) {\n    return parseInt(byte, 16);\n  }));\n  return new Uint8Array(bytes).buffer;\n}\n\nfunction _serializeNumber(major, value) {\n  if (value < 24) {\n    return new Uint8Array([(major << 5) + value]).buffer;\n  } else {\n    var minor = value <= 0xff ? 24\n    /* Int8 */\n    : value <= 0xffff ? 25\n    /* Int16 */\n    : value <= 0xffffffff ? 26\n    /* Int32 */\n    : 27\n    /* Int64 */\n    ;\n    return _serializeValue(major, minor, value.toString(16));\n  }\n}\n\nfunction _serializeString(str) {\n  var utf8 = [];\n\n  for (var i = 0; i < str.length; i++) {\n    var charcode = str.charCodeAt(i);\n\n    if (charcode < 0x80) {\n      utf8.push(charcode);\n    } else if (charcode < 0x800) {\n      utf8.push(0xc0 | charcode >> 6, 0x80 | charcode & 0x3f);\n    } else if (charcode < 0xd800 || charcode >= 0xe000) {\n      utf8.push(0xe0 | charcode >> 12, 0x80 | charcode >> 6 & 0x3f, 0x80 | charcode & 0x3f);\n    } else {\n      // Surrogate pair\n      i++;\n      charcode = (charcode & 0x3ff) << 10 | str.charCodeAt(i) & 0x3ff;\n      utf8.push(0xf0 | charcode >> 18, 0x80 | charcode >> 12 & 0x3f, 0x80 | charcode >> 6 & 0x3f, 0x80 | charcode & 0x3f);\n    }\n  }\n\n  return _concat(new Uint8Array(_serializeNumber(3\n  /* TextString */\n  , str.length)), new Uint8Array(utf8));\n}\n/**\n * Tag a value.\n */\n\n\nfunction tagged(tag, value) {\n  if (tag == 0xd9d9f7) {\n    return _concat(new Uint8Array([0xd9, 0xd9, 0xf7]), value);\n  }\n\n  if (tag < 24) {\n    return _concat(new Uint8Array([(6\n    /* Tag */\n    << 5) + tag]), value);\n  } else {\n    var minor = tag <= 0xff ? 24\n    /* Int8 */\n    : tag <= 0xffff ? 25\n    /* Int16 */\n    : tag <= 0xffffffff ? 26\n    /* Int32 */\n    : 27\n    /* Int64 */\n    ;\n    var length = Math.pow(2, minor - 24\n    /* Int8 */\n    );\n\n    var _value = tag.toString(16).slice(-length * 2).padStart(length * 2, \"0\");\n\n    var _bytes = [(6\n    /* Tag */\n    << 5) + minor].concat(_value.match(/../g).map(function (byte) {\n      return parseInt(byte, 16);\n    }));\n\n    return new Uint8Array(_bytes).buffer;\n  }\n}\n\nexports.tagged = tagged;\n/**\n * Set the raw bytes contained by this value. This should only be used with another\n * CborValue, or if you are implementing extensions to CBOR.\n * @param bytes A buffer containing the value.\n */\n\nfunction raw(bytes) {\n  return new Uint8Array(bytes).buffer;\n}\n\nexports.raw = raw;\n/**\n * Encode a number that is between [0, 23].\n * @param n\n */\n\nfunction uSmall(n) {\n  if (isNaN(n)) {\n    throw new RangeError(\"Invalid number.\");\n  }\n\n  n = Math.min(Math.max(0, n), 23); // Clamp it.\n\n  var bytes = [(0\n  /* UnsignedInteger */\n  << 5) + n];\n  return new Uint8Array(bytes).buffer;\n}\n\nexports.uSmall = uSmall;\n\nfunction u8(u8, radix) {\n  // Force u8 into a number, and validate it.\n  u8 = parseInt(\"\" + u8, radix);\n\n  if (isNaN(u8)) {\n    throw new RangeError(\"Invalid number.\");\n  }\n\n  u8 = Math.min(Math.max(0, u8), 0xff); // Clamp it.\n\n  u8 = u8.toString(16);\n  return _serializeValue(0\n  /* UnsignedInteger */\n  , 24\n  /* Int8 */\n  , u8);\n}\n\nexports.u8 = u8;\n\nfunction u16(u16, radix) {\n  // Force u16 into a number, and validate it.\n  u16 = parseInt(\"\" + u16, radix);\n\n  if (isNaN(u16)) {\n    throw new RangeError(\"Invalid number.\");\n  }\n\n  u16 = Math.min(Math.max(0, u16), 0xffff); // Clamp it.\n\n  u16 = u16.toString(16);\n  return _serializeValue(0\n  /* UnsignedInteger */\n  , 25\n  /* Int16 */\n  , u16);\n}\n\nexports.u16 = u16;\n\nfunction u32(u32, radix) {\n  // Force u32 into a number, and validate it.\n  u32 = parseInt(\"\" + u32, radix);\n\n  if (isNaN(u32)) {\n    throw new RangeError(\"Invalid number.\");\n  }\n\n  u32 = Math.min(Math.max(0, u32), 0xffffffff); // Clamp it.\n\n  u32 = u32.toString(16);\n  return _serializeValue(0\n  /* UnsignedInteger */\n  , 26\n  /* Int32 */\n  , u32);\n}\n\nexports.u32 = u32;\n\nfunction u64(u64, radix) {\n  // Special consideration for numbers that might be larger than expected.\n  if (typeof u64 == \"string\" && radix == 16) {\n    // This is the only case where we guarantee we'll encode the number directly.\n    // Validate it's all hexadecimal first.\n    if (u64.match(/[^0-9a-fA-F]/)) {\n      throw new RangeError(\"Invalid number.\");\n    }\n\n    return _serializeValue(0\n    /* UnsignedInteger */\n    , 27\n    /* Int64 */\n    , u64);\n  } // Force u64 into a number, and validate it.\n\n\n  u64 = parseInt(\"\" + u64, radix);\n\n  if (isNaN(u64)) {\n    throw new RangeError(\"Invalid number.\");\n  }\n\n  u64 = Math.min(Math.max(0, u64), MAX_U64_NUMBER); // Clamp it to actual limit.\n\n  u64 = u64.toString(16);\n  return _serializeValue(0\n  /* UnsignedInteger */\n  , 27\n  /* Int64 */\n  , u64);\n}\n\nexports.u64 = u64;\n/**\n * Encode a negative number that is between [-24, -1].\n */\n\nfunction iSmall(n) {\n  if (isNaN(n)) {\n    throw new RangeError(\"Invalid number.\");\n  }\n\n  if (n === 0) {\n    return uSmall(0);\n  } // Negative n, clamped to [1, 24], minus 1 (there's no negative 0).\n\n\n  n = Math.min(Math.max(0, -n), 24) - 1;\n  var bytes = [(1\n  /* SignedInteger */\n  << 5) + n];\n  return new Uint8Array(bytes).buffer;\n}\n\nexports.iSmall = iSmall;\n\nfunction i8(i8, radix) {\n  // Force i8 into a number, and validate it.\n  i8 = parseInt(\"\" + i8, radix);\n\n  if (isNaN(i8)) {\n    throw new RangeError(\"Invalid number.\");\n  } // Negative n, clamped, minus 1 (there's no negative 0).\n\n\n  i8 = Math.min(Math.max(0, -i8 - 1), 0xff);\n  i8 = i8.toString(16);\n  return _serializeValue(1\n  /* SignedInteger */\n  , 24\n  /* Int8 */\n  , i8);\n}\n\nexports.i8 = i8;\n\nfunction i16(i16, radix) {\n  // Force i16 into a number, and validate it.\n  i16 = parseInt(\"\" + i16, radix);\n\n  if (isNaN(i16)) {\n    throw new RangeError(\"Invalid number.\");\n  } // Negative n, clamped, minus 1 (there's no negative 0).\n\n\n  i16 = Math.min(Math.max(0, -i16 - 1), 0xffff);\n  i16 = i16.toString(16);\n  return _serializeValue(1\n  /* SignedInteger */\n  , 25\n  /* Int16 */\n  , i16);\n}\n\nexports.i16 = i16;\n\nfunction i32(i32, radix) {\n  // Force i32 into a number, and validate it.\n  i32 = parseInt(\"\" + i32, radix);\n\n  if (isNaN(i32)) {\n    throw new RangeError(\"Invalid number.\");\n  } // Negative n, clamped, minus 1 (there's no negative 0).\n\n\n  i32 = Math.min(Math.max(0, -i32 - 1), 0xffffffff);\n  i32 = i32.toString(16);\n  return _serializeValue(1\n  /* SignedInteger */\n  , 26\n  /* Int32 */\n  , i32);\n}\n\nexports.i32 = i32;\n\nfunction i64(i64, radix) {\n  // Special consideration for numbers that might be larger than expected.\n  if (typeof i64 == \"string\" && radix == 16) {\n    if (i64.startsWith(\"-\")) {\n      i64 = i64.slice(1);\n    } else {\n      // Clamp it.\n      i64 = \"0\";\n    } // This is the only case where we guarantee we'll encode the number directly.\n    // Validate it's all hexadecimal first.\n\n\n    if (i64.match(/[^0-9a-fA-F]/) || i64.length > 16) {\n      throw new RangeError(\"Invalid number.\");\n    } // We need to do -1 to the number.\n\n\n    var done = false;\n    var newI64 = i64.split(\"\").reduceRight(function (acc, x) {\n      if (done) {\n        return x + acc;\n      }\n\n      var n = parseInt(x, 16) - 1;\n\n      if (n >= 0) {\n        done = true;\n        return n.toString(16) + acc;\n      } else {\n        return \"f\" + acc;\n      }\n    }, \"\");\n\n    if (!done) {\n      // This number was 0.\n      return u64(0);\n    }\n\n    return _serializeValue(1\n    /* SignedInteger */\n    , 27\n    /* Int64 */\n    , newI64);\n  } // Force i64 into a number, and validate it.\n\n\n  i64 = parseInt(\"\" + i64, radix);\n\n  if (isNaN(i64)) {\n    throw new RangeError(\"Invalid number.\");\n  }\n\n  i64 = Math.min(Math.max(0, -i64 - 1), 0x20000000000000); // Clamp it to actual.\n\n  i64 = i64.toString(16);\n  return _serializeValue(1\n  /* SignedInteger */\n  , 27\n  /* Int64 */\n  , i64);\n}\n\nexports.i64 = i64;\n/**\n * Encode a number using the smallest amount of bytes, by calling the methods\n * above. e.g. If the number fits in a u8, it will use that.\n */\n\nfunction number(n) {\n  if (n >= 0) {\n    if (n < 24) {\n      return uSmall(n);\n    } else if (n <= 0xff) {\n      return u8(n);\n    } else if (n <= 0xffff) {\n      return u16(n);\n    } else if (n <= 0xffffffff) {\n      return u32(n);\n    } else {\n      return u64(n);\n    }\n  } else {\n    if (n >= -24) {\n      return iSmall(n);\n    } else if (n >= -0xff) {\n      return i8(n);\n    } else if (n >= -0xffff) {\n      return i16(n);\n    } else if (n >= -0xffffffff) {\n      return i32(n);\n    } else {\n      return i64(n);\n    }\n  }\n}\n\nexports.number = number;\n/**\n * Encode a byte array. This is different than the `raw()` method.\n */\n\nfunction bytes(bytes) {\n  return _concat(_serializeNumber(2\n  /* ByteString */\n  , bytes.byteLength), bytes);\n}\n\nexports.bytes = bytes;\n/**\n * Encode a JavaScript string.\n */\n\nfunction string(str) {\n  return _serializeString(str);\n}\n\nexports.string = string;\n/**\n * Encode an array of cbor values.\n */\n\nfunction array(items) {\n  return _concat.apply(void 0, [_serializeNumber(4\n  /* Array */\n  , items.length)].concat(_toConsumableArray(items)));\n}\n\nexports.array = array;\n/**\n * Encode a map of key-value pairs. The keys are string, and the values are CBOR\n * encoded.\n */\n\nfunction map(items) {\n  var stable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (!(items instanceof Map)) {\n    items = new Map(Object.entries(items));\n  }\n\n  var entries = Array.from(items.entries());\n\n  if (stable) {\n    entries = entries.sort(function (_ref, _ref2) {\n      var _ref3 = _slicedToArray(_ref, 1),\n          keyA = _ref3[0];\n\n      var _ref4 = _slicedToArray(_ref2, 1),\n          keyB = _ref4[0];\n\n      return keyA.localeCompare(keyB);\n    });\n  }\n\n  return _concat.apply(void 0, [_serializeNumber(5\n  /* Map */\n  , items.size)].concat(_toConsumableArray(entries.map(function (_ref5) {\n    var _ref6 = _slicedToArray(_ref5, 2),\n        k = _ref6[0],\n        v = _ref6[1];\n\n    return _concat(_serializeString(k), v);\n  }))));\n}\n\nexports.map = map;\n/**\n * Encode a single (32 bits) precision floating point number.\n */\n\nfunction singleFloat(f) {\n  var single = new Float32Array([f]);\n  return _concat(new Uint8Array([(7\n  /* SimpleValue */\n  << 5) + 26]), new Uint8Array(single.buffer));\n}\n\nexports.singleFloat = singleFloat;\n/**\n * Encode a double (64 bits) precision floating point number.\n */\n\nfunction doubleFloat(f) {\n  var single = new Float64Array([f]);\n  return _concat(new Uint8Array([(7\n  /* SimpleValue */\n  << 5) + 27]), new Uint8Array(single.buffer));\n}\n\nexports.doubleFloat = doubleFloat;\n\nfunction bool(v) {\n  return v ? true_() : false_();\n}\n\nexports.bool = bool;\n/**\n * Encode the boolean true.\n */\n\nfunction true_() {\n  return raw(new Uint8Array([(7\n  /* SimpleValue */\n  << 5) + 21]));\n}\n\nexports.true_ = true_;\n/**\n * Encode the boolean false.\n */\n\nfunction false_() {\n  return raw(new Uint8Array([(7\n  /* SimpleValue */\n  << 5) + 20]));\n}\n\nexports.false_ = false_;\n/**\n * Encode the constant null.\n */\n\nfunction null_() {\n  return raw(new Uint8Array([(7\n  /* SimpleValue */\n  << 5) + 22]));\n}\n\nexports.null_ = null_;\n/**\n * Encode the constant undefined.\n */\n\nfunction undefined_() {\n  return raw(new Uint8Array([(7\n  /* SimpleValue */\n  << 5) + 23]));\n}\n\nexports.undefined_ = undefined_;","map":{"version":3,"sources":["value.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst MAX_U64_NUMBER = 0x20000000000000;\nfunction _concat(a, ...args) {\n    const newBuffer = new Uint8Array(a.byteLength + args.reduce((acc, b) => acc + b.byteLength, 0));\n    newBuffer.set(new Uint8Array(a), 0);\n    let i = a.byteLength;\n    for (const b of args) {\n        newBuffer.set(new Uint8Array(b), i);\n        i += b.byteLength;\n    }\n    return newBuffer.buffer;\n}\nfunction _serializeValue(major, minor, value) {\n    // Remove everything that's not an hexadecimal character. These are not\n    // considered errors since the value was already validated and they might\n    // be number decimals or sign.\n    value = value.replace(/[^0-9a-fA-F]/g, \"\");\n    // Create the buffer from the value with left padding with 0.\n    const length = 2 ** (minor - 24 /* Int8 */);\n    value = value.slice(-length * 2).padStart(length * 2, \"0\");\n    const bytes = [(major << 5) + minor].concat(value.match(/../g).map((byte) => parseInt(byte, 16)));\n    return new Uint8Array(bytes).buffer;\n}\nfunction _serializeNumber(major, value) {\n    if (value < 24) {\n        return new Uint8Array([(major << 5) + value]).buffer;\n    }\n    else {\n        const minor = value <= 0xff\n            ? 24 /* Int8 */\n            : value <= 0xffff\n                ? 25 /* Int16 */\n                : value <= 0xffffffff\n                    ? 26 /* Int32 */\n                    : 27 /* Int64 */;\n        return _serializeValue(major, minor, value.toString(16));\n    }\n}\nfunction _serializeString(str) {\n    const utf8 = [];\n    for (let i = 0; i < str.length; i++) {\n        let charcode = str.charCodeAt(i);\n        if (charcode < 0x80) {\n            utf8.push(charcode);\n        }\n        else if (charcode < 0x800) {\n            utf8.push(0xc0 | (charcode >> 6), 0x80 | (charcode & 0x3f));\n        }\n        else if (charcode < 0xd800 || charcode >= 0xe000) {\n            utf8.push(0xe0 | (charcode >> 12), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));\n        }\n        else {\n            // Surrogate pair\n            i++;\n            charcode = ((charcode & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff);\n            utf8.push(0xf0 | (charcode >> 18), 0x80 | ((charcode >> 12) & 0x3f), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));\n        }\n    }\n    return _concat(new Uint8Array(_serializeNumber(3 /* TextString */, str.length)), new Uint8Array(utf8));\n}\n/**\n * Tag a value.\n */\nfunction tagged(tag, value) {\n    if (tag == 0xd9d9f7) {\n        return _concat(new Uint8Array([0xd9, 0xd9, 0xf7]), value);\n    }\n    if (tag < 24) {\n        return _concat(new Uint8Array([(6 /* Tag */ << 5) + tag]), value);\n    }\n    else {\n        const minor = tag <= 0xff\n            ? 24 /* Int8 */\n            : tag <= 0xffff\n                ? 25 /* Int16 */\n                : tag <= 0xffffffff\n                    ? 26 /* Int32 */\n                    : 27 /* Int64 */;\n        const length = 2 ** (minor - 24 /* Int8 */);\n        const value = tag\n            .toString(16)\n            .slice(-length * 2)\n            .padStart(length * 2, \"0\");\n        const bytes = [(6 /* Tag */ << 5) + minor].concat(value.match(/../g).map((byte) => parseInt(byte, 16)));\n        return new Uint8Array(bytes).buffer;\n    }\n}\nexports.tagged = tagged;\n/**\n * Set the raw bytes contained by this value. This should only be used with another\n * CborValue, or if you are implementing extensions to CBOR.\n * @param bytes A buffer containing the value.\n */\nfunction raw(bytes) {\n    return new Uint8Array(bytes).buffer;\n}\nexports.raw = raw;\n/**\n * Encode a number that is between [0, 23].\n * @param n\n */\nfunction uSmall(n) {\n    if (isNaN(n)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    n = Math.min(Math.max(0, n), 23); // Clamp it.\n    const bytes = [(0 /* UnsignedInteger */ << 5) + n];\n    return new Uint8Array(bytes).buffer;\n}\nexports.uSmall = uSmall;\nfunction u8(u8, radix) {\n    // Force u8 into a number, and validate it.\n    u8 = parseInt(\"\" + u8, radix);\n    if (isNaN(u8)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u8 = Math.min(Math.max(0, u8), 0xff); // Clamp it.\n    u8 = u8.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 24 /* Int8 */, u8);\n}\nexports.u8 = u8;\nfunction u16(u16, radix) {\n    // Force u16 into a number, and validate it.\n    u16 = parseInt(\"\" + u16, radix);\n    if (isNaN(u16)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u16 = Math.min(Math.max(0, u16), 0xffff); // Clamp it.\n    u16 = u16.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 25 /* Int16 */, u16);\n}\nexports.u16 = u16;\nfunction u32(u32, radix) {\n    // Force u32 into a number, and validate it.\n    u32 = parseInt(\"\" + u32, radix);\n    if (isNaN(u32)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u32 = Math.min(Math.max(0, u32), 0xffffffff); // Clamp it.\n    u32 = u32.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 26 /* Int32 */, u32);\n}\nexports.u32 = u32;\nfunction u64(u64, radix) {\n    // Special consideration for numbers that might be larger than expected.\n    if (typeof u64 == \"string\" && radix == 16) {\n        // This is the only case where we guarantee we'll encode the number directly.\n        // Validate it's all hexadecimal first.\n        if (u64.match(/[^0-9a-fA-F]/)) {\n            throw new RangeError(\"Invalid number.\");\n        }\n        return _serializeValue(0 /* UnsignedInteger */, 27 /* Int64 */, u64);\n    }\n    // Force u64 into a number, and validate it.\n    u64 = parseInt(\"\" + u64, radix);\n    if (isNaN(u64)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u64 = Math.min(Math.max(0, u64), MAX_U64_NUMBER); // Clamp it to actual limit.\n    u64 = u64.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 27 /* Int64 */, u64);\n}\nexports.u64 = u64;\n/**\n * Encode a negative number that is between [-24, -1].\n */\nfunction iSmall(n) {\n    if (isNaN(n)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    if (n === 0) {\n        return uSmall(0);\n    }\n    // Negative n, clamped to [1, 24], minus 1 (there's no negative 0).\n    n = Math.min(Math.max(0, -n), 24) - 1;\n    const bytes = [(1 /* SignedInteger */ << 5) + n];\n    return new Uint8Array(bytes).buffer;\n}\nexports.iSmall = iSmall;\nfunction i8(i8, radix) {\n    // Force i8 into a number, and validate it.\n    i8 = parseInt(\"\" + i8, radix);\n    if (isNaN(i8)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    // Negative n, clamped, minus 1 (there's no negative 0).\n    i8 = Math.min(Math.max(0, -i8 - 1), 0xff);\n    i8 = i8.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 24 /* Int8 */, i8);\n}\nexports.i8 = i8;\nfunction i16(i16, radix) {\n    // Force i16 into a number, and validate it.\n    i16 = parseInt(\"\" + i16, radix);\n    if (isNaN(i16)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    // Negative n, clamped, minus 1 (there's no negative 0).\n    i16 = Math.min(Math.max(0, -i16 - 1), 0xffff);\n    i16 = i16.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 25 /* Int16 */, i16);\n}\nexports.i16 = i16;\nfunction i32(i32, radix) {\n    // Force i32 into a number, and validate it.\n    i32 = parseInt(\"\" + i32, radix);\n    if (isNaN(i32)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    // Negative n, clamped, minus 1 (there's no negative 0).\n    i32 = Math.min(Math.max(0, -i32 - 1), 0xffffffff);\n    i32 = i32.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 26 /* Int32 */, i32);\n}\nexports.i32 = i32;\nfunction i64(i64, radix) {\n    // Special consideration for numbers that might be larger than expected.\n    if (typeof i64 == \"string\" && radix == 16) {\n        if (i64.startsWith(\"-\")) {\n            i64 = i64.slice(1);\n        }\n        else {\n            // Clamp it.\n            i64 = \"0\";\n        }\n        // This is the only case where we guarantee we'll encode the number directly.\n        // Validate it's all hexadecimal first.\n        if (i64.match(/[^0-9a-fA-F]/) || i64.length > 16) {\n            throw new RangeError(\"Invalid number.\");\n        }\n        // We need to do -1 to the number.\n        let done = false;\n        let newI64 = i64.split(\"\").reduceRight((acc, x) => {\n            if (done) {\n                return x + acc;\n            }\n            let n = parseInt(x, 16) - 1;\n            if (n >= 0) {\n                done = true;\n                return n.toString(16) + acc;\n            }\n            else {\n                return \"f\" + acc;\n            }\n        }, \"\");\n        if (!done) {\n            // This number was 0.\n            return u64(0);\n        }\n        return _serializeValue(1 /* SignedInteger */, 27 /* Int64 */, newI64);\n    }\n    // Force i64 into a number, and validate it.\n    i64 = parseInt(\"\" + i64, radix);\n    if (isNaN(i64)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    i64 = Math.min(Math.max(0, -i64 - 1), 0x20000000000000); // Clamp it to actual.\n    i64 = i64.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 27 /* Int64 */, i64);\n}\nexports.i64 = i64;\n/**\n * Encode a number using the smallest amount of bytes, by calling the methods\n * above. e.g. If the number fits in a u8, it will use that.\n */\nfunction number(n) {\n    if (n >= 0) {\n        if (n < 24) {\n            return uSmall(n);\n        }\n        else if (n <= 0xff) {\n            return u8(n);\n        }\n        else if (n <= 0xffff) {\n            return u16(n);\n        }\n        else if (n <= 0xffffffff) {\n            return u32(n);\n        }\n        else {\n            return u64(n);\n        }\n    }\n    else {\n        if (n >= -24) {\n            return iSmall(n);\n        }\n        else if (n >= -0xff) {\n            return i8(n);\n        }\n        else if (n >= -0xffff) {\n            return i16(n);\n        }\n        else if (n >= -0xffffffff) {\n            return i32(n);\n        }\n        else {\n            return i64(n);\n        }\n    }\n}\nexports.number = number;\n/**\n * Encode a byte array. This is different than the `raw()` method.\n */\nfunction bytes(bytes) {\n    return _concat(_serializeNumber(2 /* ByteString */, bytes.byteLength), bytes);\n}\nexports.bytes = bytes;\n/**\n * Encode a JavaScript string.\n */\nfunction string(str) {\n    return _serializeString(str);\n}\nexports.string = string;\n/**\n * Encode an array of cbor values.\n */\nfunction array(items) {\n    return _concat(_serializeNumber(4 /* Array */, items.length), ...items);\n}\nexports.array = array;\n/**\n * Encode a map of key-value pairs. The keys are string, and the values are CBOR\n * encoded.\n */\nfunction map(items, stable = false) {\n    if (!(items instanceof Map)) {\n        items = new Map(Object.entries(items));\n    }\n    let entries = Array.from(items.entries());\n    if (stable) {\n        entries = entries.sort(([keyA], [keyB]) => keyA.localeCompare(keyB));\n    }\n    return _concat(_serializeNumber(5 /* Map */, items.size), ...entries.map(([k, v]) => _concat(_serializeString(k), v)));\n}\nexports.map = map;\n/**\n * Encode a single (32 bits) precision floating point number.\n */\nfunction singleFloat(f) {\n    const single = new Float32Array([f]);\n    return _concat(new Uint8Array([(7 /* SimpleValue */ << 5) + 26]), new Uint8Array(single.buffer));\n}\nexports.singleFloat = singleFloat;\n/**\n * Encode a double (64 bits) precision floating point number.\n */\nfunction doubleFloat(f) {\n    const single = new Float64Array([f]);\n    return _concat(new Uint8Array([(7 /* SimpleValue */ << 5) + 27]), new Uint8Array(single.buffer));\n}\nexports.doubleFloat = doubleFloat;\nfunction bool(v) {\n    return v ? true_() : false_();\n}\nexports.bool = bool;\n/**\n * Encode the boolean true.\n */\nfunction true_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 21]));\n}\nexports.true_ = true_;\n/**\n * Encode the boolean false.\n */\nfunction false_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 20]));\n}\nexports.false_ = false_;\n/**\n * Encode the constant null.\n */\nfunction null_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 22]));\n}\nexports.null_ = null_;\n/**\n * Encode the constant undefined.\n */\nfunction undefined_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 23]));\n}\nexports.undefined_ = undefined_;\n//# sourceMappingURL=value.js.map"]},"metadata":{},"sourceType":"script"}