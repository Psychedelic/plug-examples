{"ast":null,"code":"import _regeneratorRuntime from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { RequestStatusResponseStatus } from '../agent';\nimport { Certificate } from '../certificate';\nimport { toHex } from '../utils/buffer';\nimport * as _strategy from './strategy';\nexport { _strategy as strategy };\nexport { defaultStrategy } from './strategy';\n/**\n * Polls the IC to check the status of the given request then\n * returns the response bytes once the request has been processed.\n * @param agent The agent to use to poll read_state.\n * @param canisterId The effective canister ID.\n * @param requestId The Request ID to poll status for.\n * @param strategy A polling strategy.\n */\n\nexport function pollForResponse(_x, _x2, _x3, _x4) {\n  return _pollForResponse.apply(this, arguments);\n}\n\nfunction _pollForResponse() {\n  _pollForResponse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(agent, canisterId, requestId, strategy) {\n    var path, state, cert, verified, maybeBuf, status, rejectCode, rejectMessage;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            path = [new TextEncoder().encode('request_status'), requestId];\n            _context.next = 3;\n            return agent.readState(canisterId, {\n              paths: [path]\n            });\n\n          case 3:\n            state = _context.sent;\n            cert = new Certificate(state, agent);\n            _context.next = 7;\n            return cert.verify();\n\n          case 7:\n            verified = _context.sent;\n\n            if (verified) {\n              _context.next = 10;\n              break;\n            }\n\n            throw new Error('Fail to verify certificate');\n\n          case 10:\n            maybeBuf = cert.lookup([].concat(path, [new TextEncoder().encode('status')]));\n\n            if (typeof maybeBuf === 'undefined') {\n              // Missing requestId means we need to wait\n              status = RequestStatusResponseStatus.Unknown;\n            } else {\n              status = new TextDecoder().decode(maybeBuf);\n            }\n\n            _context.t0 = status;\n            _context.next = _context.t0 === RequestStatusResponseStatus.Replied ? 15 : _context.t0 === RequestStatusResponseStatus.Received ? 16 : _context.t0 === RequestStatusResponseStatus.Unknown ? 16 : _context.t0 === RequestStatusResponseStatus.Processing ? 16 : _context.t0 === RequestStatusResponseStatus.Rejected ? 19 : _context.t0 === RequestStatusResponseStatus.Done ? 22 : 23;\n            break;\n\n          case 15:\n            return _context.abrupt(\"return\", cert.lookup([].concat(path, ['reply'])));\n\n          case 16:\n            _context.next = 18;\n            return strategy(canisterId, requestId, status);\n\n          case 18:\n            return _context.abrupt(\"return\", pollForResponse(agent, canisterId, requestId, strategy));\n\n          case 19:\n            rejectCode = new Uint8Array(cert.lookup([].concat(path, ['reject_code'])))[0];\n            rejectMessage = new TextDecoder().decode(cert.lookup([].concat(path, ['reject_message'])));\n            throw new Error(\"Call was rejected:\\n\" + \"  Request ID: \".concat(toHex(requestId), \"\\n\") + \"  Reject code: \".concat(rejectCode, \"\\n\") + \"  Reject text: \".concat(rejectMessage, \"\\n\"));\n\n          case 22:\n            throw new Error(\"Call was marked as done but we never saw the reply:\\n\" + \"  Request ID: \".concat(toHex(requestId), \"\\n\"));\n\n          case 23:\n            throw new Error('unreachable');\n\n          case 24:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _pollForResponse.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../src/polling/index.ts"],"names":[],"mappings":";;AACA,SAAgB,2BAAhB,QAAmD,UAAnD;AACA,SAAS,WAAT,QAA4B,gBAA5B;AAEA,SAAS,KAAT,QAAsB,iBAAtB;2BAE0B,Y;sBAAd,Q;AACZ,SAAS,eAAT,QAAgC,YAAhC;AAQA;;;;;;;AAOG;;AACH,gBAAsB,eAAtB;AAAA;AAAA;;;8EAAO,iBACL,KADK,EAEL,UAFK,EAGL,SAHK,EAIL,QAJK;AAAA;AAAA;AAAA;AAAA;AAAA;AAMC,YAAA,IAND,GAMQ,CAAC,IAAI,WAAJ,GAAkB,MAAlB,CAAyB,gBAAzB,CAAD,EAA6C,SAA7C,CANR;AAAA;AAAA,mBAOe,KAAK,CAAC,SAAN,CAAgB,UAAhB,EAA4B;AAAE,cAAA,KAAK,EAAE,CAAC,IAAD;AAAT,aAA5B,CAPf;;AAAA;AAOC,YAAA,KAPD;AAQC,YAAA,IARD,GAQQ,IAAI,WAAJ,CAAgB,KAAhB,EAAuB,KAAvB,CARR;AAAA;AAAA,mBASkB,IAAI,CAAC,MAAL,EATlB;;AAAA;AASC,YAAA,QATD;;AAAA,gBAUA,QAVA;AAAA;AAAA;AAAA;;AAAA,kBAWG,IAAI,KAAJ,CAAU,4BAAV,CAXH;;AAAA;AAaC,YAAA,QAbD,GAaY,IAAI,CAAC,MAAL,WAAgB,IAAhB,GAAsB,IAAI,WAAJ,GAAkB,MAAlB,CAAyB,QAAzB,CAAtB,GAbZ;;AAeL,gBAAI,OAAO,QAAP,KAAoB,WAAxB,EAAqC;AACnC;AACA,cAAA,MAAM,GAAG,2BAA2B,CAAC,OAArC;AACD,aAHD,MAGO;AACL,cAAA,MAAM,GAAG,IAAI,WAAJ,GAAkB,MAAlB,CAAyB,QAAzB,CAAT;AACD;;AApBI,0BAsBG,MAtBH;AAAA,4CAuBE,2BAA2B,CAAC,OAvB9B,wBA2BE,2BAA2B,CAAC,QA3B9B,wBA4BE,2BAA2B,CAAC,OA5B9B,wBA6BE,2BAA2B,CAAC,UA7B9B,wBAkCE,2BAA2B,CAAC,QAlC9B,wBA6CE,2BAA2B,CAAC,IA7C9B;AAAA;;AAAA;AAAA,6CAwBM,IAAI,CAAC,MAAL,WAAgB,IAAhB,GAAsB,OAAtB,GAxBN;;AAAA;AAAA;AAAA,mBA+BK,QAAQ,CAAC,UAAD,EAAa,SAAb,EAAwB,MAAxB,CA/Bb;;AAAA;AAAA,6CAgCM,eAAe,CAAC,KAAD,EAAQ,UAAR,EAAoB,SAApB,EAA+B,QAA/B,CAhCrB;;AAAA;AAmCK,YAAA,UAnCL,GAmCkB,IAAI,UAAJ,CAAe,IAAI,CAAC,MAAL,WAAgB,IAAhB,GAAsB,aAAtB,GAAf,EAAuD,CAAvD,CAnClB;AAoCK,YAAA,aApCL,GAoCqB,IAAI,WAAJ,GAAkB,MAAlB,CAAyB,IAAI,CAAC,MAAL,WAAgB,IAAhB,GAAsB,gBAAtB,GAAzB,CApCrB;AAAA,kBAqCK,IAAI,KAAJ,CACJ,iDACmB,KAAK,CAAC,SAAD,CADxB,mCAEoB,UAFpB,mCAGoB,aAHpB,OADI,CArCL;;AAAA;AAAA,kBAgDK,IAAI,KAAJ,CACJ,kFACmB,KAAK,CAAC,SAAD,CADxB,OADI,CAhDL;;AAAA;AAAA,kBAqDC,IAAI,KAAJ,CAAU,aAAV,CArDD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourceRoot":"","sourcesContent":["import { RequestStatusResponseStatus } from '../agent';\nimport { Certificate } from '../certificate';\nimport { toHex } from '../utils/buffer';\nexport * as strategy from './strategy';\nexport { defaultStrategy } from './strategy';\n/**\n * Polls the IC to check the status of the given request then\n * returns the response bytes once the request has been processed.\n * @param agent The agent to use to poll read_state.\n * @param canisterId The effective canister ID.\n * @param requestId The Request ID to poll status for.\n * @param strategy A polling strategy.\n */\nexport async function pollForResponse(agent, canisterId, requestId, strategy) {\n    const path = [new TextEncoder().encode('request_status'), requestId];\n    const state = await agent.readState(canisterId, { paths: [path] });\n    const cert = new Certificate(state, agent);\n    const verified = await cert.verify();\n    if (!verified) {\n        throw new Error('Fail to verify certificate');\n    }\n    const maybeBuf = cert.lookup([...path, new TextEncoder().encode('status')]);\n    let status;\n    if (typeof maybeBuf === 'undefined') {\n        // Missing requestId means we need to wait\n        status = RequestStatusResponseStatus.Unknown;\n    }\n    else {\n        status = new TextDecoder().decode(maybeBuf);\n    }\n    switch (status) {\n        case RequestStatusResponseStatus.Replied: {\n            return cert.lookup([...path, 'reply']);\n        }\n        case RequestStatusResponseStatus.Received:\n        case RequestStatusResponseStatus.Unknown:\n        case RequestStatusResponseStatus.Processing:\n            // Execute the polling strategy, then retry.\n            await strategy(canisterId, requestId, status);\n            return pollForResponse(agent, canisterId, requestId, strategy);\n        case RequestStatusResponseStatus.Rejected: {\n            const rejectCode = new Uint8Array(cert.lookup([...path, 'reject_code']))[0];\n            const rejectMessage = new TextDecoder().decode(cert.lookup([...path, 'reject_message']));\n            throw new Error(`Call was rejected:\\n` +\n                `  Request ID: ${toHex(requestId)}\\n` +\n                `  Reject code: ${rejectCode}\\n` +\n                `  Reject text: ${rejectMessage}\\n`);\n        }\n        case RequestStatusResponseStatus.Done:\n            // This is _technically_ not an error, but we still didn't see the `Replied` status so\n            // we don't know the result and cannot decode it.\n            throw new Error(`Call was marked as done but we never saw the reply:\\n` +\n                `  Request ID: ${toHex(requestId)}\\n`);\n    }\n    throw new Error('unreachable');\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}