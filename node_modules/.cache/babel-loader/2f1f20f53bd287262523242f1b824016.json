{"ast":null,"code":"import _defineProperty from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _createForOfIteratorHelper from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _slicedToArray from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _inherits from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _toConsumableArray from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n// tslint:disable:max-classes-per-file\nimport { Principal as PrincipalId } from '@dfinity/principal';\nimport { concat, PipeArrayBuffer as Pipe } from './utils/buffer';\nimport { idlLabelToId } from './utils/hash';\nimport { lebDecode, lebEncode, safeRead, safeReadUint8, slebDecode, slebEncode } from './utils/leb128';\nimport { readIntLE, readUIntLE, writeIntLE, writeUIntLE } from './utils/leb128';\nvar magicNumber = 'DIDL';\n\nfunction zipWith(xs, ys, f) {\n  return xs.map(function (x, i) {\n    return f(x, ys[i]);\n  });\n}\n/**\n * An IDL Type Table, which precedes the data in the stream.\n */\n\n\nvar TypeTable = /*#__PURE__*/function () {\n  function TypeTable() {\n    _classCallCheck(this, TypeTable);\n\n    // List of types. Needs to be an array as the index needs to be stable.\n    this._typs = [];\n    this._idx = new Map();\n  }\n\n  _createClass(TypeTable, [{\n    key: \"has\",\n    value: function has(obj) {\n      return this._idx.has(obj.name);\n    }\n  }, {\n    key: \"add\",\n    value: function add(type, buf) {\n      var idx = this._typs.length;\n\n      this._idx.set(type.name, idx);\n\n      this._typs.push(buf);\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(obj, knot) {\n      var idx = this._idx.get(obj.name);\n\n      var knotIdx = this._idx.get(knot);\n\n      if (idx === undefined) {\n        throw new Error('Missing type index for ' + obj);\n      }\n\n      if (knotIdx === undefined) {\n        throw new Error('Missing type index for ' + knot);\n      }\n\n      this._typs[idx] = this._typs[knotIdx]; // Delete the type.\n\n      this._typs.splice(knotIdx, 1);\n\n      this._idx.delete(knot);\n    }\n  }, {\n    key: \"encode\",\n    value: function encode() {\n      var len = lebEncode(this._typs.length);\n      var buf = concat.apply(void 0, _toConsumableArray(this._typs));\n      return concat(len, buf);\n    }\n  }, {\n    key: \"indexOf\",\n    value: function indexOf(typeName) {\n      if (!this._idx.has(typeName)) {\n        throw new Error('Missing type index for ' + typeName);\n      }\n\n      return slebEncode(this._idx.get(typeName) || 0);\n    }\n  }]);\n\n  return TypeTable;\n}();\n\nexport var Visitor = /*#__PURE__*/function () {\n  function Visitor() {\n    _classCallCheck(this, Visitor);\n  }\n\n  _createClass(Visitor, [{\n    key: \"visitType\",\n    value: function visitType(t, data) {\n      throw new Error('Not implemented');\n    }\n  }, {\n    key: \"visitPrimitive\",\n    value: function visitPrimitive(t, data) {\n      return this.visitType(t, data);\n    }\n  }, {\n    key: \"visitEmpty\",\n    value: function visitEmpty(t, data) {\n      return this.visitPrimitive(t, data);\n    }\n  }, {\n    key: \"visitBool\",\n    value: function visitBool(t, data) {\n      return this.visitPrimitive(t, data);\n    }\n  }, {\n    key: \"visitNull\",\n    value: function visitNull(t, data) {\n      return this.visitPrimitive(t, data);\n    }\n  }, {\n    key: \"visitReserved\",\n    value: function visitReserved(t, data) {\n      return this.visitPrimitive(t, data);\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(t, data) {\n      return this.visitPrimitive(t, data);\n    }\n  }, {\n    key: \"visitNumber\",\n    value: function visitNumber(t, data) {\n      return this.visitPrimitive(t, data);\n    }\n  }, {\n    key: \"visitInt\",\n    value: function visitInt(t, data) {\n      return this.visitNumber(t, data);\n    }\n  }, {\n    key: \"visitNat\",\n    value: function visitNat(t, data) {\n      return this.visitNumber(t, data);\n    }\n  }, {\n    key: \"visitFloat\",\n    value: function visitFloat(t, data) {\n      return this.visitPrimitive(t, data);\n    }\n  }, {\n    key: \"visitFixedInt\",\n    value: function visitFixedInt(t, data) {\n      return this.visitNumber(t, data);\n    }\n  }, {\n    key: \"visitFixedNat\",\n    value: function visitFixedNat(t, data) {\n      return this.visitNumber(t, data);\n    }\n  }, {\n    key: \"visitPrincipal\",\n    value: function visitPrincipal(t, data) {\n      return this.visitPrimitive(t, data);\n    }\n  }, {\n    key: \"visitConstruct\",\n    value: function visitConstruct(t, data) {\n      return this.visitType(t, data);\n    }\n  }, {\n    key: \"visitVec\",\n    value: function visitVec(t, ty, data) {\n      return this.visitConstruct(t, data);\n    }\n  }, {\n    key: \"visitOpt\",\n    value: function visitOpt(t, ty, data) {\n      return this.visitConstruct(t, data);\n    }\n  }, {\n    key: \"visitRecord\",\n    value: function visitRecord(t, fields, data) {\n      return this.visitConstruct(t, data);\n    }\n  }, {\n    key: \"visitTuple\",\n    value: function visitTuple(t, components, data) {\n      var fields = components.map(function (ty, i) {\n        return [\"_\".concat(i, \"_\"), ty];\n      });\n      return this.visitRecord(t, fields, data);\n    }\n  }, {\n    key: \"visitVariant\",\n    value: function visitVariant(t, fields, data) {\n      return this.visitConstruct(t, data);\n    }\n  }, {\n    key: \"visitRec\",\n    value: function visitRec(t, ty, data) {\n      return this.visitConstruct(ty, data);\n    }\n  }, {\n    key: \"visitFunc\",\n    value: function visitFunc(t, data) {\n      return this.visitConstruct(t, data);\n    }\n  }, {\n    key: \"visitService\",\n    value: function visitService(t, data) {\n      return this.visitConstruct(t, data);\n    }\n  }]);\n\n  return Visitor;\n}();\n/**\n * Represents an IDL type.\n */\n\nexport var Type = /*#__PURE__*/function () {\n  function Type() {\n    _classCallCheck(this, Type);\n  }\n\n  _createClass(Type, [{\n    key: \"display\",\n    value:\n    /* Display type name */\n    function display() {\n      return this.name;\n    }\n  }, {\n    key: \"valueToString\",\n    value: function valueToString(x) {\n      return toReadableString(x);\n    }\n    /* Implement `T` in the IDL spec, only needed for non-primitive types */\n\n  }, {\n    key: \"buildTypeTable\",\n    value: function buildTypeTable(typeTable) {\n      if (!typeTable.has(this)) {\n        this._buildTypeTableImpl(typeTable);\n      }\n    }\n  }]);\n\n  return Type;\n}();\nexport var PrimitiveType = /*#__PURE__*/function (_Type) {\n  _inherits(PrimitiveType, _Type);\n\n  var _super = _createSuper(PrimitiveType);\n\n  function PrimitiveType() {\n    _classCallCheck(this, PrimitiveType);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PrimitiveType, [{\n    key: \"checkType\",\n    value: function checkType(t) {\n      if (this.name !== t.name) {\n        throw new Error(\"type mismatch: type on the wire \".concat(t.name, \", expect type \").concat(this.name));\n      }\n\n      return t;\n    }\n  }, {\n    key: \"_buildTypeTableImpl\",\n    value: function _buildTypeTableImpl(typeTable) {\n      // No type table encoding for Primitive types.\n      return;\n    }\n  }]);\n\n  return PrimitiveType;\n}(Type);\nexport var ConstructType = /*#__PURE__*/function (_Type2) {\n  _inherits(ConstructType, _Type2);\n\n  var _super2 = _createSuper(ConstructType);\n\n  function ConstructType() {\n    _classCallCheck(this, ConstructType);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(ConstructType, [{\n    key: \"checkType\",\n    value: function checkType(t) {\n      if (t instanceof RecClass) {\n        var ty = t.getType();\n\n        if (typeof ty === 'undefined') {\n          throw new Error('type mismatch with uninitialized type');\n        }\n\n        return ty;\n      }\n\n      throw new Error(\"type mismatch: type on the wire \".concat(t.name, \", expect type \").concat(this.name));\n    }\n  }, {\n    key: \"encodeType\",\n    value: function encodeType(typeTable) {\n      return typeTable.indexOf(this.name);\n    }\n  }]);\n\n  return ConstructType;\n}(Type);\n/**\n * Represents an IDL Empty, a type which has no inhabitants.\n * Since no values exist for this type, it cannot be serialised or deserialised.\n * Result types like `Result<Text, Empty>` should always succeed.\n */\n\nexport var EmptyClass = /*#__PURE__*/function (_PrimitiveType) {\n  _inherits(EmptyClass, _PrimitiveType);\n\n  var _super3 = _createSuper(EmptyClass);\n\n  function EmptyClass() {\n    _classCallCheck(this, EmptyClass);\n\n    return _super3.apply(this, arguments);\n  }\n\n  _createClass(EmptyClass, [{\n    key: \"accept\",\n    value: function accept(v, d) {\n      return v.visitEmpty(this, d);\n    }\n  }, {\n    key: \"covariant\",\n    value: function covariant(x) {\n      return false;\n    }\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue() {\n      throw new Error('Empty cannot appear as a function argument');\n    }\n  }, {\n    key: \"valueToString\",\n    value: function valueToString() {\n      throw new Error('Empty cannot appear as a value');\n    }\n  }, {\n    key: \"encodeType\",\n    value: function encodeType() {\n      return slebEncode(-17\n      /* Empty */\n      );\n    }\n  }, {\n    key: \"decodeValue\",\n    value: function decodeValue() {\n      throw new Error('Empty cannot appear as an output');\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return 'empty';\n    }\n  }]);\n\n  return EmptyClass;\n}(PrimitiveType);\n/**\n * Represents an IDL Bool\n */\n\nexport var BoolClass = /*#__PURE__*/function (_PrimitiveType2) {\n  _inherits(BoolClass, _PrimitiveType2);\n\n  var _super4 = _createSuper(BoolClass);\n\n  function BoolClass() {\n    _classCallCheck(this, BoolClass);\n\n    return _super4.apply(this, arguments);\n  }\n\n  _createClass(BoolClass, [{\n    key: \"accept\",\n    value: function accept(v, d) {\n      return v.visitBool(this, d);\n    }\n  }, {\n    key: \"covariant\",\n    value: function covariant(x) {\n      return typeof x === 'boolean';\n    }\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue(x) {\n      return new Uint8Array([x ? 1 : 0]);\n    }\n  }, {\n    key: \"encodeType\",\n    value: function encodeType() {\n      return slebEncode(-2\n      /* Bool */\n      );\n    }\n  }, {\n    key: \"decodeValue\",\n    value: function decodeValue(b, t) {\n      this.checkType(t);\n\n      switch (safeReadUint8(b)) {\n        case 0:\n          return false;\n\n        case 1:\n          return true;\n\n        default:\n          throw new Error('Boolean value out of range');\n      }\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return 'bool';\n    }\n  }]);\n\n  return BoolClass;\n}(PrimitiveType);\n/**\n * Represents an IDL Null\n */\n\nexport var NullClass = /*#__PURE__*/function (_PrimitiveType3) {\n  _inherits(NullClass, _PrimitiveType3);\n\n  var _super5 = _createSuper(NullClass);\n\n  function NullClass() {\n    _classCallCheck(this, NullClass);\n\n    return _super5.apply(this, arguments);\n  }\n\n  _createClass(NullClass, [{\n    key: \"accept\",\n    value: function accept(v, d) {\n      return v.visitNull(this, d);\n    }\n  }, {\n    key: \"covariant\",\n    value: function covariant(x) {\n      return x === null;\n    }\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue() {\n      return new ArrayBuffer(0);\n    }\n  }, {\n    key: \"encodeType\",\n    value: function encodeType() {\n      return slebEncode(-1\n      /* Null */\n      );\n    }\n  }, {\n    key: \"decodeValue\",\n    value: function decodeValue(b, t) {\n      this.checkType(t);\n      return null;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return 'null';\n    }\n  }]);\n\n  return NullClass;\n}(PrimitiveType);\n/**\n * Represents an IDL Reserved\n */\n\nexport var ReservedClass = /*#__PURE__*/function (_PrimitiveType4) {\n  _inherits(ReservedClass, _PrimitiveType4);\n\n  var _super6 = _createSuper(ReservedClass);\n\n  function ReservedClass() {\n    _classCallCheck(this, ReservedClass);\n\n    return _super6.apply(this, arguments);\n  }\n\n  _createClass(ReservedClass, [{\n    key: \"accept\",\n    value: function accept(v, d) {\n      return v.visitReserved(this, d);\n    }\n  }, {\n    key: \"covariant\",\n    value: function covariant(x) {\n      return true;\n    }\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue() {\n      return new ArrayBuffer(0);\n    }\n  }, {\n    key: \"encodeType\",\n    value: function encodeType() {\n      return slebEncode(-16\n      /* Reserved */\n      );\n    }\n  }, {\n    key: \"decodeValue\",\n    value: function decodeValue(b, t) {\n      if (t.name !== this.name) {\n        t.decodeValue(b, t);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return 'reserved';\n    }\n  }]);\n\n  return ReservedClass;\n}(PrimitiveType);\n/**\n * Represents an IDL Text\n */\n\nexport var TextClass = /*#__PURE__*/function (_PrimitiveType5) {\n  _inherits(TextClass, _PrimitiveType5);\n\n  var _super7 = _createSuper(TextClass);\n\n  function TextClass() {\n    _classCallCheck(this, TextClass);\n\n    return _super7.apply(this, arguments);\n  }\n\n  _createClass(TextClass, [{\n    key: \"accept\",\n    value: function accept(v, d) {\n      return v.visitText(this, d);\n    }\n  }, {\n    key: \"covariant\",\n    value: function covariant(x) {\n      return typeof x === 'string';\n    }\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue(x) {\n      var buf = new TextEncoder().encode(x);\n      var len = lebEncode(buf.byteLength);\n      return concat(len, buf);\n    }\n  }, {\n    key: \"encodeType\",\n    value: function encodeType() {\n      return slebEncode(-15\n      /* Text */\n      );\n    }\n  }, {\n    key: \"decodeValue\",\n    value: function decodeValue(b, t) {\n      this.checkType(t);\n      var len = lebDecode(b);\n      var buf = safeRead(b, Number(len));\n      var decoder = new TextDecoder('utf8', {\n        fatal: true\n      });\n      return decoder.decode(buf);\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return 'text';\n    }\n  }, {\n    key: \"valueToString\",\n    value: function valueToString(x) {\n      return '\"' + x + '\"';\n    }\n  }]);\n\n  return TextClass;\n}(PrimitiveType);\n/**\n * Represents an IDL Int\n */\n\nexport var IntClass = /*#__PURE__*/function (_PrimitiveType6) {\n  _inherits(IntClass, _PrimitiveType6);\n\n  var _super8 = _createSuper(IntClass);\n\n  function IntClass() {\n    _classCallCheck(this, IntClass);\n\n    return _super8.apply(this, arguments);\n  }\n\n  _createClass(IntClass, [{\n    key: \"accept\",\n    value: function accept(v, d) {\n      return v.visitInt(this, d);\n    }\n  }, {\n    key: \"covariant\",\n    value: function covariant(x) {\n      // We allow encoding of JavaScript plain numbers.\n      // But we will always decode to bigint.\n      return typeof x === 'bigint' || Number.isInteger(x);\n    }\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue(x) {\n      return slebEncode(x);\n    }\n  }, {\n    key: \"encodeType\",\n    value: function encodeType() {\n      return slebEncode(-4\n      /* Int */\n      );\n    }\n  }, {\n    key: \"decodeValue\",\n    value: function decodeValue(b, t) {\n      this.checkType(t);\n      return slebDecode(b);\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return 'int';\n    }\n  }, {\n    key: \"valueToString\",\n    value: function valueToString(x) {\n      return x.toString();\n    }\n  }]);\n\n  return IntClass;\n}(PrimitiveType);\n/**\n * Represents an IDL Nat\n */\n\nexport var NatClass = /*#__PURE__*/function (_PrimitiveType7) {\n  _inherits(NatClass, _PrimitiveType7);\n\n  var _super9 = _createSuper(NatClass);\n\n  function NatClass() {\n    _classCallCheck(this, NatClass);\n\n    return _super9.apply(this, arguments);\n  }\n\n  _createClass(NatClass, [{\n    key: \"accept\",\n    value: function accept(v, d) {\n      return v.visitNat(this, d);\n    }\n  }, {\n    key: \"covariant\",\n    value: function covariant(x) {\n      // We allow encoding of JavaScript plain numbers.\n      // But we will always decode to bigint.\n      return typeof x === 'bigint' && x >= BigInt(0) || Number.isInteger(x) && x >= 0;\n    }\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue(x) {\n      return lebEncode(x);\n    }\n  }, {\n    key: \"encodeType\",\n    value: function encodeType() {\n      return slebEncode(-3\n      /* Nat */\n      );\n    }\n  }, {\n    key: \"decodeValue\",\n    value: function decodeValue(b, t) {\n      this.checkType(t);\n      return lebDecode(b);\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return 'nat';\n    }\n  }, {\n    key: \"valueToString\",\n    value: function valueToString(x) {\n      return x.toString();\n    }\n  }]);\n\n  return NatClass;\n}(PrimitiveType);\n/**\n * Represents an IDL Float\n */\n\nexport var FloatClass = /*#__PURE__*/function (_PrimitiveType8) {\n  _inherits(FloatClass, _PrimitiveType8);\n\n  var _super10 = _createSuper(FloatClass);\n\n  function FloatClass(_bits) {\n    var _this;\n\n    _classCallCheck(this, FloatClass);\n\n    _this = _super10.call(this);\n    _this._bits = _bits;\n\n    if (_bits !== 32 && _bits !== 64) {\n      throw new Error('not a valid float type');\n    }\n\n    return _this;\n  }\n\n  _createClass(FloatClass, [{\n    key: \"accept\",\n    value: function accept(v, d) {\n      return v.visitFloat(this, d);\n    }\n  }, {\n    key: \"covariant\",\n    value: function covariant(x) {\n      return typeof x === 'number' || x instanceof Number;\n    }\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue(x) {\n      var buf = new ArrayBuffer(this._bits / 8);\n      var view = new DataView(buf);\n\n      if (this._bits === 32) {\n        view.setFloat32(0, x, true);\n      } else {\n        view.setFloat64(0, x, true);\n      }\n\n      return buf;\n    }\n  }, {\n    key: \"encodeType\",\n    value: function encodeType() {\n      var opcode = this._bits === 32 ? -13\n      /* Float32 */\n      : -14\n      /* Float64 */\n      ;\n      return slebEncode(opcode);\n    }\n  }, {\n    key: \"decodeValue\",\n    value: function decodeValue(b, t) {\n      this.checkType(t);\n      var bytes = safeRead(b, this._bits / 8);\n      var view = new DataView(bytes);\n\n      if (this._bits === 32) {\n        return view.getFloat32(0, true);\n      } else {\n        return view.getFloat64(0, true);\n      }\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return 'float' + this._bits;\n    }\n  }, {\n    key: \"valueToString\",\n    value: function valueToString(x) {\n      return x.toString();\n    }\n  }]);\n\n  return FloatClass;\n}(PrimitiveType);\n/**\n * Represents an IDL fixed-width Int(n)\n */\n\nexport var FixedIntClass = /*#__PURE__*/function (_PrimitiveType9) {\n  _inherits(FixedIntClass, _PrimitiveType9);\n\n  var _super11 = _createSuper(FixedIntClass);\n\n  function FixedIntClass(_bits) {\n    var _this2;\n\n    _classCallCheck(this, FixedIntClass);\n\n    _this2 = _super11.call(this);\n    _this2._bits = _bits;\n    return _this2;\n  }\n\n  _createClass(FixedIntClass, [{\n    key: \"accept\",\n    value: function accept(v, d) {\n      return v.visitFixedInt(this, d);\n    }\n  }, {\n    key: \"covariant\",\n    value: function covariant(x) {\n      var min = Math.pow(BigInt(2), BigInt(this._bits - 1)) * BigInt(-1);\n      var max = Math.pow(BigInt(2), BigInt(this._bits - 1)) - BigInt(1);\n\n      if (typeof x === 'bigint') {\n        return x >= min && x <= max;\n      } else if (Number.isInteger(x)) {\n        var v = BigInt(x);\n        return v >= min && v <= max;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue(x) {\n      return writeIntLE(x, this._bits / 8);\n    }\n  }, {\n    key: \"encodeType\",\n    value: function encodeType() {\n      var offset = Math.log2(this._bits) - 3;\n      return slebEncode(-9 - offset);\n    }\n  }, {\n    key: \"decodeValue\",\n    value: function decodeValue(b, t) {\n      this.checkType(t);\n      var num = readIntLE(b, this._bits / 8);\n\n      if (this._bits <= 32) {\n        return Number(num);\n      } else {\n        return num;\n      }\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return \"int\".concat(this._bits);\n    }\n  }, {\n    key: \"valueToString\",\n    value: function valueToString(x) {\n      return x.toString();\n    }\n  }]);\n\n  return FixedIntClass;\n}(PrimitiveType);\n/**\n * Represents an IDL fixed-width Nat(n)\n */\n\nexport var FixedNatClass = /*#__PURE__*/function (_PrimitiveType10) {\n  _inherits(FixedNatClass, _PrimitiveType10);\n\n  var _super12 = _createSuper(FixedNatClass);\n\n  function FixedNatClass(bits) {\n    var _this3;\n\n    _classCallCheck(this, FixedNatClass);\n\n    _this3 = _super12.call(this);\n    _this3.bits = bits;\n    return _this3;\n  }\n\n  _createClass(FixedNatClass, [{\n    key: \"accept\",\n    value: function accept(v, d) {\n      return v.visitFixedNat(this, d);\n    }\n  }, {\n    key: \"covariant\",\n    value: function covariant(x) {\n      var max = Math.pow(BigInt(2), BigInt(this.bits));\n\n      if (typeof x === 'bigint' && x >= BigInt(0)) {\n        return x < max;\n      } else if (Number.isInteger(x) && x >= 0) {\n        var v = BigInt(x);\n        return v < max;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue(x) {\n      return writeUIntLE(x, this.bits / 8);\n    }\n  }, {\n    key: \"encodeType\",\n    value: function encodeType() {\n      var offset = Math.log2(this.bits) - 3;\n      return slebEncode(-5 - offset);\n    }\n  }, {\n    key: \"decodeValue\",\n    value: function decodeValue(b, t) {\n      this.checkType(t);\n      var num = readUIntLE(b, this.bits / 8);\n\n      if (this.bits <= 32) {\n        return Number(num);\n      } else {\n        return num;\n      }\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return \"nat\".concat(this.bits);\n    }\n  }, {\n    key: \"valueToString\",\n    value: function valueToString(x) {\n      return x.toString();\n    }\n  }]);\n\n  return FixedNatClass;\n}(PrimitiveType);\n/**\n * Represents an IDL Array\n * @param {Type} t\n */\n\nexport var VecClass = /*#__PURE__*/function (_ConstructType) {\n  _inherits(VecClass, _ConstructType);\n\n  var _super13 = _createSuper(VecClass);\n\n  function VecClass(_type) {\n    var _this4;\n\n    _classCallCheck(this, VecClass);\n\n    _this4 = _super13.call(this);\n    _this4._type = _type; // If true, this vector is really a blob and we can just use memcpy.\n\n    _this4._blobOptimization = false;\n\n    if (_type instanceof FixedNatClass && _type.bits === 8) {\n      _this4._blobOptimization = true;\n    }\n\n    return _this4;\n  }\n\n  _createClass(VecClass, [{\n    key: \"accept\",\n    value: function accept(v, d) {\n      return v.visitVec(this, this._type, d);\n    }\n  }, {\n    key: \"covariant\",\n    value: function covariant(x) {\n      var _this5 = this;\n\n      return Array.isArray(x) && x.every(function (v) {\n        return _this5._type.covariant(v);\n      });\n    }\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue(x) {\n      var _this6 = this;\n\n      var len = lebEncode(x.length);\n\n      if (this._blobOptimization) {\n        return concat(len, new Uint8Array(x));\n      }\n\n      return concat.apply(void 0, [len].concat(_toConsumableArray(x.map(function (d) {\n        return _this6._type.encodeValue(d);\n      }))));\n    }\n  }, {\n    key: \"_buildTypeTableImpl\",\n    value: function _buildTypeTableImpl(typeTable) {\n      this._type.buildTypeTable(typeTable);\n\n      var opCode = slebEncode(-19\n      /* Vector */\n      );\n\n      var buffer = this._type.encodeType(typeTable);\n\n      typeTable.add(this, concat(opCode, buffer));\n    }\n  }, {\n    key: \"decodeValue\",\n    value: function decodeValue(b, t) {\n      var vec = this.checkType(t);\n\n      if (!(vec instanceof VecClass)) {\n        throw new Error('Not a vector type');\n      }\n\n      var len = Number(lebDecode(b));\n\n      if (this._blobOptimization) {\n        return _toConsumableArray(new Uint8Array(b.read(len)));\n      }\n\n      var rets = [];\n\n      for (var i = 0; i < len; i++) {\n        rets.push(this._type.decodeValue(b, vec._type));\n      }\n\n      return rets;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return \"vec \".concat(this._type.name);\n    }\n  }, {\n    key: \"display\",\n    value: function display() {\n      return \"vec \".concat(this._type.display());\n    }\n  }, {\n    key: \"valueToString\",\n    value: function valueToString(x) {\n      var _this7 = this;\n\n      var elements = x.map(function (e) {\n        return _this7._type.valueToString(e);\n      });\n      return 'vec {' + elements.join('; ') + '}';\n    }\n  }]);\n\n  return VecClass;\n}(ConstructType);\n/**\n * Represents an IDL Option\n * @param {Type} t\n */\n\nexport var OptClass = /*#__PURE__*/function (_ConstructType2) {\n  _inherits(OptClass, _ConstructType2);\n\n  var _super14 = _createSuper(OptClass);\n\n  function OptClass(_type) {\n    var _this8;\n\n    _classCallCheck(this, OptClass);\n\n    _this8 = _super14.call(this);\n    _this8._type = _type;\n    return _this8;\n  }\n\n  _createClass(OptClass, [{\n    key: \"accept\",\n    value: function accept(v, d) {\n      return v.visitOpt(this, this._type, d);\n    }\n  }, {\n    key: \"covariant\",\n    value: function covariant(x) {\n      return Array.isArray(x) && (x.length === 0 || x.length === 1 && this._type.covariant(x[0]));\n    }\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue(x) {\n      if (x.length === 0) {\n        return new Uint8Array([0]);\n      } else {\n        return concat(new Uint8Array([1]), this._type.encodeValue(x[0]));\n      }\n    }\n  }, {\n    key: \"_buildTypeTableImpl\",\n    value: function _buildTypeTableImpl(typeTable) {\n      this._type.buildTypeTable(typeTable);\n\n      var opCode = slebEncode(-18\n      /* Opt */\n      );\n\n      var buffer = this._type.encodeType(typeTable);\n\n      typeTable.add(this, concat(opCode, buffer));\n    }\n  }, {\n    key: \"decodeValue\",\n    value: function decodeValue(b, t) {\n      var opt = this.checkType(t);\n\n      if (!(opt instanceof OptClass)) {\n        throw new Error('Not an option type');\n      }\n\n      switch (safeReadUint8(b)) {\n        case 0:\n          return [];\n\n        case 1:\n          return [this._type.decodeValue(b, opt._type)];\n\n        default:\n          throw new Error('Not an option value');\n      }\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return \"opt \".concat(this._type.name);\n    }\n  }, {\n    key: \"display\",\n    value: function display() {\n      return \"opt \".concat(this._type.display());\n    }\n  }, {\n    key: \"valueToString\",\n    value: function valueToString(x) {\n      if (x.length === 0) {\n        return 'null';\n      } else {\n        return \"opt \".concat(this._type.valueToString(x[0]));\n      }\n    }\n  }]);\n\n  return OptClass;\n}(ConstructType);\n/**\n * Represents an IDL Record\n * @param {Object} [fields] - mapping of function name to Type\n */\n\nexport var RecordClass = /*#__PURE__*/function (_ConstructType3) {\n  _inherits(RecordClass, _ConstructType3);\n\n  var _super15 = _createSuper(RecordClass);\n\n  function RecordClass() {\n    var _this9;\n\n    var fields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, RecordClass);\n\n    _this9 = _super15.call(this);\n    _this9._fields = Object.entries(fields).sort(function (a, b) {\n      return idlLabelToId(a[0]) - idlLabelToId(b[0]);\n    });\n    return _this9;\n  }\n\n  _createClass(RecordClass, [{\n    key: \"accept\",\n    value: function accept(v, d) {\n      return v.visitRecord(this, this._fields, d);\n    }\n  }, {\n    key: \"tryAsTuple\",\n    value: function tryAsTuple() {\n      var res = [];\n\n      for (var i = 0; i < this._fields.length; i++) {\n        var _this$_fields$i = _slicedToArray(this._fields[i], 2),\n            key = _this$_fields$i[0],\n            type = _this$_fields$i[1];\n\n        if (key !== \"_\".concat(i, \"_\")) {\n          return null;\n        }\n\n        res.push(type);\n      }\n\n      return res;\n    }\n  }, {\n    key: \"covariant\",\n    value: function covariant(x) {\n      return typeof x === 'object' && this._fields.every(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            k = _ref2[0],\n            t = _ref2[1];\n\n        // eslint-disable-next-line\n        if (!x.hasOwnProperty(k)) {\n          throw new Error(\"Record is missing key \\\"\".concat(k, \"\\\".\"));\n        }\n\n        return t.covariant(x[k]);\n      });\n    }\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue(x) {\n      var values = this._fields.map(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 1),\n            key = _ref4[0];\n\n        return x[key];\n      });\n\n      var bufs = zipWith(this._fields, values, function (_ref5, d) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            c = _ref6[1];\n\n        return c.encodeValue(d);\n      });\n      return concat.apply(void 0, _toConsumableArray(bufs));\n    }\n  }, {\n    key: \"_buildTypeTableImpl\",\n    value: function _buildTypeTableImpl(T) {\n      this._fields.forEach(function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 2),\n            _ = _ref8[0],\n            value = _ref8[1];\n\n        return value.buildTypeTable(T);\n      });\n\n      var opCode = slebEncode(-20\n      /* Record */\n      );\n      var len = lebEncode(this._fields.length);\n\n      var fields = this._fields.map(function (_ref9) {\n        var _ref10 = _slicedToArray(_ref9, 2),\n            key = _ref10[0],\n            value = _ref10[1];\n\n        return concat(lebEncode(idlLabelToId(key)), value.encodeType(T));\n      });\n\n      T.add(this, concat(opCode, len, concat.apply(void 0, _toConsumableArray(fields))));\n    }\n  }, {\n    key: \"decodeValue\",\n    value: function decodeValue(b, t) {\n      var record = this.checkType(t);\n\n      if (!(record instanceof RecordClass)) {\n        throw new Error('Not a record type');\n      }\n\n      var x = {};\n      var idx = 0;\n\n      var _iterator = _createForOfIteratorHelper(record._fields),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              hash = _step$value[0],\n              type = _step$value[1];\n\n          if (idx >= this._fields.length || idlLabelToId(this._fields[idx][0]) !== idlLabelToId(hash)) {\n            // skip field\n            type.decodeValue(b, type);\n            continue;\n          }\n\n          var _this$_fields$idx = _slicedToArray(this._fields[idx], 2),\n              expectKey = _this$_fields$idx[0],\n              expectType = _this$_fields$idx[1];\n\n          x[expectKey] = expectType.decodeValue(b, type);\n          idx++;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (idx < this._fields.length) {\n        throw new Error('Cannot find field ' + this._fields[idx][0]);\n      }\n\n      return x;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      var fields = this._fields.map(function (_ref11) {\n        var _ref12 = _slicedToArray(_ref11, 2),\n            key = _ref12[0],\n            value = _ref12[1];\n\n        return key + ':' + value.name;\n      });\n\n      return \"record {\".concat(fields.join('; '), \"}\");\n    }\n  }, {\n    key: \"display\",\n    value: function display() {\n      var fields = this._fields.map(function (_ref13) {\n        var _ref14 = _slicedToArray(_ref13, 2),\n            key = _ref14[0],\n            value = _ref14[1];\n\n        return key + ':' + value.display();\n      });\n\n      return \"record {\".concat(fields.join('; '), \"}\");\n    }\n  }, {\n    key: \"valueToString\",\n    value: function valueToString(x) {\n      var values = this._fields.map(function (_ref15) {\n        var _ref16 = _slicedToArray(_ref15, 1),\n            key = _ref16[0];\n\n        return x[key];\n      });\n\n      var fields = zipWith(this._fields, values, function (_ref17, d) {\n        var _ref18 = _slicedToArray(_ref17, 2),\n            k = _ref18[0],\n            c = _ref18[1];\n\n        return k + '=' + c.valueToString(d);\n      });\n      return \"record {\".concat(fields.join('; '), \"}\");\n    }\n  }]);\n\n  return RecordClass;\n}(ConstructType);\n/**\n * Represents Tuple, a syntactic sugar for Record.\n * @param {Type} components\n */\n\nexport var TupleClass = /*#__PURE__*/function (_RecordClass) {\n  _inherits(TupleClass, _RecordClass);\n\n  var _super16 = _createSuper(TupleClass);\n\n  function TupleClass(_components) {\n    var _this10;\n\n    _classCallCheck(this, TupleClass);\n\n    var x = {};\n\n    _components.forEach(function (e, i) {\n      return x['_' + i + '_'] = e;\n    });\n\n    _this10 = _super16.call(this, x);\n    _this10._components = _components;\n    return _this10;\n  }\n\n  _createClass(TupleClass, [{\n    key: \"accept\",\n    value: function accept(v, d) {\n      return v.visitTuple(this, this._components, d);\n    }\n  }, {\n    key: \"covariant\",\n    value: function covariant(x) {\n      // `>=` because tuples can be covariant when encoded.\n      return Array.isArray(x) && x.length >= this._fields.length && this._components.every(function (t, i) {\n        return t.covariant(x[i]);\n      });\n    }\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue(x) {\n      var bufs = zipWith(this._components, x, function (c, d) {\n        return c.encodeValue(d);\n      });\n      return concat.apply(void 0, _toConsumableArray(bufs));\n    }\n  }, {\n    key: \"decodeValue\",\n    value: function decodeValue(b, t) {\n      var tuple = this.checkType(t);\n\n      if (!(tuple instanceof TupleClass)) {\n        throw new Error('not a tuple type');\n      }\n\n      if (tuple._components.length < this._components.length) {\n        throw new Error('tuple mismatch');\n      }\n\n      var res = [];\n\n      var _iterator2 = _createForOfIteratorHelper(tuple._components.entries()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n              i = _step2$value[0],\n              wireType = _step2$value[1];\n\n          if (i >= this._components.length) {\n            // skip value\n            wireType.decodeValue(b, wireType);\n          } else {\n            res.push(this._components[i].decodeValue(b, wireType));\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return res;\n    }\n  }, {\n    key: \"display\",\n    value: function display() {\n      var fields = this._components.map(function (value) {\n        return value.display();\n      });\n\n      return \"record {\".concat(fields.join('; '), \"}\");\n    }\n  }, {\n    key: \"valueToString\",\n    value: function valueToString(values) {\n      var fields = zipWith(this._components, values, function (c, d) {\n        return c.valueToString(d);\n      });\n      return \"record {\".concat(fields.join('; '), \"}\");\n    }\n  }]);\n\n  return TupleClass;\n}(RecordClass);\n/**\n * Represents an IDL Variant\n * @param {Object} [fields] - mapping of function name to Type\n */\n\nexport var VariantClass = /*#__PURE__*/function (_ConstructType4) {\n  _inherits(VariantClass, _ConstructType4);\n\n  var _super17 = _createSuper(VariantClass);\n\n  function VariantClass() {\n    var _this11;\n\n    var fields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, VariantClass);\n\n    _this11 = _super17.call(this);\n    _this11._fields = Object.entries(fields).sort(function (a, b) {\n      return idlLabelToId(a[0]) - idlLabelToId(b[0]);\n    });\n    return _this11;\n  }\n\n  _createClass(VariantClass, [{\n    key: \"accept\",\n    value: function accept(v, d) {\n      return v.visitVariant(this, this._fields, d);\n    }\n  }, {\n    key: \"covariant\",\n    value: function covariant(x) {\n      return typeof x === 'object' && Object.entries(x).length === 1 && this._fields.every(function (_ref19) {\n        var _ref20 = _slicedToArray(_ref19, 2),\n            k = _ref20[0],\n            v = _ref20[1];\n\n        // eslint-disable-next-line\n        return !x.hasOwnProperty(k) || v.covariant(x[k]);\n      });\n    }\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue(x) {\n      for (var i = 0; i < this._fields.length; i++) {\n        var _this$_fields$i2 = _slicedToArray(this._fields[i], 2),\n            name = _this$_fields$i2[0],\n            type = _this$_fields$i2[1]; // eslint-disable-next-line\n\n\n        if (x.hasOwnProperty(name)) {\n          var idx = lebEncode(i);\n          var buf = type.encodeValue(x[name]);\n          return concat(idx, buf);\n        }\n      }\n\n      throw Error('Variant has no data: ' + x);\n    }\n  }, {\n    key: \"_buildTypeTableImpl\",\n    value: function _buildTypeTableImpl(typeTable) {\n      this._fields.forEach(function (_ref21) {\n        var _ref22 = _slicedToArray(_ref21, 2),\n            type = _ref22[1];\n\n        type.buildTypeTable(typeTable);\n      });\n\n      var opCode = slebEncode(-21\n      /* Variant */\n      );\n      var len = lebEncode(this._fields.length);\n\n      var fields = this._fields.map(function (_ref23) {\n        var _ref24 = _slicedToArray(_ref23, 2),\n            key = _ref24[0],\n            value = _ref24[1];\n\n        return concat(lebEncode(idlLabelToId(key)), value.encodeType(typeTable));\n      });\n\n      typeTable.add(this, concat.apply(void 0, [opCode, len].concat(_toConsumableArray(fields))));\n    }\n  }, {\n    key: \"decodeValue\",\n    value: function decodeValue(b, t) {\n      var variant = this.checkType(t);\n\n      if (!(variant instanceof VariantClass)) {\n        throw new Error('Not a variant type');\n      }\n\n      var idx = Number(lebDecode(b));\n\n      if (idx >= variant._fields.length) {\n        throw Error('Invalid variant index: ' + idx);\n      }\n\n      var _variant$_fields$idx = _slicedToArray(variant._fields[idx], 2),\n          wireHash = _variant$_fields$idx[0],\n          wireType = _variant$_fields$idx[1];\n\n      var _iterator3 = _createForOfIteratorHelper(this._fields),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _step3$value = _slicedToArray(_step3.value, 2),\n              key = _step3$value[0],\n              expectType = _step3$value[1];\n\n          if (idlLabelToId(wireHash) === idlLabelToId(key)) {\n            var value = expectType.decodeValue(b, wireType);\n            return _defineProperty({}, key, value);\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      throw new Error('Cannot find field hash ' + wireHash);\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      var fields = this._fields.map(function (_ref26) {\n        var _ref27 = _slicedToArray(_ref26, 2),\n            key = _ref27[0],\n            type = _ref27[1];\n\n        return key + ':' + type.name;\n      });\n\n      return \"variant {\".concat(fields.join('; '), \"}\");\n    }\n  }, {\n    key: \"display\",\n    value: function display() {\n      var fields = this._fields.map(function (_ref28) {\n        var _ref29 = _slicedToArray(_ref28, 2),\n            key = _ref29[0],\n            type = _ref29[1];\n\n        return key + (type.name === 'null' ? '' : \":\".concat(type.display()));\n      });\n\n      return \"variant {\".concat(fields.join('; '), \"}\");\n    }\n  }, {\n    key: \"valueToString\",\n    value: function valueToString(x) {\n      var _iterator4 = _createForOfIteratorHelper(this._fields),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _step4$value = _slicedToArray(_step4.value, 2),\n              name = _step4$value[0],\n              type = _step4$value[1];\n\n          // eslint-disable-next-line\n          if (x.hasOwnProperty(name)) {\n            var value = type.valueToString(x[name]);\n\n            if (value === 'null') {\n              return \"variant {\".concat(name, \"}\");\n            } else {\n              return \"variant {\".concat(name, \"=\").concat(value, \"}\");\n            }\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      throw new Error('Variant has no data: ' + x);\n    }\n  }]);\n\n  return VariantClass;\n}(ConstructType);\n/**\n * Represents a reference to an IDL type, used for defining recursive data\n * types.\n */\n\nexport var RecClass = /*#__PURE__*/function (_ConstructType5) {\n  _inherits(RecClass, _ConstructType5);\n\n  var _super18 = _createSuper(RecClass);\n\n  function RecClass() {\n    var _this12;\n\n    _classCallCheck(this, RecClass);\n\n    _this12 = _super18.apply(this, arguments);\n    _this12._id = RecClass._counter++;\n    _this12._type = undefined;\n    return _this12;\n  }\n\n  _createClass(RecClass, [{\n    key: \"accept\",\n    value: function accept(v, d) {\n      if (!this._type) {\n        throw Error('Recursive type uninitialized.');\n      }\n\n      return v.visitRec(this, this._type, d);\n    }\n  }, {\n    key: \"fill\",\n    value: function fill(t) {\n      this._type = t;\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return this._type;\n    }\n  }, {\n    key: \"covariant\",\n    value: function covariant(x) {\n      return this._type ? this._type.covariant(x) : false;\n    }\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue(x) {\n      if (!this._type) {\n        throw Error('Recursive type uninitialized.');\n      }\n\n      return this._type.encodeValue(x);\n    }\n  }, {\n    key: \"_buildTypeTableImpl\",\n    value: function _buildTypeTableImpl(typeTable) {\n      if (!this._type) {\n        throw Error('Recursive type uninitialized.');\n      }\n\n      typeTable.add(this, new Uint8Array([]));\n\n      this._type.buildTypeTable(typeTable);\n\n      typeTable.merge(this, this._type.name);\n    }\n  }, {\n    key: \"decodeValue\",\n    value: function decodeValue(b, t) {\n      if (!this._type) {\n        throw Error('Recursive type uninitialized.');\n      }\n\n      return this._type.decodeValue(b, t);\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return \"rec_\".concat(this._id);\n    }\n  }, {\n    key: \"display\",\n    value: function display() {\n      if (!this._type) {\n        throw Error('Recursive type uninitialized.');\n      }\n\n      return \"\\u03BC\".concat(this.name, \".\").concat(this._type.name);\n    }\n  }, {\n    key: \"valueToString\",\n    value: function valueToString(x) {\n      if (!this._type) {\n        throw Error('Recursive type uninitialized.');\n      }\n\n      return this._type.valueToString(x);\n    }\n  }]);\n\n  return RecClass;\n}(ConstructType);\nRecClass._counter = 0;\n\nfunction decodePrincipalId(b) {\n  var x = safeReadUint8(b);\n\n  if (x !== 1) {\n    throw new Error('Cannot decode principal');\n  }\n\n  var len = Number(lebDecode(b));\n  return PrincipalId.fromUint8Array(new Uint8Array(safeRead(b, len)));\n}\n/**\n * Represents an IDL principal reference\n */\n\n\nexport var PrincipalClass = /*#__PURE__*/function (_PrimitiveType11) {\n  _inherits(PrincipalClass, _PrimitiveType11);\n\n  var _super19 = _createSuper(PrincipalClass);\n\n  function PrincipalClass() {\n    _classCallCheck(this, PrincipalClass);\n\n    return _super19.apply(this, arguments);\n  }\n\n  _createClass(PrincipalClass, [{\n    key: \"accept\",\n    value: function accept(v, d) {\n      return v.visitPrincipal(this, d);\n    }\n  }, {\n    key: \"covariant\",\n    value: function covariant(x) {\n      return x && x._isPrincipal;\n    }\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue(x) {\n      var buf = x.toUint8Array();\n      var len = lebEncode(buf.byteLength);\n      return concat(new Uint8Array([1]), len, buf);\n    }\n  }, {\n    key: \"encodeType\",\n    value: function encodeType() {\n      return slebEncode(-24\n      /* Principal */\n      );\n    }\n  }, {\n    key: \"decodeValue\",\n    value: function decodeValue(b, t) {\n      this.checkType(t);\n      return decodePrincipalId(b);\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return 'principal';\n    }\n  }, {\n    key: \"valueToString\",\n    value: function valueToString(x) {\n      return \"\".concat(this.name, \" \\\"\").concat(x.toText(), \"\\\"\");\n    }\n  }]);\n\n  return PrincipalClass;\n}(PrimitiveType);\n/**\n * Represents an IDL function reference.\n * @param argTypes Argument types.\n * @param retTypes Return types.\n * @param annotations Function annotations.\n */\n\nexport var FuncClass = /*#__PURE__*/function (_ConstructType6) {\n  _inherits(FuncClass, _ConstructType6);\n\n  var _super20 = _createSuper(FuncClass);\n\n  function FuncClass(argTypes, retTypes) {\n    var _this13;\n\n    var annotations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    _classCallCheck(this, FuncClass);\n\n    _this13 = _super20.call(this);\n    _this13.argTypes = argTypes;\n    _this13.retTypes = retTypes;\n    _this13.annotations = annotations;\n    return _this13;\n  }\n\n  _createClass(FuncClass, [{\n    key: \"accept\",\n    value: function accept(v, d) {\n      return v.visitFunc(this, d);\n    }\n  }, {\n    key: \"covariant\",\n    value: function covariant(x) {\n      return Array.isArray(x) && x.length === 2 && x[0] && x[0]._isPrincipal && typeof x[1] === 'string';\n    }\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue(_ref30) {\n      var _ref31 = _slicedToArray(_ref30, 2),\n          principal = _ref31[0],\n          methodName = _ref31[1];\n\n      var buf = principal.toUint8Array();\n      var len = lebEncode(buf.byteLength);\n      var canister = concat(new Uint8Array([1]), len, buf);\n      var method = new TextEncoder().encode(methodName);\n      var methodLen = lebEncode(method.byteLength);\n      return concat(new Uint8Array([1]), canister, methodLen, method);\n    }\n  }, {\n    key: \"_buildTypeTableImpl\",\n    value: function _buildTypeTableImpl(T) {\n      var _this14 = this;\n\n      this.argTypes.forEach(function (arg) {\n        return arg.buildTypeTable(T);\n      });\n      this.retTypes.forEach(function (arg) {\n        return arg.buildTypeTable(T);\n      });\n      var opCode = slebEncode(-22\n      /* Func */\n      );\n      var argLen = lebEncode(this.argTypes.length);\n      var args = concat.apply(void 0, _toConsumableArray(this.argTypes.map(function (arg) {\n        return arg.encodeType(T);\n      })));\n      var retLen = lebEncode(this.retTypes.length);\n      var rets = concat.apply(void 0, _toConsumableArray(this.retTypes.map(function (arg) {\n        return arg.encodeType(T);\n      })));\n      var annLen = lebEncode(this.annotations.length);\n      var anns = concat.apply(void 0, _toConsumableArray(this.annotations.map(function (a) {\n        return _this14.encodeAnnotation(a);\n      })));\n      T.add(this, concat(opCode, argLen, args, retLen, rets, annLen, anns));\n    }\n  }, {\n    key: \"decodeValue\",\n    value: function decodeValue(b) {\n      var x = safeReadUint8(b);\n\n      if (x !== 1) {\n        throw new Error('Cannot decode function reference');\n      }\n\n      var canister = decodePrincipalId(b);\n      var mLen = Number(lebDecode(b));\n      var buf = safeRead(b, mLen);\n      var decoder = new TextDecoder('utf8', {\n        fatal: true\n      });\n      var method = decoder.decode(buf);\n      return [canister, method];\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      var args = this.argTypes.map(function (arg) {\n        return arg.name;\n      }).join(', ');\n      var rets = this.retTypes.map(function (arg) {\n        return arg.name;\n      }).join(', ');\n      var annon = ' ' + this.annotations.join(' ');\n      return \"(\".concat(args, \") -> (\").concat(rets, \")\").concat(annon);\n    }\n  }, {\n    key: \"valueToString\",\n    value: function valueToString(_ref32) {\n      var _ref33 = _slicedToArray(_ref32, 2),\n          principal = _ref33[0],\n          str = _ref33[1];\n\n      return \"func \\\"\".concat(principal.toText(), \"\\\".\").concat(str);\n    }\n  }, {\n    key: \"display\",\n    value: function display() {\n      var args = this.argTypes.map(function (arg) {\n        return arg.display();\n      }).join(', ');\n      var rets = this.retTypes.map(function (arg) {\n        return arg.display();\n      }).join(', ');\n      var annon = ' ' + this.annotations.join(' ');\n      return \"(\".concat(args, \") \\u2192 (\").concat(rets, \")\").concat(annon);\n    }\n  }, {\n    key: \"encodeAnnotation\",\n    value: function encodeAnnotation(ann) {\n      if (ann === 'query') {\n        return new Uint8Array([1]);\n      } else if (ann === 'oneway') {\n        return new Uint8Array([2]);\n      } else {\n        throw new Error('Illeagal function annotation');\n      }\n    }\n  }], [{\n    key: \"argsToString\",\n    value: function argsToString(types, v) {\n      if (types.length !== v.length) {\n        throw new Error('arity mismatch');\n      }\n\n      return '(' + types.map(function (t, i) {\n        return t.valueToString(v[i]);\n      }).join(', ') + ')';\n    }\n  }]);\n\n  return FuncClass;\n}(ConstructType);\nexport var ServiceClass = /*#__PURE__*/function (_ConstructType7) {\n  _inherits(ServiceClass, _ConstructType7);\n\n  var _super21 = _createSuper(ServiceClass);\n\n  function ServiceClass(fields) {\n    var _this15;\n\n    _classCallCheck(this, ServiceClass);\n\n    _this15 = _super21.call(this);\n    _this15._fields = Object.entries(fields).sort(function (a, b) {\n      return idlLabelToId(a[0]) - idlLabelToId(b[0]);\n    });\n    return _this15;\n  }\n\n  _createClass(ServiceClass, [{\n    key: \"accept\",\n    value: function accept(v, d) {\n      return v.visitService(this, d);\n    }\n  }, {\n    key: \"covariant\",\n    value: function covariant(x) {\n      return x && x._isPrincipal;\n    }\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue(x) {\n      var buf = x.toUint8Array();\n      var len = lebEncode(buf.length);\n      return concat(new Uint8Array([1]), len, buf);\n    }\n  }, {\n    key: \"_buildTypeTableImpl\",\n    value: function _buildTypeTableImpl(T) {\n      this._fields.forEach(function (_ref34) {\n        var _ref35 = _slicedToArray(_ref34, 2),\n            _ = _ref35[0],\n            func = _ref35[1];\n\n        return func.buildTypeTable(T);\n      });\n\n      var opCode = slebEncode(-23\n      /* Service */\n      );\n      var len = lebEncode(this._fields.length);\n\n      var meths = this._fields.map(function (_ref36) {\n        var _ref37 = _slicedToArray(_ref36, 2),\n            label = _ref37[0],\n            func = _ref37[1];\n\n        var labelBuf = new TextEncoder().encode(label);\n        var labelLen = lebEncode(labelBuf.length);\n        return concat(labelLen, labelBuf, func.encodeType(T));\n      });\n\n      T.add(this, concat.apply(void 0, [opCode, len].concat(_toConsumableArray(meths))));\n    }\n  }, {\n    key: \"decodeValue\",\n    value: function decodeValue(b) {\n      return decodePrincipalId(b);\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      var fields = this._fields.map(function (_ref38) {\n        var _ref39 = _slicedToArray(_ref38, 2),\n            key = _ref39[0],\n            value = _ref39[1];\n\n        return key + ':' + value.name;\n      });\n\n      return \"service {\".concat(fields.join('; '), \"}\");\n    }\n  }, {\n    key: \"valueToString\",\n    value: function valueToString(x) {\n      return \"service \\\"\".concat(x.toText(), \"\\\"\");\n    }\n  }]);\n\n  return ServiceClass;\n}(ConstructType);\n/**\n *\n * @param x\n * @returns {string}\n */\n\nfunction toReadableString(x) {\n  return JSON.stringify(x, function (_key, value) {\n    return typeof value === 'bigint' ? \"BigInt(\".concat(value, \")\") : value;\n  });\n}\n/**\n * Encode a array of values\n * @param argTypes\n * @param args\n * @returns {Buffer} serialised value\n */\n\n\nexport function encode(argTypes, args) {\n  if (args.length < argTypes.length) {\n    throw Error('Wrong number of message arguments');\n  }\n\n  var typeTable = new TypeTable();\n  argTypes.forEach(function (t) {\n    return t.buildTypeTable(typeTable);\n  });\n  var magic = new TextEncoder().encode(magicNumber);\n  var table = typeTable.encode();\n  var len = lebEncode(args.length);\n  var typs = concat.apply(void 0, _toConsumableArray(argTypes.map(function (t) {\n    return t.encodeType(typeTable);\n  })));\n  var vals = concat.apply(void 0, _toConsumableArray(zipWith(argTypes, args, function (t, x) {\n    if (!t.covariant(x)) {\n      throw new Error(\"Invalid \".concat(t.display(), \" argument: \").concat(toReadableString(x)));\n    }\n\n    return t.encodeValue(x);\n  })));\n  return concat(magic, table, len, typs, vals);\n}\n/**\n * Decode a binary value\n * @param retTypes - Types expected in the buffer.\n * @param bytes - hex-encoded string, or buffer.\n * @returns Value deserialised to JS type\n */\n\nexport function decode(retTypes, bytes) {\n  var b = new Pipe(bytes);\n\n  if (bytes.byteLength < magicNumber.length) {\n    throw new Error('Message length smaller than magic number');\n  }\n\n  var magicBuffer = safeRead(b, magicNumber.length);\n  var magic = new TextDecoder().decode(magicBuffer);\n\n  if (magic !== magicNumber) {\n    throw new Error('Wrong magic number: ' + JSON.stringify(magic));\n  }\n\n  function readTypeTable(pipe) {\n    var typeTable = [];\n    var len = Number(lebDecode(pipe));\n\n    for (var i = 0; i < len; i++) {\n      var ty = Number(slebDecode(pipe));\n\n      switch (ty) {\n        case -18\n        /* Opt */\n        :\n        case -19\n        /* Vector */\n        :\n          {\n            var t = Number(slebDecode(pipe));\n            typeTable.push([ty, t]);\n            break;\n          }\n\n        case -20\n        /* Record */\n        :\n        case -21\n        /* Variant */\n        :\n          {\n            var fields = [];\n            var objectLength = Number(lebDecode(pipe));\n            var prevHash = void 0;\n\n            while (objectLength--) {\n              var hash = Number(lebDecode(pipe));\n\n              if (hash >= Math.pow(2, 32)) {\n                throw new Error('field id out of 32-bit range');\n              }\n\n              if (typeof prevHash === 'number' && prevHash >= hash) {\n                throw new Error('field id collision or not sorted');\n              }\n\n              prevHash = hash;\n\n              var _t = Number(slebDecode(pipe));\n\n              fields.push([hash, _t]);\n            }\n\n            typeTable.push([ty, fields]);\n            break;\n          }\n\n        case -22\n        /* Func */\n        :\n          {\n            for (var k = 0; k < 2; k++) {\n              var funcLength = Number(lebDecode(pipe));\n\n              while (funcLength--) {\n                slebDecode(pipe);\n              }\n            }\n\n            var annLen = Number(lebDecode(pipe));\n            safeRead(pipe, annLen);\n            typeTable.push([ty, undefined]);\n            break;\n          }\n\n        case -23\n        /* Service */\n        :\n          {\n            var servLength = Number(lebDecode(pipe));\n\n            while (servLength--) {\n              var l = Number(lebDecode(pipe));\n              safeRead(pipe, l);\n              slebDecode(pipe);\n            }\n\n            typeTable.push([ty, undefined]);\n            break;\n          }\n\n        default:\n          throw new Error('Illegal op_code: ' + ty);\n      }\n    }\n\n    var rawList = [];\n    var length = Number(lebDecode(pipe));\n\n    for (var _i = 0; _i < length; _i++) {\n      rawList.push(Number(slebDecode(pipe)));\n    }\n\n    return [typeTable, rawList];\n  }\n\n  var _readTypeTable = readTypeTable(b),\n      _readTypeTable2 = _slicedToArray(_readTypeTable, 2),\n      rawTable = _readTypeTable2[0],\n      rawTypes = _readTypeTable2[1];\n\n  if (rawTypes.length < retTypes.length) {\n    throw new Error('Wrong number of return values');\n  }\n\n  var table = rawTable.map(function (_) {\n    return Rec();\n  });\n\n  function getType(t) {\n    if (t < -24) {\n      throw new Error('future value not supported');\n    }\n\n    if (t < 0) {\n      switch (t) {\n        case -1:\n          return Null;\n\n        case -2:\n          return Bool;\n\n        case -3:\n          return Nat;\n\n        case -4:\n          return Int;\n\n        case -5:\n          return Nat8;\n\n        case -6:\n          return Nat16;\n\n        case -7:\n          return Nat32;\n\n        case -8:\n          return Nat64;\n\n        case -9:\n          return Int8;\n\n        case -10:\n          return Int16;\n\n        case -11:\n          return Int32;\n\n        case -12:\n          return Int64;\n\n        case -13:\n          return Float32;\n\n        case -14:\n          return Float64;\n\n        case -15:\n          return Text;\n\n        case -16:\n          return Reserved;\n\n        case -17:\n          return Empty;\n\n        case -24:\n          return Principal;\n\n        default:\n          throw new Error('Illegal op_code: ' + t);\n      }\n    }\n\n    if (t >= rawTable.length) {\n      throw new Error('type index out of range');\n    }\n\n    return table[t];\n  }\n\n  function buildType(entry) {\n    switch (entry[0]) {\n      case -19\n      /* Vector */\n      :\n        {\n          var ty = getType(entry[1]);\n          return Vec(ty);\n        }\n\n      case -18\n      /* Opt */\n      :\n        {\n          var _ty = getType(entry[1]);\n\n          return Opt(_ty);\n        }\n\n      case -20\n      /* Record */\n      :\n        {\n          var fields = {};\n\n          var _iterator5 = _createForOfIteratorHelper(entry[1]),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _step5$value = _slicedToArray(_step5.value, 2),\n                  hash = _step5$value[0],\n                  _ty2 = _step5$value[1];\n\n              var name = \"_\".concat(hash, \"_\");\n              fields[name] = getType(_ty2);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n\n          var record = Record(fields);\n          var tuple = record.tryAsTuple();\n\n          if (Array.isArray(tuple)) {\n            return Tuple.apply(void 0, _toConsumableArray(tuple));\n          } else {\n            return record;\n          }\n        }\n\n      case -21\n      /* Variant */\n      :\n        {\n          var _fields = {};\n\n          var _iterator6 = _createForOfIteratorHelper(entry[1]),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var _step6$value = _slicedToArray(_step6.value, 2),\n                  _hash = _step6$value[0],\n                  _ty3 = _step6$value[1];\n\n              var _name = \"_\".concat(_hash, \"_\");\n\n              _fields[_name] = getType(_ty3);\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n\n          return Variant(_fields);\n        }\n\n      case -22\n      /* Func */\n      :\n        {\n          return Func([], [], []);\n        }\n\n      case -23\n      /* Service */\n      :\n        {\n          return Service({});\n        }\n\n      default:\n        throw new Error('Illegal op_code: ' + entry[0]);\n    }\n  }\n\n  rawTable.forEach(function (entry, i) {\n    var t = buildType(entry);\n    table[i].fill(t);\n  });\n  var types = rawTypes.map(function (t) {\n    return getType(t);\n  });\n  var output = retTypes.map(function (t, i) {\n    return t.decodeValue(b, types[i]);\n  }); // skip unused values\n\n  for (var ind = retTypes.length; ind < types.length; ind++) {\n    types[ind].decodeValue(b, types[ind]);\n  }\n\n  if (b.byteLength > 0) {\n    throw new Error('decode: Left-over bytes');\n  }\n\n  return output;\n} // Export Types instances.\n\nexport var Empty = new EmptyClass();\nexport var Reserved = new ReservedClass();\nexport var Bool = new BoolClass();\nexport var Null = new NullClass();\nexport var Text = new TextClass();\nexport var Int = new IntClass();\nexport var Nat = new NatClass();\nexport var Float32 = new FloatClass(32);\nexport var Float64 = new FloatClass(64);\nexport var Int8 = new FixedIntClass(8);\nexport var Int16 = new FixedIntClass(16);\nexport var Int32 = new FixedIntClass(32);\nexport var Int64 = new FixedIntClass(64);\nexport var Nat8 = new FixedNatClass(8);\nexport var Nat16 = new FixedNatClass(16);\nexport var Nat32 = new FixedNatClass(32);\nexport var Nat64 = new FixedNatClass(64);\nexport var Principal = new PrincipalClass();\n/**\n *\n * @param types array of any types\n * @returns TupleClass from those types\n */\n\nexport function Tuple() {\n  for (var _len = arguments.length, types = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n    types[_key2] = arguments[_key2];\n  }\n\n  return new TupleClass(types);\n}\n/**\n *\n * @param t IDL Type\n * @returns VecClass from that type\n */\n\nexport function Vec(t) {\n  return new VecClass(t);\n}\n/**\n *\n * @param t IDL Type\n * @returns OptClass of Type\n */\n\nexport function Opt(t) {\n  return new OptClass(t);\n}\n/**\n *\n * @param t Record of string and IDL Type\n * @returns RecordClass of string and Type\n */\n\nexport function Record(t) {\n  return new RecordClass(t);\n}\n/**\n *\n * @param fields Record of string and IDL Type\n * @returns VariantClass\n */\n\nexport function Variant(fields) {\n  return new VariantClass(fields);\n}\n/**\n *\n * @returns new RecClass\n */\n\nexport function Rec() {\n  return new RecClass();\n}\n/**\n *\n * @param args array of IDL Types\n * @param ret array of IDL Types\n * @param annotations array of strings, [] by default\n * @returns new FuncClass\n */\n\nexport function Func(args, ret) {\n  var annotations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  return new FuncClass(args, ret, annotations);\n}\n/**\n *\n * @param t Record of string and FuncClass\n * @returns ServiceClass\n */\n\nexport function Service(t) {\n  return new ServiceClass(t);\n}","map":{"version":3,"sources":["../../src/idl.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// tslint:disable:max-classes-per-file\nimport { Principal as PrincipalId } from '@dfinity/principal';\nimport { concat, PipeArrayBuffer as Pipe } from './utils/buffer';\nimport { idlLabelToId } from './utils/hash';\nimport { lebDecode, lebEncode, safeRead, safeReadUint8, slebDecode, slebEncode, } from './utils/leb128';\nimport { readIntLE, readUIntLE, writeIntLE, writeUIntLE } from './utils/leb128';\nconst magicNumber = 'DIDL';\nfunction zipWith(xs, ys, f) {\n    return xs.map((x, i) => f(x, ys[i]));\n}\n/**\n * An IDL Type Table, which precedes the data in the stream.\n */\nclass TypeTable {\n    constructor() {\n        // List of types. Needs to be an array as the index needs to be stable.\n        this._typs = [];\n        this._idx = new Map();\n    }\n    has(obj) {\n        return this._idx.has(obj.name);\n    }\n    add(type, buf) {\n        const idx = this._typs.length;\n        this._idx.set(type.name, idx);\n        this._typs.push(buf);\n    }\n    merge(obj, knot) {\n        const idx = this._idx.get(obj.name);\n        const knotIdx = this._idx.get(knot);\n        if (idx === undefined) {\n            throw new Error('Missing type index for ' + obj);\n        }\n        if (knotIdx === undefined) {\n            throw new Error('Missing type index for ' + knot);\n        }\n        this._typs[idx] = this._typs[knotIdx];\n        // Delete the type.\n        this._typs.splice(knotIdx, 1);\n        this._idx.delete(knot);\n    }\n    encode() {\n        const len = lebEncode(this._typs.length);\n        const buf = concat(...this._typs);\n        return concat(len, buf);\n    }\n    indexOf(typeName) {\n        if (!this._idx.has(typeName)) {\n            throw new Error('Missing type index for ' + typeName);\n        }\n        return slebEncode(this._idx.get(typeName) || 0);\n    }\n}\nexport class Visitor {\n    visitType(t, data) {\n        throw new Error('Not implemented');\n    }\n    visitPrimitive(t, data) {\n        return this.visitType(t, data);\n    }\n    visitEmpty(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitBool(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitNull(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitReserved(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitText(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitNumber(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitInt(t, data) {\n        return this.visitNumber(t, data);\n    }\n    visitNat(t, data) {\n        return this.visitNumber(t, data);\n    }\n    visitFloat(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitFixedInt(t, data) {\n        return this.visitNumber(t, data);\n    }\n    visitFixedNat(t, data) {\n        return this.visitNumber(t, data);\n    }\n    visitPrincipal(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitConstruct(t, data) {\n        return this.visitType(t, data);\n    }\n    visitVec(t, ty, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitOpt(t, ty, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitRecord(t, fields, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitTuple(t, components, data) {\n        const fields = components.map((ty, i) => [`_${i}_`, ty]);\n        return this.visitRecord(t, fields, data);\n    }\n    visitVariant(t, fields, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitRec(t, ty, data) {\n        return this.visitConstruct(ty, data);\n    }\n    visitFunc(t, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitService(t, data) {\n        return this.visitConstruct(t, data);\n    }\n}\n/**\n * Represents an IDL type.\n */\nexport class Type {\n    /* Display type name */\n    display() {\n        return this.name;\n    }\n    valueToString(x) {\n        return toReadableString(x);\n    }\n    /* Implement `T` in the IDL spec, only needed for non-primitive types */\n    buildTypeTable(typeTable) {\n        if (!typeTable.has(this)) {\n            this._buildTypeTableImpl(typeTable);\n        }\n    }\n}\nexport class PrimitiveType extends Type {\n    checkType(t) {\n        if (this.name !== t.name) {\n            throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n        }\n        return t;\n    }\n    _buildTypeTableImpl(typeTable) {\n        // No type table encoding for Primitive types.\n        return;\n    }\n}\nexport class ConstructType extends Type {\n    checkType(t) {\n        if (t instanceof RecClass) {\n            const ty = t.getType();\n            if (typeof ty === 'undefined') {\n                throw new Error('type mismatch with uninitialized type');\n            }\n            return ty;\n        }\n        throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n    }\n    encodeType(typeTable) {\n        return typeTable.indexOf(this.name);\n    }\n}\n/**\n * Represents an IDL Empty, a type which has no inhabitants.\n * Since no values exist for this type, it cannot be serialised or deserialised.\n * Result types like `Result<Text, Empty>` should always succeed.\n */\nexport class EmptyClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitEmpty(this, d);\n    }\n    covariant(x) {\n        return false;\n    }\n    encodeValue() {\n        throw new Error('Empty cannot appear as a function argument');\n    }\n    valueToString() {\n        throw new Error('Empty cannot appear as a value');\n    }\n    encodeType() {\n        return slebEncode(-17 /* Empty */);\n    }\n    decodeValue() {\n        throw new Error('Empty cannot appear as an output');\n    }\n    get name() {\n        return 'empty';\n    }\n}\n/**\n * Represents an IDL Bool\n */\nexport class BoolClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitBool(this, d);\n    }\n    covariant(x) {\n        return typeof x === 'boolean';\n    }\n    encodeValue(x) {\n        return new Uint8Array([x ? 1 : 0]);\n    }\n    encodeType() {\n        return slebEncode(-2 /* Bool */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        switch (safeReadUint8(b)) {\n            case 0:\n                return false;\n            case 1:\n                return true;\n            default:\n                throw new Error('Boolean value out of range');\n        }\n    }\n    get name() {\n        return 'bool';\n    }\n}\n/**\n * Represents an IDL Null\n */\nexport class NullClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitNull(this, d);\n    }\n    covariant(x) {\n        return x === null;\n    }\n    encodeValue() {\n        return new ArrayBuffer(0);\n    }\n    encodeType() {\n        return slebEncode(-1 /* Null */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        return null;\n    }\n    get name() {\n        return 'null';\n    }\n}\n/**\n * Represents an IDL Reserved\n */\nexport class ReservedClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitReserved(this, d);\n    }\n    covariant(x) {\n        return true;\n    }\n    encodeValue() {\n        return new ArrayBuffer(0);\n    }\n    encodeType() {\n        return slebEncode(-16 /* Reserved */);\n    }\n    decodeValue(b, t) {\n        if (t.name !== this.name) {\n            t.decodeValue(b, t);\n        }\n        return null;\n    }\n    get name() {\n        return 'reserved';\n    }\n}\n/**\n * Represents an IDL Text\n */\nexport class TextClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitText(this, d);\n    }\n    covariant(x) {\n        return typeof x === 'string';\n    }\n    encodeValue(x) {\n        const buf = new TextEncoder().encode(x);\n        const len = lebEncode(buf.byteLength);\n        return concat(len, buf);\n    }\n    encodeType() {\n        return slebEncode(-15 /* Text */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        const len = lebDecode(b);\n        const buf = safeRead(b, Number(len));\n        const decoder = new TextDecoder('utf8', { fatal: true });\n        return decoder.decode(buf);\n    }\n    get name() {\n        return 'text';\n    }\n    valueToString(x) {\n        return '\"' + x + '\"';\n    }\n}\n/**\n * Represents an IDL Int\n */\nexport class IntClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitInt(this, d);\n    }\n    covariant(x) {\n        // We allow encoding of JavaScript plain numbers.\n        // But we will always decode to bigint.\n        return typeof x === 'bigint' || Number.isInteger(x);\n    }\n    encodeValue(x) {\n        return slebEncode(x);\n    }\n    encodeType() {\n        return slebEncode(-4 /* Int */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        return slebDecode(b);\n    }\n    get name() {\n        return 'int';\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL Nat\n */\nexport class NatClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitNat(this, d);\n    }\n    covariant(x) {\n        // We allow encoding of JavaScript plain numbers.\n        // But we will always decode to bigint.\n        return (typeof x === 'bigint' && x >= BigInt(0)) || (Number.isInteger(x) && x >= 0);\n    }\n    encodeValue(x) {\n        return lebEncode(x);\n    }\n    encodeType() {\n        return slebEncode(-3 /* Nat */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        return lebDecode(b);\n    }\n    get name() {\n        return 'nat';\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL Float\n */\nexport class FloatClass extends PrimitiveType {\n    constructor(_bits) {\n        super();\n        this._bits = _bits;\n        if (_bits !== 32 && _bits !== 64) {\n            throw new Error('not a valid float type');\n        }\n    }\n    accept(v, d) {\n        return v.visitFloat(this, d);\n    }\n    covariant(x) {\n        return typeof x === 'number' || x instanceof Number;\n    }\n    encodeValue(x) {\n        const buf = new ArrayBuffer(this._bits / 8);\n        const view = new DataView(buf);\n        if (this._bits === 32) {\n            view.setFloat32(0, x, true);\n        }\n        else {\n            view.setFloat64(0, x, true);\n        }\n        return buf;\n    }\n    encodeType() {\n        const opcode = this._bits === 32 ? -13 /* Float32 */ : -14 /* Float64 */;\n        return slebEncode(opcode);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        const bytes = safeRead(b, this._bits / 8);\n        const view = new DataView(bytes);\n        if (this._bits === 32) {\n            return view.getFloat32(0, true);\n        }\n        else {\n            return view.getFloat64(0, true);\n        }\n    }\n    get name() {\n        return 'float' + this._bits;\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL fixed-width Int(n)\n */\nexport class FixedIntClass extends PrimitiveType {\n    constructor(_bits) {\n        super();\n        this._bits = _bits;\n    }\n    accept(v, d) {\n        return v.visitFixedInt(this, d);\n    }\n    covariant(x) {\n        const min = BigInt(2) ** BigInt(this._bits - 1) * BigInt(-1);\n        const max = BigInt(2) ** BigInt(this._bits - 1) - BigInt(1);\n        if (typeof x === 'bigint') {\n            return x >= min && x <= max;\n        }\n        else if (Number.isInteger(x)) {\n            const v = BigInt(x);\n            return v >= min && v <= max;\n        }\n        else {\n            return false;\n        }\n    }\n    encodeValue(x) {\n        return writeIntLE(x, this._bits / 8);\n    }\n    encodeType() {\n        const offset = Math.log2(this._bits) - 3;\n        return slebEncode(-9 - offset);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        const num = readIntLE(b, this._bits / 8);\n        if (this._bits <= 32) {\n            return Number(num);\n        }\n        else {\n            return num;\n        }\n    }\n    get name() {\n        return `int${this._bits}`;\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL fixed-width Nat(n)\n */\nexport class FixedNatClass extends PrimitiveType {\n    constructor(bits) {\n        super();\n        this.bits = bits;\n    }\n    accept(v, d) {\n        return v.visitFixedNat(this, d);\n    }\n    covariant(x) {\n        const max = BigInt(2) ** BigInt(this.bits);\n        if (typeof x === 'bigint' && x >= BigInt(0)) {\n            return x < max;\n        }\n        else if (Number.isInteger(x) && x >= 0) {\n            const v = BigInt(x);\n            return v < max;\n        }\n        else {\n            return false;\n        }\n    }\n    encodeValue(x) {\n        return writeUIntLE(x, this.bits / 8);\n    }\n    encodeType() {\n        const offset = Math.log2(this.bits) - 3;\n        return slebEncode(-5 - offset);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        const num = readUIntLE(b, this.bits / 8);\n        if (this.bits <= 32) {\n            return Number(num);\n        }\n        else {\n            return num;\n        }\n    }\n    get name() {\n        return `nat${this.bits}`;\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL Array\n * @param {Type} t\n */\nexport class VecClass extends ConstructType {\n    constructor(_type) {\n        super();\n        this._type = _type;\n        // If true, this vector is really a blob and we can just use memcpy.\n        this._blobOptimization = false;\n        if (_type instanceof FixedNatClass && _type.bits === 8) {\n            this._blobOptimization = true;\n        }\n    }\n    accept(v, d) {\n        return v.visitVec(this, this._type, d);\n    }\n    covariant(x) {\n        return Array.isArray(x) && x.every(v => this._type.covariant(v));\n    }\n    encodeValue(x) {\n        const len = lebEncode(x.length);\n        if (this._blobOptimization) {\n            return concat(len, new Uint8Array(x));\n        }\n        return concat(len, ...x.map(d => this._type.encodeValue(d)));\n    }\n    _buildTypeTableImpl(typeTable) {\n        this._type.buildTypeTable(typeTable);\n        const opCode = slebEncode(-19 /* Vector */);\n        const buffer = this._type.encodeType(typeTable);\n        typeTable.add(this, concat(opCode, buffer));\n    }\n    decodeValue(b, t) {\n        const vec = this.checkType(t);\n        if (!(vec instanceof VecClass)) {\n            throw new Error('Not a vector type');\n        }\n        const len = Number(lebDecode(b));\n        if (this._blobOptimization) {\n            return [...new Uint8Array(b.read(len))];\n        }\n        const rets = [];\n        for (let i = 0; i < len; i++) {\n            rets.push(this._type.decodeValue(b, vec._type));\n        }\n        return rets;\n    }\n    get name() {\n        return `vec ${this._type.name}`;\n    }\n    display() {\n        return `vec ${this._type.display()}`;\n    }\n    valueToString(x) {\n        const elements = x.map(e => this._type.valueToString(e));\n        return 'vec {' + elements.join('; ') + '}';\n    }\n}\n/**\n * Represents an IDL Option\n * @param {Type} t\n */\nexport class OptClass extends ConstructType {\n    constructor(_type) {\n        super();\n        this._type = _type;\n    }\n    accept(v, d) {\n        return v.visitOpt(this, this._type, d);\n    }\n    covariant(x) {\n        return Array.isArray(x) && (x.length === 0 || (x.length === 1 && this._type.covariant(x[0])));\n    }\n    encodeValue(x) {\n        if (x.length === 0) {\n            return new Uint8Array([0]);\n        }\n        else {\n            return concat(new Uint8Array([1]), this._type.encodeValue(x[0]));\n        }\n    }\n    _buildTypeTableImpl(typeTable) {\n        this._type.buildTypeTable(typeTable);\n        const opCode = slebEncode(-18 /* Opt */);\n        const buffer = this._type.encodeType(typeTable);\n        typeTable.add(this, concat(opCode, buffer));\n    }\n    decodeValue(b, t) {\n        const opt = this.checkType(t);\n        if (!(opt instanceof OptClass)) {\n            throw new Error('Not an option type');\n        }\n        switch (safeReadUint8(b)) {\n            case 0:\n                return [];\n            case 1:\n                return [this._type.decodeValue(b, opt._type)];\n            default:\n                throw new Error('Not an option value');\n        }\n    }\n    get name() {\n        return `opt ${this._type.name}`;\n    }\n    display() {\n        return `opt ${this._type.display()}`;\n    }\n    valueToString(x) {\n        if (x.length === 0) {\n            return 'null';\n        }\n        else {\n            return `opt ${this._type.valueToString(x[0])}`;\n        }\n    }\n}\n/**\n * Represents an IDL Record\n * @param {Object} [fields] - mapping of function name to Type\n */\nexport class RecordClass extends ConstructType {\n    constructor(fields = {}) {\n        super();\n        this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));\n    }\n    accept(v, d) {\n        return v.visitRecord(this, this._fields, d);\n    }\n    tryAsTuple() {\n        const res = [];\n        for (let i = 0; i < this._fields.length; i++) {\n            const [key, type] = this._fields[i];\n            if (key !== `_${i}_`) {\n                return null;\n            }\n            res.push(type);\n        }\n        return res;\n    }\n    covariant(x) {\n        return (typeof x === 'object' &&\n            this._fields.every(([k, t]) => {\n                // eslint-disable-next-line\n                if (!x.hasOwnProperty(k)) {\n                    throw new Error(`Record is missing key \"${k}\".`);\n                }\n                return t.covariant(x[k]);\n            }));\n    }\n    encodeValue(x) {\n        const values = this._fields.map(([key]) => x[key]);\n        const bufs = zipWith(this._fields, values, ([, c], d) => c.encodeValue(d));\n        return concat(...bufs);\n    }\n    _buildTypeTableImpl(T) {\n        this._fields.forEach(([_, value]) => value.buildTypeTable(T));\n        const opCode = slebEncode(-20 /* Record */);\n        const len = lebEncode(this._fields.length);\n        const fields = this._fields.map(([key, value]) => concat(lebEncode(idlLabelToId(key)), value.encodeType(T)));\n        T.add(this, concat(opCode, len, concat(...fields)));\n    }\n    decodeValue(b, t) {\n        const record = this.checkType(t);\n        if (!(record instanceof RecordClass)) {\n            throw new Error('Not a record type');\n        }\n        const x = {};\n        let idx = 0;\n        for (const [hash, type] of record._fields) {\n            if (idx >= this._fields.length || idlLabelToId(this._fields[idx][0]) !== idlLabelToId(hash)) {\n                // skip field\n                type.decodeValue(b, type);\n                continue;\n            }\n            const [expectKey, expectType] = this._fields[idx];\n            x[expectKey] = expectType.decodeValue(b, type);\n            idx++;\n        }\n        if (idx < this._fields.length) {\n            throw new Error('Cannot find field ' + this._fields[idx][0]);\n        }\n        return x;\n    }\n    get name() {\n        const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n        return `record {${fields.join('; ')}}`;\n    }\n    display() {\n        const fields = this._fields.map(([key, value]) => key + ':' + value.display());\n        return `record {${fields.join('; ')}}`;\n    }\n    valueToString(x) {\n        const values = this._fields.map(([key]) => x[key]);\n        const fields = zipWith(this._fields, values, ([k, c], d) => k + '=' + c.valueToString(d));\n        return `record {${fields.join('; ')}}`;\n    }\n}\n/**\n * Represents Tuple, a syntactic sugar for Record.\n * @param {Type} components\n */\nexport class TupleClass extends RecordClass {\n    constructor(_components) {\n        const x = {};\n        _components.forEach((e, i) => (x['_' + i + '_'] = e));\n        super(x);\n        this._components = _components;\n    }\n    accept(v, d) {\n        return v.visitTuple(this, this._components, d);\n    }\n    covariant(x) {\n        // `>=` because tuples can be covariant when encoded.\n        return (Array.isArray(x) &&\n            x.length >= this._fields.length &&\n            this._components.every((t, i) => t.covariant(x[i])));\n    }\n    encodeValue(x) {\n        const bufs = zipWith(this._components, x, (c, d) => c.encodeValue(d));\n        return concat(...bufs);\n    }\n    decodeValue(b, t) {\n        const tuple = this.checkType(t);\n        if (!(tuple instanceof TupleClass)) {\n            throw new Error('not a tuple type');\n        }\n        if (tuple._components.length < this._components.length) {\n            throw new Error('tuple mismatch');\n        }\n        const res = [];\n        for (const [i, wireType] of tuple._components.entries()) {\n            if (i >= this._components.length) {\n                // skip value\n                wireType.decodeValue(b, wireType);\n            }\n            else {\n                res.push(this._components[i].decodeValue(b, wireType));\n            }\n        }\n        return res;\n    }\n    display() {\n        const fields = this._components.map(value => value.display());\n        return `record {${fields.join('; ')}}`;\n    }\n    valueToString(values) {\n        const fields = zipWith(this._components, values, (c, d) => c.valueToString(d));\n        return `record {${fields.join('; ')}}`;\n    }\n}\n/**\n * Represents an IDL Variant\n * @param {Object} [fields] - mapping of function name to Type\n */\nexport class VariantClass extends ConstructType {\n    constructor(fields = {}) {\n        super();\n        this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));\n    }\n    accept(v, d) {\n        return v.visitVariant(this, this._fields, d);\n    }\n    covariant(x) {\n        return (typeof x === 'object' &&\n            Object.entries(x).length === 1 &&\n            this._fields.every(([k, v]) => {\n                // eslint-disable-next-line\n                return !x.hasOwnProperty(k) || v.covariant(x[k]);\n            }));\n    }\n    encodeValue(x) {\n        for (let i = 0; i < this._fields.length; i++) {\n            const [name, type] = this._fields[i];\n            // eslint-disable-next-line\n            if (x.hasOwnProperty(name)) {\n                const idx = lebEncode(i);\n                const buf = type.encodeValue(x[name]);\n                return concat(idx, buf);\n            }\n        }\n        throw Error('Variant has no data: ' + x);\n    }\n    _buildTypeTableImpl(typeTable) {\n        this._fields.forEach(([, type]) => {\n            type.buildTypeTable(typeTable);\n        });\n        const opCode = slebEncode(-21 /* Variant */);\n        const len = lebEncode(this._fields.length);\n        const fields = this._fields.map(([key, value]) => concat(lebEncode(idlLabelToId(key)), value.encodeType(typeTable)));\n        typeTable.add(this, concat(opCode, len, ...fields));\n    }\n    decodeValue(b, t) {\n        const variant = this.checkType(t);\n        if (!(variant instanceof VariantClass)) {\n            throw new Error('Not a variant type');\n        }\n        const idx = Number(lebDecode(b));\n        if (idx >= variant._fields.length) {\n            throw Error('Invalid variant index: ' + idx);\n        }\n        const [wireHash, wireType] = variant._fields[idx];\n        for (const [key, expectType] of this._fields) {\n            if (idlLabelToId(wireHash) === idlLabelToId(key)) {\n                const value = expectType.decodeValue(b, wireType);\n                return { [key]: value };\n            }\n        }\n        throw new Error('Cannot find field hash ' + wireHash);\n    }\n    get name() {\n        const fields = this._fields.map(([key, type]) => key + ':' + type.name);\n        return `variant {${fields.join('; ')}}`;\n    }\n    display() {\n        const fields = this._fields.map(([key, type]) => key + (type.name === 'null' ? '' : `:${type.display()}`));\n        return `variant {${fields.join('; ')}}`;\n    }\n    valueToString(x) {\n        for (const [name, type] of this._fields) {\n            // eslint-disable-next-line\n            if (x.hasOwnProperty(name)) {\n                const value = type.valueToString(x[name]);\n                if (value === 'null') {\n                    return `variant {${name}}`;\n                }\n                else {\n                    return `variant {${name}=${value}}`;\n                }\n            }\n        }\n        throw new Error('Variant has no data: ' + x);\n    }\n}\n/**\n * Represents a reference to an IDL type, used for defining recursive data\n * types.\n */\nexport class RecClass extends ConstructType {\n    constructor() {\n        super(...arguments);\n        this._id = RecClass._counter++;\n        this._type = undefined;\n    }\n    accept(v, d) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return v.visitRec(this, this._type, d);\n    }\n    fill(t) {\n        this._type = t;\n    }\n    getType() {\n        return this._type;\n    }\n    covariant(x) {\n        return this._type ? this._type.covariant(x) : false;\n    }\n    encodeValue(x) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return this._type.encodeValue(x);\n    }\n    _buildTypeTableImpl(typeTable) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        typeTable.add(this, new Uint8Array([]));\n        this._type.buildTypeTable(typeTable);\n        typeTable.merge(this, this._type.name);\n    }\n    decodeValue(b, t) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return this._type.decodeValue(b, t);\n    }\n    get name() {\n        return `rec_${this._id}`;\n    }\n    display() {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return `μ${this.name}.${this._type.name}`;\n    }\n    valueToString(x) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return this._type.valueToString(x);\n    }\n}\nRecClass._counter = 0;\nfunction decodePrincipalId(b) {\n    const x = safeReadUint8(b);\n    if (x !== 1) {\n        throw new Error('Cannot decode principal');\n    }\n    const len = Number(lebDecode(b));\n    return PrincipalId.fromUint8Array(new Uint8Array(safeRead(b, len)));\n}\n/**\n * Represents an IDL principal reference\n */\nexport class PrincipalClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitPrincipal(this, d);\n    }\n    covariant(x) {\n        return x && x._isPrincipal;\n    }\n    encodeValue(x) {\n        const buf = x.toUint8Array();\n        const len = lebEncode(buf.byteLength);\n        return concat(new Uint8Array([1]), len, buf);\n    }\n    encodeType() {\n        return slebEncode(-24 /* Principal */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        return decodePrincipalId(b);\n    }\n    get name() {\n        return 'principal';\n    }\n    valueToString(x) {\n        return `${this.name} \"${x.toText()}\"`;\n    }\n}\n/**\n * Represents an IDL function reference.\n * @param argTypes Argument types.\n * @param retTypes Return types.\n * @param annotations Function annotations.\n */\nexport class FuncClass extends ConstructType {\n    constructor(argTypes, retTypes, annotations = []) {\n        super();\n        this.argTypes = argTypes;\n        this.retTypes = retTypes;\n        this.annotations = annotations;\n    }\n    static argsToString(types, v) {\n        if (types.length !== v.length) {\n            throw new Error('arity mismatch');\n        }\n        return '(' + types.map((t, i) => t.valueToString(v[i])).join(', ') + ')';\n    }\n    accept(v, d) {\n        return v.visitFunc(this, d);\n    }\n    covariant(x) {\n        return (Array.isArray(x) && x.length === 2 && x[0] && x[0]._isPrincipal && typeof x[1] === 'string');\n    }\n    encodeValue([principal, methodName]) {\n        const buf = principal.toUint8Array();\n        const len = lebEncode(buf.byteLength);\n        const canister = concat(new Uint8Array([1]), len, buf);\n        const method = new TextEncoder().encode(methodName);\n        const methodLen = lebEncode(method.byteLength);\n        return concat(new Uint8Array([1]), canister, methodLen, method);\n    }\n    _buildTypeTableImpl(T) {\n        this.argTypes.forEach(arg => arg.buildTypeTable(T));\n        this.retTypes.forEach(arg => arg.buildTypeTable(T));\n        const opCode = slebEncode(-22 /* Func */);\n        const argLen = lebEncode(this.argTypes.length);\n        const args = concat(...this.argTypes.map(arg => arg.encodeType(T)));\n        const retLen = lebEncode(this.retTypes.length);\n        const rets = concat(...this.retTypes.map(arg => arg.encodeType(T)));\n        const annLen = lebEncode(this.annotations.length);\n        const anns = concat(...this.annotations.map(a => this.encodeAnnotation(a)));\n        T.add(this, concat(opCode, argLen, args, retLen, rets, annLen, anns));\n    }\n    decodeValue(b) {\n        const x = safeReadUint8(b);\n        if (x !== 1) {\n            throw new Error('Cannot decode function reference');\n        }\n        const canister = decodePrincipalId(b);\n        const mLen = Number(lebDecode(b));\n        const buf = safeRead(b, mLen);\n        const decoder = new TextDecoder('utf8', { fatal: true });\n        const method = decoder.decode(buf);\n        return [canister, method];\n    }\n    get name() {\n        const args = this.argTypes.map(arg => arg.name).join(', ');\n        const rets = this.retTypes.map(arg => arg.name).join(', ');\n        const annon = ' ' + this.annotations.join(' ');\n        return `(${args}) -> (${rets})${annon}`;\n    }\n    valueToString([principal, str]) {\n        return `func \"${principal.toText()}\".${str}`;\n    }\n    display() {\n        const args = this.argTypes.map(arg => arg.display()).join(', ');\n        const rets = this.retTypes.map(arg => arg.display()).join(', ');\n        const annon = ' ' + this.annotations.join(' ');\n        return `(${args}) → (${rets})${annon}`;\n    }\n    encodeAnnotation(ann) {\n        if (ann === 'query') {\n            return new Uint8Array([1]);\n        }\n        else if (ann === 'oneway') {\n            return new Uint8Array([2]);\n        }\n        else {\n            throw new Error('Illeagal function annotation');\n        }\n    }\n}\nexport class ServiceClass extends ConstructType {\n    constructor(fields) {\n        super();\n        this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));\n    }\n    accept(v, d) {\n        return v.visitService(this, d);\n    }\n    covariant(x) {\n        return x && x._isPrincipal;\n    }\n    encodeValue(x) {\n        const buf = x.toUint8Array();\n        const len = lebEncode(buf.length);\n        return concat(new Uint8Array([1]), len, buf);\n    }\n    _buildTypeTableImpl(T) {\n        this._fields.forEach(([_, func]) => func.buildTypeTable(T));\n        const opCode = slebEncode(-23 /* Service */);\n        const len = lebEncode(this._fields.length);\n        const meths = this._fields.map(([label, func]) => {\n            const labelBuf = new TextEncoder().encode(label);\n            const labelLen = lebEncode(labelBuf.length);\n            return concat(labelLen, labelBuf, func.encodeType(T));\n        });\n        T.add(this, concat(opCode, len, ...meths));\n    }\n    decodeValue(b) {\n        return decodePrincipalId(b);\n    }\n    get name() {\n        const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n        return `service {${fields.join('; ')}}`;\n    }\n    valueToString(x) {\n        return `service \"${x.toText()}\"`;\n    }\n}\n/**\n *\n * @param x\n * @returns {string}\n */\nfunction toReadableString(x) {\n    return JSON.stringify(x, (_key, value) => typeof value === 'bigint' ? `BigInt(${value})` : value);\n}\n/**\n * Encode a array of values\n * @param argTypes\n * @param args\n * @returns {Buffer} serialised value\n */\nexport function encode(argTypes, args) {\n    if (args.length < argTypes.length) {\n        throw Error('Wrong number of message arguments');\n    }\n    const typeTable = new TypeTable();\n    argTypes.forEach(t => t.buildTypeTable(typeTable));\n    const magic = new TextEncoder().encode(magicNumber);\n    const table = typeTable.encode();\n    const len = lebEncode(args.length);\n    const typs = concat(...argTypes.map(t => t.encodeType(typeTable)));\n    const vals = concat(...zipWith(argTypes, args, (t, x) => {\n        if (!t.covariant(x)) {\n            throw new Error(`Invalid ${t.display()} argument: ${toReadableString(x)}`);\n        }\n        return t.encodeValue(x);\n    }));\n    return concat(magic, table, len, typs, vals);\n}\n/**\n * Decode a binary value\n * @param retTypes - Types expected in the buffer.\n * @param bytes - hex-encoded string, or buffer.\n * @returns Value deserialised to JS type\n */\nexport function decode(retTypes, bytes) {\n    const b = new Pipe(bytes);\n    if (bytes.byteLength < magicNumber.length) {\n        throw new Error('Message length smaller than magic number');\n    }\n    const magicBuffer = safeRead(b, magicNumber.length);\n    const magic = new TextDecoder().decode(magicBuffer);\n    if (magic !== magicNumber) {\n        throw new Error('Wrong magic number: ' + JSON.stringify(magic));\n    }\n    function readTypeTable(pipe) {\n        const typeTable = [];\n        const len = Number(lebDecode(pipe));\n        for (let i = 0; i < len; i++) {\n            const ty = Number(slebDecode(pipe));\n            switch (ty) {\n                case -18 /* Opt */:\n                case -19 /* Vector */: {\n                    const t = Number(slebDecode(pipe));\n                    typeTable.push([ty, t]);\n                    break;\n                }\n                case -20 /* Record */:\n                case -21 /* Variant */: {\n                    const fields = [];\n                    let objectLength = Number(lebDecode(pipe));\n                    let prevHash;\n                    while (objectLength--) {\n                        const hash = Number(lebDecode(pipe));\n                        if (hash >= Math.pow(2, 32)) {\n                            throw new Error('field id out of 32-bit range');\n                        }\n                        if (typeof prevHash === 'number' && prevHash >= hash) {\n                            throw new Error('field id collision or not sorted');\n                        }\n                        prevHash = hash;\n                        const t = Number(slebDecode(pipe));\n                        fields.push([hash, t]);\n                    }\n                    typeTable.push([ty, fields]);\n                    break;\n                }\n                case -22 /* Func */: {\n                    for (let k = 0; k < 2; k++) {\n                        let funcLength = Number(lebDecode(pipe));\n                        while (funcLength--) {\n                            slebDecode(pipe);\n                        }\n                    }\n                    const annLen = Number(lebDecode(pipe));\n                    safeRead(pipe, annLen);\n                    typeTable.push([ty, undefined]);\n                    break;\n                }\n                case -23 /* Service */: {\n                    let servLength = Number(lebDecode(pipe));\n                    while (servLength--) {\n                        const l = Number(lebDecode(pipe));\n                        safeRead(pipe, l);\n                        slebDecode(pipe);\n                    }\n                    typeTable.push([ty, undefined]);\n                    break;\n                }\n                default:\n                    throw new Error('Illegal op_code: ' + ty);\n            }\n        }\n        const rawList = [];\n        const length = Number(lebDecode(pipe));\n        for (let i = 0; i < length; i++) {\n            rawList.push(Number(slebDecode(pipe)));\n        }\n        return [typeTable, rawList];\n    }\n    const [rawTable, rawTypes] = readTypeTable(b);\n    if (rawTypes.length < retTypes.length) {\n        throw new Error('Wrong number of return values');\n    }\n    const table = rawTable.map(_ => Rec());\n    function getType(t) {\n        if (t < -24) {\n            throw new Error('future value not supported');\n        }\n        if (t < 0) {\n            switch (t) {\n                case -1:\n                    return Null;\n                case -2:\n                    return Bool;\n                case -3:\n                    return Nat;\n                case -4:\n                    return Int;\n                case -5:\n                    return Nat8;\n                case -6:\n                    return Nat16;\n                case -7:\n                    return Nat32;\n                case -8:\n                    return Nat64;\n                case -9:\n                    return Int8;\n                case -10:\n                    return Int16;\n                case -11:\n                    return Int32;\n                case -12:\n                    return Int64;\n                case -13:\n                    return Float32;\n                case -14:\n                    return Float64;\n                case -15:\n                    return Text;\n                case -16:\n                    return Reserved;\n                case -17:\n                    return Empty;\n                case -24:\n                    return Principal;\n                default:\n                    throw new Error('Illegal op_code: ' + t);\n            }\n        }\n        if (t >= rawTable.length) {\n            throw new Error('type index out of range');\n        }\n        return table[t];\n    }\n    function buildType(entry) {\n        switch (entry[0]) {\n            case -19 /* Vector */: {\n                const ty = getType(entry[1]);\n                return Vec(ty);\n            }\n            case -18 /* Opt */: {\n                const ty = getType(entry[1]);\n                return Opt(ty);\n            }\n            case -20 /* Record */: {\n                const fields = {};\n                for (const [hash, ty] of entry[1]) {\n                    const name = `_${hash}_`;\n                    fields[name] = getType(ty);\n                }\n                const record = Record(fields);\n                const tuple = record.tryAsTuple();\n                if (Array.isArray(tuple)) {\n                    return Tuple(...tuple);\n                }\n                else {\n                    return record;\n                }\n            }\n            case -21 /* Variant */: {\n                const fields = {};\n                for (const [hash, ty] of entry[1]) {\n                    const name = `_${hash}_`;\n                    fields[name] = getType(ty);\n                }\n                return Variant(fields);\n            }\n            case -22 /* Func */: {\n                return Func([], [], []);\n            }\n            case -23 /* Service */: {\n                return Service({});\n            }\n            default:\n                throw new Error('Illegal op_code: ' + entry[0]);\n        }\n    }\n    rawTable.forEach((entry, i) => {\n        const t = buildType(entry);\n        table[i].fill(t);\n    });\n    const types = rawTypes.map(t => getType(t));\n    const output = retTypes.map((t, i) => {\n        return t.decodeValue(b, types[i]);\n    });\n    // skip unused values\n    for (let ind = retTypes.length; ind < types.length; ind++) {\n        types[ind].decodeValue(b, types[ind]);\n    }\n    if (b.byteLength > 0) {\n        throw new Error('decode: Left-over bytes');\n    }\n    return output;\n}\n// Export Types instances.\nexport const Empty = new EmptyClass();\nexport const Reserved = new ReservedClass();\nexport const Bool = new BoolClass();\nexport const Null = new NullClass();\nexport const Text = new TextClass();\nexport const Int = new IntClass();\nexport const Nat = new NatClass();\nexport const Float32 = new FloatClass(32);\nexport const Float64 = new FloatClass(64);\nexport const Int8 = new FixedIntClass(8);\nexport const Int16 = new FixedIntClass(16);\nexport const Int32 = new FixedIntClass(32);\nexport const Int64 = new FixedIntClass(64);\nexport const Nat8 = new FixedNatClass(8);\nexport const Nat16 = new FixedNatClass(16);\nexport const Nat32 = new FixedNatClass(32);\nexport const Nat64 = new FixedNatClass(64);\nexport const Principal = new PrincipalClass();\n/**\n *\n * @param types array of any types\n * @returns TupleClass from those types\n */\nexport function Tuple(...types) {\n    return new TupleClass(types);\n}\n/**\n *\n * @param t IDL Type\n * @returns VecClass from that type\n */\nexport function Vec(t) {\n    return new VecClass(t);\n}\n/**\n *\n * @param t IDL Type\n * @returns OptClass of Type\n */\nexport function Opt(t) {\n    return new OptClass(t);\n}\n/**\n *\n * @param t Record of string and IDL Type\n * @returns RecordClass of string and Type\n */\nexport function Record(t) {\n    return new RecordClass(t);\n}\n/**\n *\n * @param fields Record of string and IDL Type\n * @returns VariantClass\n */\nexport function Variant(fields) {\n    return new VariantClass(fields);\n}\n/**\n *\n * @returns new RecClass\n */\nexport function Rec() {\n    return new RecClass();\n}\n/**\n *\n * @param args array of IDL Types\n * @param ret array of IDL Types\n * @param annotations array of strings, [] by default\n * @returns new FuncClass\n */\nexport function Func(args, ret, annotations = []) {\n    return new FuncClass(args, ret, annotations);\n}\n/**\n *\n * @param t Record of string and FuncClass\n * @returns ServiceClass\n */\nexport function Service(t) {\n    return new ServiceClass(t);\n}\n//# sourceMappingURL=idl.js.map"]},"metadata":{},"sourceType":"module"}