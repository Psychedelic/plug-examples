{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _regeneratorRuntime from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _createClass from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _inherits from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { getDefaultAgent } from './agent';\nimport * as cbor from './cbor';\nimport { AgentError } from './errors';\nimport { hash } from './request_id';\nimport { blsVerify } from './utils/bls';\nimport { concat, fromHex, toHex } from './utils/buffer';\n/**\n * A certificate needs to be verified (using {@link Certificate.prototype.verify})\n * before it can be used.\n */\n\nexport var UnverifiedCertificateError = /*#__PURE__*/function (_AgentError) {\n  _inherits(UnverifiedCertificateError, _AgentError);\n\n  var _super = _createSuper(UnverifiedCertificateError);\n\n  function UnverifiedCertificateError() {\n    _classCallCheck(this, UnverifiedCertificateError);\n\n    return _super.call(this, \"Cannot lookup unverified certificate. Call 'verify()' first.\");\n  }\n\n  return UnverifiedCertificateError;\n}(AgentError);\n/**\n * Make a human readable string out of a hash tree.\n * @param tree\n */\n\nexport function hashTreeToString(tree) {\n  var indent = function indent(s) {\n    return s.split('\\n').map(function (x) {\n      return '  ' + x;\n    }).join('\\n');\n  };\n\n  function labelToString(label) {\n    var decoder = new TextDecoder(undefined, {\n      fatal: true\n    });\n\n    try {\n      return JSON.stringify(decoder.decode(label));\n    } catch (e) {\n      return \"data(...\".concat(label.byteLength, \" bytes)\");\n    }\n  }\n\n  switch (tree[0]) {\n    case 0\n    /* Empty */\n    :\n      return '()';\n\n    case 1\n    /* Fork */\n    :\n      {\n        var left = hashTreeToString(tree[1]);\n        var right = hashTreeToString(tree[2]);\n        return \"sub(\\n left:\\n\".concat(indent(left), \"\\n---\\n right:\\n\").concat(indent(right), \"\\n)\");\n      }\n\n    case 2\n    /* Labeled */\n    :\n      {\n        var label = labelToString(tree[1]);\n        var sub = hashTreeToString(tree[2]);\n        return \"label(\\n label:\\n\".concat(indent(label), \"\\n sub:\\n\").concat(indent(sub), \"\\n)\");\n      }\n\n    case 3\n    /* Leaf */\n    :\n      {\n        return \"leaf(...\".concat(tree[1].byteLength, \" bytes)\");\n      }\n\n    case 4\n    /* Pruned */\n    :\n      {\n        return \"pruned(\".concat(toHex(new Uint8Array(tree[1])));\n      }\n\n    default:\n      {\n        return \"unknown(\".concat(JSON.stringify(tree[0]), \")\");\n      }\n  }\n}\n\nfunction isBufferEqual(a, b) {\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n\n  var a8 = new Uint8Array(a);\n  var b8 = new Uint8Array(b);\n\n  for (var i = 0; i < a8.length; i++) {\n    if (a8[i] !== b8[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport var Certificate = /*#__PURE__*/function () {\n  function Certificate(response) {\n    var _agent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getDefaultAgent();\n\n    _classCallCheck(this, Certificate);\n\n    this._agent = _agent;\n    this.verified = false;\n    this._rootKey = null;\n    this.cert = cbor.decode(new Uint8Array(response.certificate));\n  }\n\n  _createClass(Certificate, [{\n    key: \"lookup\",\n    value: function lookup(path) {\n      this.checkState();\n      return lookup_path(path, this.cert.tree);\n    }\n  }, {\n    key: \"verify\",\n    value: function () {\n      var _verify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var rootHash, derKey, sig, key, msg, res;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return reconstruct(this.cert.tree);\n\n              case 2:\n                rootHash = _context.sent;\n                _context.next = 5;\n                return this._checkDelegation(this.cert.delegation);\n\n              case 5:\n                derKey = _context.sent;\n                sig = this.cert.signature;\n                key = extractDER(derKey);\n                msg = concat(domain_sep('ic-state-root'), rootHash);\n                _context.next = 11;\n                return blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));\n\n              case 11:\n                res = _context.sent;\n                this.verified = res;\n                return _context.abrupt(\"return\", res);\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function verify() {\n        return _verify.apply(this, arguments);\n      }\n\n      return verify;\n    }()\n  }, {\n    key: \"checkState\",\n    value: function checkState() {\n      if (!this.verified) {\n        throw new UnverifiedCertificateError();\n      }\n    }\n  }, {\n    key: \"_checkDelegation\",\n    value: function () {\n      var _checkDelegation2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(d) {\n        var cert, lookup;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (d) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                if (this._rootKey) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                if (!this._agent.rootKey) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                this._rootKey = this._agent.rootKey;\n                return _context2.abrupt(\"return\", this._rootKey);\n\n              case 5:\n                throw new Error(\"Agent does not have a rootKey. Do you need to call 'fetchRootKey'?\");\n\n              case 6:\n                return _context2.abrupt(\"return\", this._rootKey);\n\n              case 7:\n                cert = new Certificate(d, this._agent);\n                _context2.next = 10;\n                return cert.verify();\n\n              case 10:\n                if (_context2.sent) {\n                  _context2.next = 12;\n                  break;\n                }\n\n                throw new Error('fail to verify delegation certificate');\n\n              case 12:\n                lookup = cert.lookup(['subnet', d.subnet_id, 'public_key']);\n\n                if (lookup) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                throw new Error(\"Could not find subnet key for subnet 0x\".concat(toHex(d.subnet_id)));\n\n              case 15:\n                return _context2.abrupt(\"return\", lookup);\n\n              case 16:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _checkDelegation(_x) {\n        return _checkDelegation2.apply(this, arguments);\n      }\n\n      return _checkDelegation;\n    }()\n  }]);\n\n  return Certificate;\n}();\nvar DER_PREFIX = fromHex('308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100');\nvar KEY_LENGTH = 96;\n\nfunction extractDER(buf) {\n  var expectedLength = DER_PREFIX.byteLength + KEY_LENGTH;\n\n  if (buf.byteLength !== expectedLength) {\n    throw new TypeError(\"BLS DER-encoded public key must be \".concat(expectedLength, \" bytes long\"));\n  }\n\n  var prefix = buf.slice(0, DER_PREFIX.byteLength);\n\n  if (!isBufferEqual(prefix, DER_PREFIX)) {\n    throw new TypeError(\"BLS DER-encoded public key is invalid. Expect the following prefix: \".concat(DER_PREFIX, \", but get \").concat(prefix));\n  }\n\n  return buf.slice(DER_PREFIX.byteLength);\n}\n/**\n * @param t\n */\n\n\nexport function reconstruct(_x2) {\n  return _reconstruct.apply(this, arguments);\n}\n\nfunction _reconstruct() {\n  _reconstruct = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(t) {\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.t0 = t[0];\n            _context3.next = _context3.t0 === 0\n            /* Empty */\n            ? 3 : _context3.t0 === 4\n            /* Pruned */\n            ? 4 : _context3.t0 === 3\n            /* Leaf */\n            ? 5 : _context3.t0 === 2\n            /* Labeled */\n            ? 6 : _context3.t0 === 1\n            /* Fork */\n            ? 15 : 26;\n            break;\n\n          case 3:\n            return _context3.abrupt(\"return\", hash(domain_sep('ic-hashtree-empty')));\n\n          case 4:\n            return _context3.abrupt(\"return\", t[1]);\n\n          case 5:\n            return _context3.abrupt(\"return\", hash(concat(domain_sep('ic-hashtree-leaf'), t[1])));\n\n          case 6:\n            _context3.t1 = hash;\n            _context3.t2 = concat;\n            _context3.t3 = domain_sep('ic-hashtree-labeled');\n            _context3.t4 = t[1];\n            _context3.next = 12;\n            return reconstruct(t[2]);\n\n          case 12:\n            _context3.t5 = _context3.sent;\n            _context3.t6 = (0, _context3.t2)(_context3.t3, _context3.t4, _context3.t5);\n            return _context3.abrupt(\"return\", (0, _context3.t1)(_context3.t6));\n\n          case 15:\n            _context3.t7 = hash;\n            _context3.t8 = concat;\n            _context3.t9 = domain_sep('ic-hashtree-fork');\n            _context3.next = 20;\n            return reconstruct(t[1]);\n\n          case 20:\n            _context3.t10 = _context3.sent;\n            _context3.next = 23;\n            return reconstruct(t[2]);\n\n          case 23:\n            _context3.t11 = _context3.sent;\n            _context3.t12 = (0, _context3.t8)(_context3.t9, _context3.t10, _context3.t11);\n            return _context3.abrupt(\"return\", (0, _context3.t7)(_context3.t12));\n\n          case 26:\n            throw new Error('unreachable');\n\n          case 27:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _reconstruct.apply(this, arguments);\n}\n\nfunction domain_sep(s) {\n  var len = new Uint8Array([s.length]);\n  var str = new TextEncoder().encode(s);\n  return concat(len, str);\n}\n/**\n * @param path\n * @param tree\n */\n\n\nexport function lookup_path(path, tree) {\n  if (path.length === 0) {\n    switch (tree[0]) {\n      case 3\n      /* Leaf */\n      :\n        {\n          return new Uint8Array(tree[1]).buffer;\n        }\n\n      default:\n        {\n          return undefined;\n        }\n    }\n  }\n\n  var label = typeof path[0] === 'string' ? new TextEncoder().encode(path[0]) : path[0];\n  var t = find_label(label, flatten_forks(tree));\n\n  if (t) {\n    return lookup_path(path.slice(1), t);\n  }\n}\n\nfunction flatten_forks(t) {\n  switch (t[0]) {\n    case 0\n    /* Empty */\n    :\n      return [];\n\n    case 1\n    /* Fork */\n    :\n      return flatten_forks(t[1]).concat(flatten_forks(t[2]));\n\n    default:\n      return [t];\n  }\n}\n\nfunction find_label(l, trees) {\n  if (trees.length === 0) {\n    return undefined;\n  }\n\n  var _iterator = _createForOfIteratorHelper(trees),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var t = _step.value;\n\n      if (t[0] === 2\n      /* Labeled */\n      ) {\n          var p = t[1];\n\n          if (isBufferEqual(l, p)) {\n            return t[2];\n          }\n        }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}","map":{"version":3,"sources":["../../src/certificate.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { getDefaultAgent } from './agent';\nimport * as cbor from './cbor';\nimport { AgentError } from './errors';\nimport { hash } from './request_id';\nimport { blsVerify } from './utils/bls';\nimport { concat, fromHex, toHex } from './utils/buffer';\n/**\n * A certificate needs to be verified (using {@link Certificate.prototype.verify})\n * before it can be used.\n */\nexport class UnverifiedCertificateError extends AgentError {\n    constructor() {\n        super(`Cannot lookup unverified certificate. Call 'verify()' first.`);\n    }\n}\n/**\n * Make a human readable string out of a hash tree.\n * @param tree\n */\nexport function hashTreeToString(tree) {\n    const indent = (s) => s\n        .split('\\n')\n        .map(x => '  ' + x)\n        .join('\\n');\n    function labelToString(label) {\n        const decoder = new TextDecoder(undefined, { fatal: true });\n        try {\n            return JSON.stringify(decoder.decode(label));\n        }\n        catch (e) {\n            return `data(...${label.byteLength} bytes)`;\n        }\n    }\n    switch (tree[0]) {\n        case 0 /* Empty */:\n            return '()';\n        case 1 /* Fork */: {\n            const left = hashTreeToString(tree[1]);\n            const right = hashTreeToString(tree[2]);\n            return `sub(\\n left:\\n${indent(left)}\\n---\\n right:\\n${indent(right)}\\n)`;\n        }\n        case 2 /* Labeled */: {\n            const label = labelToString(tree[1]);\n            const sub = hashTreeToString(tree[2]);\n            return `label(\\n label:\\n${indent(label)}\\n sub:\\n${indent(sub)}\\n)`;\n        }\n        case 3 /* Leaf */: {\n            return `leaf(...${tree[1].byteLength} bytes)`;\n        }\n        case 4 /* Pruned */: {\n            return `pruned(${toHex(new Uint8Array(tree[1]))}`;\n        }\n        default: {\n            return `unknown(${JSON.stringify(tree[0])})`;\n        }\n    }\n}\nfunction isBufferEqual(a, b) {\n    if (a.byteLength !== b.byteLength) {\n        return false;\n    }\n    const a8 = new Uint8Array(a);\n    const b8 = new Uint8Array(b);\n    for (let i = 0; i < a8.length; i++) {\n        if (a8[i] !== b8[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport class Certificate {\n    constructor(response, _agent = getDefaultAgent()) {\n        this._agent = _agent;\n        this.verified = false;\n        this._rootKey = null;\n        this.cert = cbor.decode(new Uint8Array(response.certificate));\n    }\n    lookup(path) {\n        this.checkState();\n        return lookup_path(path, this.cert.tree);\n    }\n    async verify() {\n        const rootHash = await reconstruct(this.cert.tree);\n        const derKey = await this._checkDelegation(this.cert.delegation);\n        const sig = this.cert.signature;\n        const key = extractDER(derKey);\n        const msg = concat(domain_sep('ic-state-root'), rootHash);\n        const res = await blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));\n        this.verified = res;\n        return res;\n    }\n    checkState() {\n        if (!this.verified) {\n            throw new UnverifiedCertificateError();\n        }\n    }\n    async _checkDelegation(d) {\n        if (!d) {\n            if (!this._rootKey) {\n                if (this._agent.rootKey) {\n                    this._rootKey = this._agent.rootKey;\n                    return this._rootKey;\n                }\n                throw new Error(`Agent does not have a rootKey. Do you need to call 'fetchRootKey'?`);\n            }\n            return this._rootKey;\n        }\n        const cert = new Certificate(d, this._agent);\n        if (!(await cert.verify())) {\n            throw new Error('fail to verify delegation certificate');\n        }\n        const lookup = cert.lookup(['subnet', d.subnet_id, 'public_key']);\n        if (!lookup) {\n            throw new Error(`Could not find subnet key for subnet 0x${toHex(d.subnet_id)}`);\n        }\n        return lookup;\n    }\n}\nconst DER_PREFIX = fromHex('308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100');\nconst KEY_LENGTH = 96;\nfunction extractDER(buf) {\n    const expectedLength = DER_PREFIX.byteLength + KEY_LENGTH;\n    if (buf.byteLength !== expectedLength) {\n        throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);\n    }\n    const prefix = buf.slice(0, DER_PREFIX.byteLength);\n    if (!isBufferEqual(prefix, DER_PREFIX)) {\n        throw new TypeError(`BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX}, but get ${prefix}`);\n    }\n    return buf.slice(DER_PREFIX.byteLength);\n}\n/**\n * @param t\n */\nexport async function reconstruct(t) {\n    switch (t[0]) {\n        case 0 /* Empty */:\n            return hash(domain_sep('ic-hashtree-empty'));\n        case 4 /* Pruned */:\n            return t[1];\n        case 3 /* Leaf */:\n            return hash(concat(domain_sep('ic-hashtree-leaf'), t[1]));\n        case 2 /* Labeled */:\n            return hash(concat(domain_sep('ic-hashtree-labeled'), t[1], await reconstruct(t[2])));\n        case 1 /* Fork */:\n            return hash(concat(domain_sep('ic-hashtree-fork'), await reconstruct(t[1]), await reconstruct(t[2])));\n        default:\n            throw new Error('unreachable');\n    }\n}\nfunction domain_sep(s) {\n    const len = new Uint8Array([s.length]);\n    const str = new TextEncoder().encode(s);\n    return concat(len, str);\n}\n/**\n * @param path\n * @param tree\n */\nexport function lookup_path(path, tree) {\n    if (path.length === 0) {\n        switch (tree[0]) {\n            case 3 /* Leaf */: {\n                return new Uint8Array(tree[1]).buffer;\n            }\n            default: {\n                return undefined;\n            }\n        }\n    }\n    const label = typeof path[0] === 'string' ? new TextEncoder().encode(path[0]) : path[0];\n    const t = find_label(label, flatten_forks(tree));\n    if (t) {\n        return lookup_path(path.slice(1), t);\n    }\n}\nfunction flatten_forks(t) {\n    switch (t[0]) {\n        case 0 /* Empty */:\n            return [];\n        case 1 /* Fork */:\n            return flatten_forks(t[1]).concat(flatten_forks(t[2]));\n        default:\n            return [t];\n    }\n}\nfunction find_label(l, trees) {\n    if (trees.length === 0) {\n        return undefined;\n    }\n    for (const t of trees) {\n        if (t[0] === 2 /* Labeled */) {\n            const p = t[1];\n            if (isBufferEqual(l, p)) {\n                return t[2];\n            }\n        }\n    }\n}\n//# sourceMappingURL=certificate.js.map"]},"metadata":{},"sourceType":"module"}