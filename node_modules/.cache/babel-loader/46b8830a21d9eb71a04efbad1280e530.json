{"ast":null,"code":"import { Buffer } from 'buffer/';\nimport { getDefaultAgent, ReplicaRejectCode } from './agent';\nimport { getManagementCanister } from './canisters/management';\nimport { AgentError } from './errors';\nimport { IDL } from '@dfinity/candid';\nimport { pollForResponse, strategy } from './polling';\nimport { Principal } from '@dfinity/principal';\nimport { toHex } from './utils/buffer';\nexport class ActorCallError extends AgentError {\n  constructor(canisterId, methodName, type, props) {\n    super([`Call failed:`, `  Canister: ${canisterId.toText()}`, `  Method: ${methodName} (${type})`, ...Object.getOwnPropertyNames(props).map(n => `  \"${n}\": ${JSON.stringify(props[n])}`)].join('\\n'));\n    this.canisterId = canisterId;\n    this.methodName = methodName;\n    this.type = type;\n    this.props = props;\n  }\n\n}\nexport class QueryCallRejectedError extends ActorCallError {\n  constructor(canisterId, methodName, result) {\n    var _a;\n\n    super(canisterId, methodName, 'query', {\n      Status: result.status,\n      Code: (_a = ReplicaRejectCode[result.reject_code]) !== null && _a !== void 0 ? _a : `Unknown Code \"${result.reject_code}\"`,\n      Message: result.reject_message\n    });\n    this.result = result;\n  }\n\n}\nexport class UpdateCallRejectedError extends ActorCallError {\n  constructor(canisterId, methodName, requestId, response) {\n    super(canisterId, methodName, 'update', {\n      'Request ID': toHex(requestId),\n      'HTTP status code': response.status.toString(),\n      'HTTP status text': response.statusText\n    });\n    this.requestId = requestId;\n    this.response = response;\n  }\n\n}\n/**\n * The mode used when installing a canister.\n */\n\nexport var CanisterInstallMode;\n\n(function (CanisterInstallMode) {\n  CanisterInstallMode[\"Install\"] = \"install\";\n  CanisterInstallMode[\"Reinstall\"] = \"reinstall\";\n  CanisterInstallMode[\"Upgrade\"] = \"upgrade\";\n})(CanisterInstallMode || (CanisterInstallMode = {}));\n\nconst metadataSymbol = Symbol.for('ic-agent-metadata');\n/**\n * An actor base class. An actor is an object containing only functions that will\n * return a promise. These functions are derived from the IDL definition.\n */\n\nexport class Actor {\n  constructor(metadata) {\n    this[metadataSymbol] = Object.freeze(metadata);\n  }\n  /**\n   * Get the Agent class this Actor would call, or undefined if the Actor would use\n   * the default agent (global.ic.agent).\n   * @param actor The actor to get the agent of.\n   */\n\n\n  static agentOf(actor) {\n    return actor[metadataSymbol].config.agent;\n  }\n  /**\n   * Get the interface of an actor, in the form of an instance of a Service.\n   * @param actor The actor to get the interface of.\n   */\n\n\n  static interfaceOf(actor) {\n    return actor[metadataSymbol].service;\n  }\n\n  static canisterIdOf(actor) {\n    return Principal.from(actor[metadataSymbol].config.canisterId);\n  }\n\n  static async install(fields, config) {\n    const mode = fields.mode === undefined ? CanisterInstallMode.Install : fields.mode; // Need to transform the arg into a number array.\n\n    const arg = fields.arg ? [...new Uint8Array(fields.arg)] : []; // Same for module.\n\n    const wasmModule = [...new Uint8Array(fields.module)];\n    const canisterId = typeof config.canisterId === 'string' ? Principal.fromText(config.canisterId) : config.canisterId;\n    await getManagementCanister(config).install_code({\n      mode: {\n        [mode]: null\n      },\n      arg,\n      wasm_module: wasmModule,\n      canister_id: canisterId\n    });\n  }\n\n  static async createCanister(config) {\n    const {\n      canister_id: canisterId\n    } = await getManagementCanister(config || {}).provisional_create_canister_with_cycles({\n      amount: [],\n      settings: []\n    });\n    return canisterId;\n  }\n\n  static async createAndInstallCanister(interfaceFactory, fields, config) {\n    const canisterId = await this.createCanister(config);\n    await this.install(Object.assign({}, fields), Object.assign(Object.assign({}, config), {\n      canisterId\n    }));\n    return this.createActor(interfaceFactory, Object.assign(Object.assign({}, config), {\n      canisterId\n    }));\n  }\n\n  static createActorClass(interfaceFactory) {\n    const service = interfaceFactory({\n      IDL\n    });\n\n    class CanisterActor extends Actor {\n      constructor(config) {\n        const canisterId = typeof config.canisterId === 'string' ? Principal.fromText(config.canisterId) : config.canisterId;\n        super({\n          config: Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), config), {\n            canisterId\n          }),\n          service\n        });\n\n        for (const [methodName, func] of service._fields) {\n          this[methodName] = _createActorMethod(this, methodName, func);\n        }\n      }\n\n    }\n\n    return CanisterActor;\n  }\n\n  static createActor(interfaceFactory, configuration) {\n    return new (this.createActorClass(interfaceFactory))(configuration);\n  }\n\n} // IDL functions can have multiple return values, so decoding always\n// produces an array. Ensure that functions with single or zero return\n// values behave as expected.\n\nfunction decodeReturnValue(types, msg) {\n  const returnValues = IDL.decode(types, Buffer.from(msg));\n\n  switch (returnValues.length) {\n    case 0:\n      return undefined;\n\n    case 1:\n      return returnValues[0];\n\n    default:\n      return returnValues;\n  }\n}\n\nconst DEFAULT_ACTOR_CONFIG = {\n  pollingStrategyFactory: strategy.defaultStrategy\n};\n\nfunction _createActorMethod(actor, methodName, func) {\n  let caller;\n\n  if (func.annotations.includes('query')) {\n    caller = async (options, ...args) => {\n      var _a, _b; // First, if there's a config transformation, call it.\n\n\n      options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).queryTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));\n      const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();\n      const cid = Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);\n      const arg = IDL.encode(func.argTypes, args);\n      const result = await agent.query(cid, {\n        methodName,\n        arg\n      });\n\n      switch (result.status) {\n        case \"rejected\"\n        /* Rejected */\n        :\n          throw new QueryCallRejectedError(cid, methodName, result);\n\n        case \"replied\"\n        /* Replied */\n        :\n          return decodeReturnValue(func.retTypes, result.reply.arg);\n      }\n    };\n  } else {\n    caller = async (options, ...args) => {\n      var _a, _b; // First, if there's a config transformation, call it.\n\n\n      options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).callTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));\n      const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();\n      const {\n        canisterId,\n        effectiveCanisterId,\n        pollingStrategyFactory\n      } = Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), actor[metadataSymbol].config), options);\n      const cid = Principal.from(canisterId);\n      const ecid = effectiveCanisterId !== undefined ? Principal.from(effectiveCanisterId) : cid;\n      const arg = IDL.encode(func.argTypes, args);\n      const {\n        requestId,\n        response\n      } = await agent.call(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: ecid\n      });\n\n      if (!response.ok) {\n        throw new UpdateCallRejectedError(cid, methodName, requestId, response);\n      }\n\n      const pollStrategy = pollingStrategyFactory();\n      const responseBytes = await pollForResponse(agent, ecid, requestId, pollStrategy);\n\n      if (responseBytes !== undefined) {\n        return decodeReturnValue(func.retTypes, responseBytes);\n      } else if (func.retTypes.length === 0) {\n        return undefined;\n      } else {\n        throw new Error(`Call was returned undefined, but type [${func.retTypes.join(',')}].`);\n      }\n    };\n  }\n\n  const handler = (...args) => caller({}, ...args);\n\n  handler.withOptions = options => (...args) => caller(options, ...args);\n\n  return handler;\n}","map":{"version":3,"sources":["../../src/actor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Buffer } from 'buffer/';\nimport { getDefaultAgent, ReplicaRejectCode, } from './agent';\nimport { getManagementCanister } from './canisters/management';\nimport { AgentError } from './errors';\nimport { IDL } from '@dfinity/candid';\nimport { pollForResponse, strategy } from './polling';\nimport { Principal } from '@dfinity/principal';\nimport { toHex } from './utils/buffer';\nexport class ActorCallError extends AgentError {\n    constructor(canisterId, methodName, type, props) {\n        super([\n            `Call failed:`,\n            `  Canister: ${canisterId.toText()}`,\n            `  Method: ${methodName} (${type})`,\n            ...Object.getOwnPropertyNames(props).map(n => `  \"${n}\": ${JSON.stringify(props[n])}`),\n        ].join('\\n'));\n        this.canisterId = canisterId;\n        this.methodName = methodName;\n        this.type = type;\n        this.props = props;\n    }\n}\nexport class QueryCallRejectedError extends ActorCallError {\n    constructor(canisterId, methodName, result) {\n        var _a;\n        super(canisterId, methodName, 'query', {\n            Status: result.status,\n            Code: (_a = ReplicaRejectCode[result.reject_code]) !== null && _a !== void 0 ? _a : `Unknown Code \"${result.reject_code}\"`,\n            Message: result.reject_message,\n        });\n        this.result = result;\n    }\n}\nexport class UpdateCallRejectedError extends ActorCallError {\n    constructor(canisterId, methodName, requestId, response) {\n        super(canisterId, methodName, 'update', {\n            'Request ID': toHex(requestId),\n            'HTTP status code': response.status.toString(),\n            'HTTP status text': response.statusText,\n        });\n        this.requestId = requestId;\n        this.response = response;\n    }\n}\n/**\n * The mode used when installing a canister.\n */\nexport var CanisterInstallMode;\n(function (CanisterInstallMode) {\n    CanisterInstallMode[\"Install\"] = \"install\";\n    CanisterInstallMode[\"Reinstall\"] = \"reinstall\";\n    CanisterInstallMode[\"Upgrade\"] = \"upgrade\";\n})(CanisterInstallMode || (CanisterInstallMode = {}));\nconst metadataSymbol = Symbol.for('ic-agent-metadata');\n/**\n * An actor base class. An actor is an object containing only functions that will\n * return a promise. These functions are derived from the IDL definition.\n */\nexport class Actor {\n    constructor(metadata) {\n        this[metadataSymbol] = Object.freeze(metadata);\n    }\n    /**\n     * Get the Agent class this Actor would call, or undefined if the Actor would use\n     * the default agent (global.ic.agent).\n     * @param actor The actor to get the agent of.\n     */\n    static agentOf(actor) {\n        return actor[metadataSymbol].config.agent;\n    }\n    /**\n     * Get the interface of an actor, in the form of an instance of a Service.\n     * @param actor The actor to get the interface of.\n     */\n    static interfaceOf(actor) {\n        return actor[metadataSymbol].service;\n    }\n    static canisterIdOf(actor) {\n        return Principal.from(actor[metadataSymbol].config.canisterId);\n    }\n    static async install(fields, config) {\n        const mode = fields.mode === undefined ? CanisterInstallMode.Install : fields.mode;\n        // Need to transform the arg into a number array.\n        const arg = fields.arg ? [...new Uint8Array(fields.arg)] : [];\n        // Same for module.\n        const wasmModule = [...new Uint8Array(fields.module)];\n        const canisterId = typeof config.canisterId === 'string'\n            ? Principal.fromText(config.canisterId)\n            : config.canisterId;\n        await getManagementCanister(config).install_code({\n            mode: { [mode]: null },\n            arg,\n            wasm_module: wasmModule,\n            canister_id: canisterId,\n        });\n    }\n    static async createCanister(config) {\n        const { canister_id: canisterId } = await getManagementCanister(config || {}).provisional_create_canister_with_cycles({ amount: [], settings: [] });\n        return canisterId;\n    }\n    static async createAndInstallCanister(interfaceFactory, fields, config) {\n        const canisterId = await this.createCanister(config);\n        await this.install(Object.assign({}, fields), Object.assign(Object.assign({}, config), { canisterId }));\n        return this.createActor(interfaceFactory, Object.assign(Object.assign({}, config), { canisterId }));\n    }\n    static createActorClass(interfaceFactory) {\n        const service = interfaceFactory({ IDL });\n        class CanisterActor extends Actor {\n            constructor(config) {\n                const canisterId = typeof config.canisterId === 'string'\n                    ? Principal.fromText(config.canisterId)\n                    : config.canisterId;\n                super({\n                    config: Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), config), { canisterId }),\n                    service,\n                });\n                for (const [methodName, func] of service._fields) {\n                    this[methodName] = _createActorMethod(this, methodName, func);\n                }\n            }\n        }\n        return CanisterActor;\n    }\n    static createActor(interfaceFactory, configuration) {\n        return new (this.createActorClass(interfaceFactory))(configuration);\n    }\n}\n// IDL functions can have multiple return values, so decoding always\n// produces an array. Ensure that functions with single or zero return\n// values behave as expected.\nfunction decodeReturnValue(types, msg) {\n    const returnValues = IDL.decode(types, Buffer.from(msg));\n    switch (returnValues.length) {\n        case 0:\n            return undefined;\n        case 1:\n            return returnValues[0];\n        default:\n            return returnValues;\n    }\n}\nconst DEFAULT_ACTOR_CONFIG = {\n    pollingStrategyFactory: strategy.defaultStrategy,\n};\nfunction _createActorMethod(actor, methodName, func) {\n    let caller;\n    if (func.annotations.includes('query')) {\n        caller = async (options, ...args) => {\n            var _a, _b;\n            // First, if there's a config transformation, call it.\n            options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).queryTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));\n            const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();\n            const cid = Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);\n            const arg = IDL.encode(func.argTypes, args);\n            const result = await agent.query(cid, { methodName, arg });\n            switch (result.status) {\n                case \"rejected\" /* Rejected */:\n                    throw new QueryCallRejectedError(cid, methodName, result);\n                case \"replied\" /* Replied */:\n                    return decodeReturnValue(func.retTypes, result.reply.arg);\n            }\n        };\n    }\n    else {\n        caller = async (options, ...args) => {\n            var _a, _b;\n            // First, if there's a config transformation, call it.\n            options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).callTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));\n            const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();\n            const { canisterId, effectiveCanisterId, pollingStrategyFactory } = Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), actor[metadataSymbol].config), options);\n            const cid = Principal.from(canisterId);\n            const ecid = effectiveCanisterId !== undefined ? Principal.from(effectiveCanisterId) : cid;\n            const arg = IDL.encode(func.argTypes, args);\n            const { requestId, response } = await agent.call(cid, {\n                methodName,\n                arg,\n                effectiveCanisterId: ecid,\n            });\n            if (!response.ok) {\n                throw new UpdateCallRejectedError(cid, methodName, requestId, response);\n            }\n            const pollStrategy = pollingStrategyFactory();\n            const responseBytes = await pollForResponse(agent, ecid, requestId, pollStrategy);\n            if (responseBytes !== undefined) {\n                return decodeReturnValue(func.retTypes, responseBytes);\n            }\n            else if (func.retTypes.length === 0) {\n                return undefined;\n            }\n            else {\n                throw new Error(`Call was returned undefined, but type [${func.retTypes.join(',')}].`);\n            }\n        };\n    }\n    const handler = (...args) => caller({}, ...args);\n    handler.withOptions =\n        (options) => (...args) => caller(options, ...args);\n    return handler;\n}\n//# sourceMappingURL=actor.js.map"]},"metadata":{},"sourceType":"module"}