{"ast":null,"code":"import { toHex } from '../utils/buffer';\nconst FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n/**\n * A best practices polling strategy: wait 2 seconds before the first poll, then 1 second\n * with an exponential backoff factor of 1.2. Timeout after 5 minutes.\n */\n\nexport function defaultStrategy() {\n  return chain(conditionalDelay(once(), 1000), backoff(1000, 1.2), timeout(FIVE_MINUTES_IN_MSEC));\n}\n/**\n * Predicate that returns true once.\n */\n\nexport function once() {\n  let first = true;\n  return async () => {\n    if (first) {\n      first = false;\n      return true;\n    }\n\n    return false;\n  };\n}\n/**\n * Delay the polling once.\n * @param condition A predicate that indicates when to delay.\n * @param timeInMsec The amount of time to delay.\n */\n\nexport function conditionalDelay(condition, timeInMsec) {\n  return async (canisterId, requestId, status) => {\n    if (await condition(canisterId, requestId, status)) {\n      return new Promise(resolve => setTimeout(resolve, timeInMsec));\n    }\n  };\n}\n/**\n * Error out after a maximum number of polling has been done.\n * @param count The maximum attempts to poll.\n */\n\nexport function maxAttempts(count) {\n  let attempts = count;\n  return async (canisterId, requestId, status) => {\n    if (--attempts <= 0) {\n      throw new Error(`Failed to retrieve a reply for request after ${count} attempts:\\n` + `  Request ID: ${toHex(requestId)}\\n` + `  Request status: ${status}\\n`);\n    }\n  };\n}\n/**\n * Throttle polling.\n * @param throttleInMsec Amount in millisecond to wait between each polling.\n */\n\nexport function throttle(throttleInMsec) {\n  return () => new Promise(resolve => setTimeout(resolve, throttleInMsec));\n}\n/**\n * Reject a call after a certain amount of time.\n * @param timeInMsec Time in milliseconds before the polling should be rejected.\n */\n\nexport function timeout(timeInMsec) {\n  const end = Date.now() + timeInMsec;\n  return async (canisterId, requestId, status) => {\n    if (Date.now() > end) {\n      throw new Error(`Request timed out after ${timeInMsec} msec:\\n` + `  Request ID: ${toHex(requestId)}\\n` + `  Request status: ${status}\\n`);\n    }\n  };\n}\n/**\n * A strategy that throttle, but using an exponential backoff strategy.\n * @param startingThrottleInMsec The throttle in milliseconds to start with.\n * @param backoffFactor The factor to multiple the throttle time between every poll. For\n *   example if using 2, the throttle will double between every run.\n */\n\nexport function backoff(startingThrottleInMsec, backoffFactor) {\n  let currentThrottling = startingThrottleInMsec;\n  return () => new Promise(resolve => setTimeout(() => {\n    currentThrottling *= backoffFactor;\n    resolve();\n  }, currentThrottling));\n}\n/**\n * Chain multiple polling strategy. This _chains_ the strategies, so if you pass in,\n * say, two throttling strategy of 1 second, it will result in a throttle of 2 seconds.\n * @param strategies A strategy list to chain.\n */\n\nexport function chain(...strategies) {\n  return async (canisterId, requestId, status) => {\n    for (const a of strategies) {\n      await a(canisterId, requestId, status);\n    }\n  };\n}","map":{"version":3,"sources":["../../../src/polling/strategy.ts"],"names":[],"mappings":"AAEA,SAAS,KAAT,QAAsB,iBAAtB;AASA,MAAM,oBAAoB,GAAG,IAAI,EAAJ,GAAS,IAAtC;AAEA;;;AAGG;;AACH,OAAM,SAAU,eAAV,GAAyB;AAC7B,SAAO,KAAK,CAAC,gBAAgB,CAAC,IAAI,EAAL,EAAS,IAAT,CAAjB,EAAiC,OAAO,CAAC,IAAD,EAAO,GAAP,CAAxC,EAAqD,OAAO,CAAC,oBAAD,CAA5D,CAAZ;AACD;AAED;;AAEG;;AACH,OAAM,SAAU,IAAV,GAAc;AAClB,MAAI,KAAK,GAAG,IAAZ;AACA,SAAO,YAAW;AAChB,QAAI,KAAJ,EAAW;AACT,MAAA,KAAK,GAAG,KAAR;AACA,aAAO,IAAP;AACD;;AACD,WAAO,KAAP;AACD,GAND;AAOD;AAED;;;;AAIG;;AACH,OAAM,SAAU,gBAAV,CAA2B,SAA3B,EAA0D,UAA1D,EAA4E;AAChF,SAAO,OACL,UADK,EAEL,SAFK,EAGL,MAHK,KAIH;AACF,QAAI,MAAM,SAAS,CAAC,UAAD,EAAa,SAAb,EAAwB,MAAxB,CAAnB,EAAoD;AAClD,aAAO,IAAI,OAAJ,CAAY,OAAO,IAAI,UAAU,CAAC,OAAD,EAAU,UAAV,CAAjC,CAAP;AACD;AACF,GARD;AASD;AAED;;;AAGG;;AACH,OAAM,SAAU,WAAV,CAAsB,KAAtB,EAAmC;AACvC,MAAI,QAAQ,GAAG,KAAf;AACA,SAAO,OACL,UADK,EAEL,SAFK,EAGL,MAHK,KAIH;AACF,QAAI,EAAE,QAAF,IAAc,CAAlB,EAAqB;AACnB,YAAM,IAAI,KAAJ,CACJ,gDAAgD,KAAK,cAArD,GACE,iBAAiB,KAAK,CAAC,SAAD,CAAW,IADnC,GAEE,qBAAqB,MAAM,IAHzB,CAAN;AAKD;AACF,GAZD;AAaD;AAED;;;AAGG;;AACH,OAAM,SAAU,QAAV,CAAmB,cAAnB,EAAyC;AAC7C,SAAO,MAAM,IAAI,OAAJ,CAAY,OAAO,IAAI,UAAU,CAAC,OAAD,EAAU,cAAV,CAAjC,CAAb;AACD;AAED;;;AAGG;;AACH,OAAM,SAAU,OAAV,CAAkB,UAAlB,EAAoC;AACxC,QAAM,GAAG,GAAG,IAAI,CAAC,GAAL,KAAa,UAAzB;AACA,SAAO,OACL,UADK,EAEL,SAFK,EAGL,MAHK,KAIH;AACF,QAAI,IAAI,CAAC,GAAL,KAAa,GAAjB,EAAsB;AACpB,YAAM,IAAI,KAAJ,CACJ,2BAA2B,UAAU,UAArC,GACE,iBAAiB,KAAK,CAAC,SAAD,CAAW,IADnC,GAEE,qBAAqB,MAAM,IAHzB,CAAN;AAKD;AACF,GAZD;AAaD;AAED;;;;;AAKG;;AACH,OAAM,SAAU,OAAV,CAAkB,sBAAlB,EAAkD,aAAlD,EAAuE;AAC3E,MAAI,iBAAiB,GAAG,sBAAxB;AAEA,SAAO,MACL,IAAI,OAAJ,CAAY,OAAO,IACjB,UAAU,CAAC,MAAK;AACd,IAAA,iBAAiB,IAAI,aAArB;AACA,IAAA,OAAO;AACR,GAHS,EAGP,iBAHO,CADZ,CADF;AAOD;AAED;;;;AAIG;;AACH,OAAM,SAAU,KAAV,CAAgB,GAAG,UAAnB,EAA6C;AACjD,SAAO,OACL,UADK,EAEL,SAFK,EAGL,MAHK,KAIH;AACF,SAAK,MAAM,CAAX,IAAgB,UAAhB,EAA4B;AAC1B,YAAM,CAAC,CAAC,UAAD,EAAa,SAAb,EAAwB,MAAxB,CAAP;AACD;AACF,GARD;AASD","sourceRoot":"","sourcesContent":["import { toHex } from '../utils/buffer';\nconst FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n/**\n * A best practices polling strategy: wait 2 seconds before the first poll, then 1 second\n * with an exponential backoff factor of 1.2. Timeout after 5 minutes.\n */\nexport function defaultStrategy() {\n    return chain(conditionalDelay(once(), 1000), backoff(1000, 1.2), timeout(FIVE_MINUTES_IN_MSEC));\n}\n/**\n * Predicate that returns true once.\n */\nexport function once() {\n    let first = true;\n    return async () => {\n        if (first) {\n            first = false;\n            return true;\n        }\n        return false;\n    };\n}\n/**\n * Delay the polling once.\n * @param condition A predicate that indicates when to delay.\n * @param timeInMsec The amount of time to delay.\n */\nexport function conditionalDelay(condition, timeInMsec) {\n    return async (canisterId, requestId, status) => {\n        if (await condition(canisterId, requestId, status)) {\n            return new Promise(resolve => setTimeout(resolve, timeInMsec));\n        }\n    };\n}\n/**\n * Error out after a maximum number of polling has been done.\n * @param count The maximum attempts to poll.\n */\nexport function maxAttempts(count) {\n    let attempts = count;\n    return async (canisterId, requestId, status) => {\n        if (--attempts <= 0) {\n            throw new Error(`Failed to retrieve a reply for request after ${count} attempts:\\n` +\n                `  Request ID: ${toHex(requestId)}\\n` +\n                `  Request status: ${status}\\n`);\n        }\n    };\n}\n/**\n * Throttle polling.\n * @param throttleInMsec Amount in millisecond to wait between each polling.\n */\nexport function throttle(throttleInMsec) {\n    return () => new Promise(resolve => setTimeout(resolve, throttleInMsec));\n}\n/**\n * Reject a call after a certain amount of time.\n * @param timeInMsec Time in milliseconds before the polling should be rejected.\n */\nexport function timeout(timeInMsec) {\n    const end = Date.now() + timeInMsec;\n    return async (canisterId, requestId, status) => {\n        if (Date.now() > end) {\n            throw new Error(`Request timed out after ${timeInMsec} msec:\\n` +\n                `  Request ID: ${toHex(requestId)}\\n` +\n                `  Request status: ${status}\\n`);\n        }\n    };\n}\n/**\n * A strategy that throttle, but using an exponential backoff strategy.\n * @param startingThrottleInMsec The throttle in milliseconds to start with.\n * @param backoffFactor The factor to multiple the throttle time between every poll. For\n *   example if using 2, the throttle will double between every run.\n */\nexport function backoff(startingThrottleInMsec, backoffFactor) {\n    let currentThrottling = startingThrottleInMsec;\n    return () => new Promise(resolve => setTimeout(() => {\n        currentThrottling *= backoffFactor;\n        resolve();\n    }, currentThrottling));\n}\n/**\n * Chain multiple polling strategy. This _chains_ the strategies, so if you pass in,\n * say, two throttling strategy of 1 second, it will result in a throttle of 2 seconds.\n * @param strategies A strategy list to chain.\n */\nexport function chain(...strategies) {\n    return async (canisterId, requestId, status) => {\n        for (const a of strategies) {\n            await a(canisterId, requestId, status);\n        }\n    };\n}\n//# sourceMappingURL=strategy.js.map"]},"metadata":{},"sourceType":"module"}