{"ast":null,"code":"import { lebEncode } from '@dfinity/candid';\nimport * as cbor from 'simple-cbor';\nimport { makeNonce } from './types';\nconst NANOSECONDS_PER_MILLISECONDS = BigInt(1000000);\nconst REPLICA_PERMITTED_DRIFT_MILLISECONDS = BigInt(60 * 1000);\nexport class Expiry {\n  constructor(deltaInMSec) {\n    // Use bigint because it can overflow the maximum number allowed in a double float.\n    this._value = (BigInt(Date.now()) + BigInt(deltaInMSec) - REPLICA_PERMITTED_DRIFT_MILLISECONDS) * NANOSECONDS_PER_MILLISECONDS;\n  }\n\n  toCBOR() {\n    // TODO: change this to take the minimum amount of space (it always takes 8 bytes now).\n    return cbor.value.u64(this._value.toString(16), 16);\n  }\n\n  toHash() {\n    return lebEncode(this._value);\n  }\n\n}\n/**\n * Create a Nonce transform, which takes a function that returns a Buffer, and adds it\n * as the nonce to every call requests.\n * @param nonceFn A function that returns a buffer. By default uses a semi-random method.\n */\n\nexport function makeNonceTransform(nonceFn = makeNonce) {\n  return async request => {\n    // Nonce are only useful for async calls, to prevent replay attacks. Other types of\n    // calls don't need Nonce so we just skip creating one.\n    if (request.endpoint === \"call\"\n    /* Call */\n    ) {\n        request.body.nonce = nonceFn();\n      }\n  };\n}\n/**\n * Create a transform that adds a delay (by default 5 minutes) to the expiry.\n *\n * @param delayInMilliseconds The delay to add to the call time, in milliseconds.\n */\n\nexport function makeExpiryTransform(delayInMilliseconds) {\n  return async request => {\n    request.body.ingress_expiry = new Expiry(delayInMilliseconds);\n  };\n}","map":{"version":3,"sources":["../../../../src/agent/http/transforms.ts"],"names":[],"mappings":"AAAA,SAAS,SAAT,QAA0B,iBAA1B;AACA,OAAO,KAAK,IAAZ,MAAsB,aAAtB;AACA,SAAkE,SAAlE,QAA0F,SAA1F;AAEA,MAAM,4BAA4B,GAAG,MAAM,CAAC,OAAD,CAA3C;AAEA,MAAM,oCAAoC,GAAG,MAAM,CAAC,KAAK,IAAN,CAAnD;AAEA,OAAM,MAAO,MAAP,CAAa;AAGjB,EAAA,WAAA,CAAY,WAAZ,EAA+B;AAC7B;AACA,SAAK,MAAL,GACE,CAAC,MAAM,CAAC,IAAI,CAAC,GAAL,EAAD,CAAN,GAAqB,MAAM,CAAC,WAAD,CAA3B,GAA2C,oCAA5C,IACA,4BAFF;AAGD;;AAEM,EAAA,MAAM,GAAA;AACX;AACA,WAAO,IAAI,CAAC,KAAL,CAAW,GAAX,CAAe,KAAK,MAAL,CAAY,QAAZ,CAAqB,EAArB,CAAf,EAAyC,EAAzC,CAAP;AACD;;AAEM,EAAA,MAAM,GAAA;AACX,WAAO,SAAS,CAAC,KAAK,MAAN,CAAhB;AACD;;AAjBgB;AAoBnB;;;;AAIG;;AACH,OAAM,SAAU,kBAAV,CAA6B,OAAA,GAAuB,SAApD,EAA6D;AACjE,SAAO,MAAO,OAAP,IAAoC;AACzC;AACA;AACA,QAAI,OAAO,CAAC,QAAR,KAAgB;AAAA;AAApB,MAAwC;AACtC,QAAA,OAAO,CAAC,IAAR,CAAa,KAAb,GAAqB,OAAO,EAA5B;AACD;AACF,GAND;AAOD;AAED;;;;AAIG;;AACH,OAAM,SAAU,mBAAV,CAA8B,mBAA9B,EAAyD;AAC7D,SAAO,MAAO,OAAP,IAAoC;AACzC,IAAA,OAAO,CAAC,IAAR,CAAa,cAAb,GAA8B,IAAI,MAAJ,CAAW,mBAAX,CAA9B;AACD,GAFD;AAGD","sourceRoot":"","sourcesContent":["import { lebEncode } from '@dfinity/candid';\nimport * as cbor from 'simple-cbor';\nimport { makeNonce } from './types';\nconst NANOSECONDS_PER_MILLISECONDS = BigInt(1000000);\nconst REPLICA_PERMITTED_DRIFT_MILLISECONDS = BigInt(60 * 1000);\nexport class Expiry {\n    constructor(deltaInMSec) {\n        // Use bigint because it can overflow the maximum number allowed in a double float.\n        this._value =\n            (BigInt(Date.now()) + BigInt(deltaInMSec) - REPLICA_PERMITTED_DRIFT_MILLISECONDS) *\n                NANOSECONDS_PER_MILLISECONDS;\n    }\n    toCBOR() {\n        // TODO: change this to take the minimum amount of space (it always takes 8 bytes now).\n        return cbor.value.u64(this._value.toString(16), 16);\n    }\n    toHash() {\n        return lebEncode(this._value);\n    }\n}\n/**\n * Create a Nonce transform, which takes a function that returns a Buffer, and adds it\n * as the nonce to every call requests.\n * @param nonceFn A function that returns a buffer. By default uses a semi-random method.\n */\nexport function makeNonceTransform(nonceFn = makeNonce) {\n    return async (request) => {\n        // Nonce are only useful for async calls, to prevent replay attacks. Other types of\n        // calls don't need Nonce so we just skip creating one.\n        if (request.endpoint === \"call\" /* Call */) {\n            request.body.nonce = nonceFn();\n        }\n    };\n}\n/**\n * Create a transform that adds a delay (by default 5 minutes) to the expiry.\n *\n * @param delayInMilliseconds The delay to add to the call time, in milliseconds.\n */\nexport function makeExpiryTransform(delayInMilliseconds) {\n    return async (request) => {\n        request.body.ingress_expiry = new Expiry(delayInMilliseconds);\n    };\n}\n//# sourceMappingURL=transforms.js.map"]},"metadata":{},"sourceType":"module"}