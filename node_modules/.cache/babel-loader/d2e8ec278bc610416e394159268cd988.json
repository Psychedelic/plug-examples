{"ast":null,"code":"import _slicedToArray from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _assertThisInitialized from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _regeneratorRuntime from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _defineProperty from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _asyncToGenerator from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _createClass from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _toConsumableArray from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _inherits from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Buffer } from 'buffer/';\nimport { getDefaultAgent, ReplicaRejectCode } from './agent';\nimport { getManagementCanister } from './canisters/management';\nimport { AgentError } from './errors';\nimport { IDL } from '@dfinity/candid';\nimport { pollForResponse, strategy } from './polling';\nimport { Principal } from '@dfinity/principal';\nimport { toHex } from './utils/buffer';\nexport var ActorCallError = /*#__PURE__*/function (_AgentError) {\n  _inherits(ActorCallError, _AgentError);\n\n  var _super = _createSuper(ActorCallError);\n\n  function ActorCallError(canisterId, methodName, type, props) {\n    var _this;\n\n    _classCallCheck(this, ActorCallError);\n\n    _this = _super.call(this, [\"Call failed:\", \"  Canister: \".concat(canisterId.toText()), \"  Method: \".concat(methodName, \" (\").concat(type, \")\")].concat(_toConsumableArray(Object.getOwnPropertyNames(props).map(function (n) {\n      return \"  \\\"\".concat(n, \"\\\": \").concat(JSON.stringify(props[n]));\n    }))).join('\\n'));\n    _this.canisterId = canisterId;\n    _this.methodName = methodName;\n    _this.type = type;\n    _this.props = props;\n    return _this;\n  }\n\n  return ActorCallError;\n}(AgentError);\nexport var QueryCallRejectedError = /*#__PURE__*/function (_ActorCallError) {\n  _inherits(QueryCallRejectedError, _ActorCallError);\n\n  var _super2 = _createSuper(QueryCallRejectedError);\n\n  function QueryCallRejectedError(canisterId, methodName, result) {\n    var _this2;\n\n    _classCallCheck(this, QueryCallRejectedError);\n\n    var _a;\n\n    _this2 = _super2.call(this, canisterId, methodName, 'query', {\n      Status: result.status,\n      Code: (_a = ReplicaRejectCode[result.reject_code]) !== null && _a !== void 0 ? _a : \"Unknown Code \\\"\".concat(result.reject_code, \"\\\"\"),\n      Message: result.reject_message\n    });\n    _this2.result = result;\n    return _this2;\n  }\n\n  return QueryCallRejectedError;\n}(ActorCallError);\nexport var UpdateCallRejectedError = /*#__PURE__*/function (_ActorCallError2) {\n  _inherits(UpdateCallRejectedError, _ActorCallError2);\n\n  var _super3 = _createSuper(UpdateCallRejectedError);\n\n  function UpdateCallRejectedError(canisterId, methodName, requestId, response) {\n    var _this3;\n\n    _classCallCheck(this, UpdateCallRejectedError);\n\n    _this3 = _super3.call(this, canisterId, methodName, 'update', {\n      'Request ID': toHex(requestId),\n      'HTTP status code': response.status.toString(),\n      'HTTP status text': response.statusText\n    });\n    _this3.requestId = requestId;\n    _this3.response = response;\n    return _this3;\n  }\n\n  return UpdateCallRejectedError;\n}(ActorCallError);\n/**\n * The mode used when installing a canister.\n */\n\nexport var CanisterInstallMode;\n\n(function (CanisterInstallMode) {\n  CanisterInstallMode[\"Install\"] = \"install\";\n  CanisterInstallMode[\"Reinstall\"] = \"reinstall\";\n  CanisterInstallMode[\"Upgrade\"] = \"upgrade\";\n})(CanisterInstallMode || (CanisterInstallMode = {}));\n\nvar metadataSymbol = Symbol.for('ic-agent-metadata');\n/**\n * An actor base class. An actor is an object containing only functions that will\n * return a promise. These functions are derived from the IDL definition.\n */\n\nexport var Actor = /*#__PURE__*/function () {\n  function Actor(metadata) {\n    _classCallCheck(this, Actor);\n\n    this[metadataSymbol] = Object.freeze(metadata);\n  }\n  /**\n   * Get the Agent class this Actor would call, or undefined if the Actor would use\n   * the default agent (global.ic.agent).\n   * @param actor The actor to get the agent of.\n   */\n\n\n  _createClass(Actor, null, [{\n    key: \"agentOf\",\n    value: function agentOf(actor) {\n      return actor[metadataSymbol].config.agent;\n    }\n    /**\n     * Get the interface of an actor, in the form of an instance of a Service.\n     * @param actor The actor to get the interface of.\n     */\n\n  }, {\n    key: \"interfaceOf\",\n    value: function interfaceOf(actor) {\n      return actor[metadataSymbol].service;\n    }\n  }, {\n    key: \"canisterIdOf\",\n    value: function canisterIdOf(actor) {\n      return Principal.from(actor[metadataSymbol].config.canisterId);\n    }\n  }, {\n    key: \"install\",\n    value: function () {\n      var _install = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(fields, config) {\n        var mode, arg, wasmModule, canisterId;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                mode = fields.mode === undefined ? CanisterInstallMode.Install : fields.mode; // Need to transform the arg into a number array.\n\n                arg = fields.arg ? _toConsumableArray(new Uint8Array(fields.arg)) : []; // Same for module.\n\n                wasmModule = _toConsumableArray(new Uint8Array(fields.module));\n                canisterId = typeof config.canisterId === 'string' ? Principal.fromText(config.canisterId) : config.canisterId;\n                _context.next = 6;\n                return getManagementCanister(config).install_code({\n                  mode: _defineProperty({}, mode, null),\n                  arg: arg,\n                  wasm_module: wasmModule,\n                  canister_id: canisterId\n                });\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function install(_x, _x2) {\n        return _install.apply(this, arguments);\n      }\n\n      return install;\n    }()\n  }, {\n    key: \"createCanister\",\n    value: function () {\n      var _createCanister = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(config) {\n        var _yield$getManagementC, canisterId;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return getManagementCanister(config || {}).provisional_create_canister_with_cycles({\n                  amount: [],\n                  settings: []\n                });\n\n              case 2:\n                _yield$getManagementC = _context2.sent;\n                canisterId = _yield$getManagementC.canister_id;\n                return _context2.abrupt(\"return\", canisterId);\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function createCanister(_x3) {\n        return _createCanister.apply(this, arguments);\n      }\n\n      return createCanister;\n    }()\n  }, {\n    key: \"createAndInstallCanister\",\n    value: function () {\n      var _createAndInstallCanister = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(interfaceFactory, fields, config) {\n        var canisterId;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.createCanister(config);\n\n              case 2:\n                canisterId = _context3.sent;\n                _context3.next = 5;\n                return this.install(Object.assign({}, fields), Object.assign(Object.assign({}, config), {\n                  canisterId: canisterId\n                }));\n\n              case 5:\n                return _context3.abrupt(\"return\", this.createActor(interfaceFactory, Object.assign(Object.assign({}, config), {\n                  canisterId: canisterId\n                })));\n\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function createAndInstallCanister(_x4, _x5, _x6) {\n        return _createAndInstallCanister.apply(this, arguments);\n      }\n\n      return createAndInstallCanister;\n    }()\n  }, {\n    key: \"createActorClass\",\n    value: function createActorClass(interfaceFactory) {\n      var service = interfaceFactory({\n        IDL: IDL\n      });\n\n      var CanisterActor = /*#__PURE__*/function (_Actor) {\n        _inherits(CanisterActor, _Actor);\n\n        var _super4 = _createSuper(CanisterActor);\n\n        function CanisterActor(config) {\n          var _this4;\n\n          _classCallCheck(this, CanisterActor);\n\n          var canisterId = typeof config.canisterId === 'string' ? Principal.fromText(config.canisterId) : config.canisterId;\n          _this4 = _super4.call(this, {\n            config: Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), config), {\n              canisterId: canisterId\n            }),\n            service: service\n          });\n\n          var _iterator = _createForOfIteratorHelper(service._fields),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _step$value = _slicedToArray(_step.value, 2),\n                  methodName = _step$value[0],\n                  func = _step$value[1];\n\n              _this4[methodName] = _createActorMethod(_assertThisInitialized(_this4), methodName, func);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          return _this4;\n        }\n\n        return CanisterActor;\n      }(Actor);\n\n      return CanisterActor;\n    }\n  }, {\n    key: \"createActor\",\n    value: function createActor(interfaceFactory, configuration) {\n      return new (this.createActorClass(interfaceFactory))(configuration);\n    }\n  }]);\n\n  return Actor;\n}(); // IDL functions can have multiple return values, so decoding always\n// produces an array. Ensure that functions with single or zero return\n// values behave as expected.\n\nfunction decodeReturnValue(types, msg) {\n  var returnValues = IDL.decode(types, Buffer.from(msg));\n\n  switch (returnValues.length) {\n    case 0:\n      return undefined;\n\n    case 1:\n      return returnValues[0];\n\n    default:\n      return returnValues;\n  }\n}\n\nvar DEFAULT_ACTOR_CONFIG = {\n  pollingStrategyFactory: strategy.defaultStrategy\n};\n\nfunction _createActorMethod(actor, methodName, func) {\n  var caller;\n\n  if (func.annotations.includes('query')) {\n    caller = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(options) {\n        var _a,\n            _b,\n            _len,\n            args,\n            _key,\n            agent,\n            cid,\n            arg,\n            result,\n            _args4 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                for (_len = _args4.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                  args[_key - 1] = _args4[_key];\n                }\n\n                // First, if there's a config transformation, call it.\n                options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).queryTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));\n                agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();\n                cid = Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);\n                arg = IDL.encode(func.argTypes, args);\n                _context4.next = 7;\n                return agent.query(cid, {\n                  methodName: methodName,\n                  arg: arg\n                });\n\n              case 7:\n                result = _context4.sent;\n                _context4.t0 = result.status;\n                _context4.next = _context4.t0 === \"rejected\"\n                /* Rejected */\n                ? 11 : _context4.t0 === \"replied\"\n                /* Replied */\n                ? 12 : 13;\n                break;\n\n              case 11:\n                throw new QueryCallRejectedError(cid, methodName, result);\n\n              case 12:\n                return _context4.abrupt(\"return\", decodeReturnValue(func.retTypes, result.reply.arg));\n\n              case 13:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      return function caller(_x7) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n  } else {\n    caller = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(options) {\n        var _a,\n            _b,\n            _len2,\n            args,\n            _key2,\n            agent,\n            _Object$assign,\n            canisterId,\n            effectiveCanisterId,\n            pollingStrategyFactory,\n            cid,\n            ecid,\n            arg,\n            _yield$agent$call,\n            requestId,\n            response,\n            pollStrategy,\n            responseBytes,\n            _args5 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                for (_len2 = _args5.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                  args[_key2 - 1] = _args5[_key2];\n                }\n\n                // First, if there's a config transformation, call it.\n                options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).callTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));\n                agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();\n                _Object$assign = Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), actor[metadataSymbol].config), options), canisterId = _Object$assign.canisterId, effectiveCanisterId = _Object$assign.effectiveCanisterId, pollingStrategyFactory = _Object$assign.pollingStrategyFactory;\n                cid = Principal.from(canisterId);\n                ecid = effectiveCanisterId !== undefined ? Principal.from(effectiveCanisterId) : cid;\n                arg = IDL.encode(func.argTypes, args);\n                _context5.next = 9;\n                return agent.call(cid, {\n                  methodName: methodName,\n                  arg: arg,\n                  effectiveCanisterId: ecid\n                });\n\n              case 9:\n                _yield$agent$call = _context5.sent;\n                requestId = _yield$agent$call.requestId;\n                response = _yield$agent$call.response;\n\n                if (response.ok) {\n                  _context5.next = 14;\n                  break;\n                }\n\n                throw new UpdateCallRejectedError(cid, methodName, requestId, response);\n\n              case 14:\n                pollStrategy = pollingStrategyFactory();\n                _context5.next = 17;\n                return pollForResponse(agent, ecid, requestId, pollStrategy);\n\n              case 17:\n                responseBytes = _context5.sent;\n\n                if (!(responseBytes !== undefined)) {\n                  _context5.next = 22;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", decodeReturnValue(func.retTypes, responseBytes));\n\n              case 22:\n                if (!(func.retTypes.length === 0)) {\n                  _context5.next = 26;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", undefined);\n\n              case 26:\n                throw new Error(\"Call was returned undefined, but type [\".concat(func.retTypes.join(','), \"].\"));\n\n              case 27:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n\n      return function caller(_x8) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n  }\n\n  var handler = function handler() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    return caller.apply(void 0, [{}].concat(args));\n  };\n\n  handler.withOptions = function (options) {\n    return function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      return caller.apply(void 0, [options].concat(args));\n    };\n  };\n\n  return handler;\n}","map":{"version":3,"sources":["../../src/actor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Buffer } from 'buffer/';\nimport { getDefaultAgent, ReplicaRejectCode, } from './agent';\nimport { getManagementCanister } from './canisters/management';\nimport { AgentError } from './errors';\nimport { IDL } from '@dfinity/candid';\nimport { pollForResponse, strategy } from './polling';\nimport { Principal } from '@dfinity/principal';\nimport { toHex } from './utils/buffer';\nexport class ActorCallError extends AgentError {\n    constructor(canisterId, methodName, type, props) {\n        super([\n            `Call failed:`,\n            `  Canister: ${canisterId.toText()}`,\n            `  Method: ${methodName} (${type})`,\n            ...Object.getOwnPropertyNames(props).map(n => `  \"${n}\": ${JSON.stringify(props[n])}`),\n        ].join('\\n'));\n        this.canisterId = canisterId;\n        this.methodName = methodName;\n        this.type = type;\n        this.props = props;\n    }\n}\nexport class QueryCallRejectedError extends ActorCallError {\n    constructor(canisterId, methodName, result) {\n        var _a;\n        super(canisterId, methodName, 'query', {\n            Status: result.status,\n            Code: (_a = ReplicaRejectCode[result.reject_code]) !== null && _a !== void 0 ? _a : `Unknown Code \"${result.reject_code}\"`,\n            Message: result.reject_message,\n        });\n        this.result = result;\n    }\n}\nexport class UpdateCallRejectedError extends ActorCallError {\n    constructor(canisterId, methodName, requestId, response) {\n        super(canisterId, methodName, 'update', {\n            'Request ID': toHex(requestId),\n            'HTTP status code': response.status.toString(),\n            'HTTP status text': response.statusText,\n        });\n        this.requestId = requestId;\n        this.response = response;\n    }\n}\n/**\n * The mode used when installing a canister.\n */\nexport var CanisterInstallMode;\n(function (CanisterInstallMode) {\n    CanisterInstallMode[\"Install\"] = \"install\";\n    CanisterInstallMode[\"Reinstall\"] = \"reinstall\";\n    CanisterInstallMode[\"Upgrade\"] = \"upgrade\";\n})(CanisterInstallMode || (CanisterInstallMode = {}));\nconst metadataSymbol = Symbol.for('ic-agent-metadata');\n/**\n * An actor base class. An actor is an object containing only functions that will\n * return a promise. These functions are derived from the IDL definition.\n */\nexport class Actor {\n    constructor(metadata) {\n        this[metadataSymbol] = Object.freeze(metadata);\n    }\n    /**\n     * Get the Agent class this Actor would call, or undefined if the Actor would use\n     * the default agent (global.ic.agent).\n     * @param actor The actor to get the agent of.\n     */\n    static agentOf(actor) {\n        return actor[metadataSymbol].config.agent;\n    }\n    /**\n     * Get the interface of an actor, in the form of an instance of a Service.\n     * @param actor The actor to get the interface of.\n     */\n    static interfaceOf(actor) {\n        return actor[metadataSymbol].service;\n    }\n    static canisterIdOf(actor) {\n        return Principal.from(actor[metadataSymbol].config.canisterId);\n    }\n    static async install(fields, config) {\n        const mode = fields.mode === undefined ? CanisterInstallMode.Install : fields.mode;\n        // Need to transform the arg into a number array.\n        const arg = fields.arg ? [...new Uint8Array(fields.arg)] : [];\n        // Same for module.\n        const wasmModule = [...new Uint8Array(fields.module)];\n        const canisterId = typeof config.canisterId === 'string'\n            ? Principal.fromText(config.canisterId)\n            : config.canisterId;\n        await getManagementCanister(config).install_code({\n            mode: { [mode]: null },\n            arg,\n            wasm_module: wasmModule,\n            canister_id: canisterId,\n        });\n    }\n    static async createCanister(config) {\n        const { canister_id: canisterId } = await getManagementCanister(config || {}).provisional_create_canister_with_cycles({ amount: [], settings: [] });\n        return canisterId;\n    }\n    static async createAndInstallCanister(interfaceFactory, fields, config) {\n        const canisterId = await this.createCanister(config);\n        await this.install(Object.assign({}, fields), Object.assign(Object.assign({}, config), { canisterId }));\n        return this.createActor(interfaceFactory, Object.assign(Object.assign({}, config), { canisterId }));\n    }\n    static createActorClass(interfaceFactory) {\n        const service = interfaceFactory({ IDL });\n        class CanisterActor extends Actor {\n            constructor(config) {\n                const canisterId = typeof config.canisterId === 'string'\n                    ? Principal.fromText(config.canisterId)\n                    : config.canisterId;\n                super({\n                    config: Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), config), { canisterId }),\n                    service,\n                });\n                for (const [methodName, func] of service._fields) {\n                    this[methodName] = _createActorMethod(this, methodName, func);\n                }\n            }\n        }\n        return CanisterActor;\n    }\n    static createActor(interfaceFactory, configuration) {\n        return new (this.createActorClass(interfaceFactory))(configuration);\n    }\n}\n// IDL functions can have multiple return values, so decoding always\n// produces an array. Ensure that functions with single or zero return\n// values behave as expected.\nfunction decodeReturnValue(types, msg) {\n    const returnValues = IDL.decode(types, Buffer.from(msg));\n    switch (returnValues.length) {\n        case 0:\n            return undefined;\n        case 1:\n            return returnValues[0];\n        default:\n            return returnValues;\n    }\n}\nconst DEFAULT_ACTOR_CONFIG = {\n    pollingStrategyFactory: strategy.defaultStrategy,\n};\nfunction _createActorMethod(actor, methodName, func) {\n    let caller;\n    if (func.annotations.includes('query')) {\n        caller = async (options, ...args) => {\n            var _a, _b;\n            // First, if there's a config transformation, call it.\n            options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).queryTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));\n            const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();\n            const cid = Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);\n            const arg = IDL.encode(func.argTypes, args);\n            const result = await agent.query(cid, { methodName, arg });\n            switch (result.status) {\n                case \"rejected\" /* Rejected */:\n                    throw new QueryCallRejectedError(cid, methodName, result);\n                case \"replied\" /* Replied */:\n                    return decodeReturnValue(func.retTypes, result.reply.arg);\n            }\n        };\n    }\n    else {\n        caller = async (options, ...args) => {\n            var _a, _b;\n            // First, if there's a config transformation, call it.\n            options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).callTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));\n            const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();\n            const { canisterId, effectiveCanisterId, pollingStrategyFactory } = Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), actor[metadataSymbol].config), options);\n            const cid = Principal.from(canisterId);\n            const ecid = effectiveCanisterId !== undefined ? Principal.from(effectiveCanisterId) : cid;\n            const arg = IDL.encode(func.argTypes, args);\n            const { requestId, response } = await agent.call(cid, {\n                methodName,\n                arg,\n                effectiveCanisterId: ecid,\n            });\n            if (!response.ok) {\n                throw new UpdateCallRejectedError(cid, methodName, requestId, response);\n            }\n            const pollStrategy = pollingStrategyFactory();\n            const responseBytes = await pollForResponse(agent, ecid, requestId, pollStrategy);\n            if (responseBytes !== undefined) {\n                return decodeReturnValue(func.retTypes, responseBytes);\n            }\n            else if (func.retTypes.length === 0) {\n                return undefined;\n            }\n            else {\n                throw new Error(`Call was returned undefined, but type [${func.retTypes.join(',')}].`);\n            }\n        };\n    }\n    const handler = (...args) => caller({}, ...args);\n    handler.withOptions =\n        (options) => (...args) => caller(options, ...args);\n    return handler;\n}\n//# sourceMappingURL=actor.js.map"]},"metadata":{},"sourceType":"module"}