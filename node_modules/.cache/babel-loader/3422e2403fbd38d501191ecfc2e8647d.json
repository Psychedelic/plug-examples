{"ast":null,"code":"import _defineProperty from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _inherits from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n// tslint:disable:max-classes-per-file\n// This file is based on:\n// tslint:disable-next-line: max-line-length\n// https://github.com/dfinity-lab/dfinity/blob/9bca65f8edd65701ea6bdb00e0752f9186bbc893/docs/spec/public/index.adoc#cbor-encoding-of-requests-and-responses\nimport borc from 'borc';\nimport * as cbor from 'simple-cbor';\nimport { SelfDescribeCborSerializer } from 'simple-cbor';\nimport { concat, fromHex } from './utils/buffer'; // We are using hansl/simple-cbor for CBOR serialization, to avoid issues with\n// encoding the uint64 values that the HTTP handler of the client expects for\n// canister IDs. However, simple-cbor does not yet provide deserialization so\n// we are using `Uint8Array` so that we can use the dignifiedquire/borc CBOR\n// decoder.\n\nvar PrincipalEncoder = /*#__PURE__*/function () {\n  function PrincipalEncoder() {\n    _classCallCheck(this, PrincipalEncoder);\n  }\n\n  _createClass(PrincipalEncoder, [{\n    key: \"name\",\n    get: function get() {\n      return 'Principal';\n    }\n  }, {\n    key: \"priority\",\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: \"match\",\n    value: function match(value) {\n      return value && value._isPrincipal === true;\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(v) {\n      return cbor.value.bytes(v.toUint8Array());\n    }\n  }]);\n\n  return PrincipalEncoder;\n}();\n\nvar BufferEncoder = /*#__PURE__*/function () {\n  function BufferEncoder() {\n    _classCallCheck(this, BufferEncoder);\n  }\n\n  _createClass(BufferEncoder, [{\n    key: \"name\",\n    get: function get() {\n      return 'Buffer';\n    }\n  }, {\n    key: \"priority\",\n    get: function get() {\n      return 1;\n    }\n  }, {\n    key: \"match\",\n    value: function match(value) {\n      return value instanceof ArrayBuffer || ArrayBuffer.isView(value);\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(v) {\n      return cbor.value.bytes(new Uint8Array(v));\n    }\n  }]);\n\n  return BufferEncoder;\n}();\n\nvar BigIntEncoder = /*#__PURE__*/function () {\n  function BigIntEncoder() {\n    _classCallCheck(this, BigIntEncoder);\n  }\n\n  _createClass(BigIntEncoder, [{\n    key: \"name\",\n    get: function get() {\n      return 'BigInt';\n    }\n  }, {\n    key: \"priority\",\n    get: function get() {\n      return 1;\n    }\n  }, {\n    key: \"match\",\n    value: function match(value) {\n      return typeof value === \"bigint\";\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(v) {\n      // Always use a bigint encoding.\n      if (v > BigInt(0)) {\n        return cbor.value.tagged(2, cbor.value.bytes(fromHex(v.toString(16))));\n      } else {\n        return cbor.value.tagged(3, cbor.value.bytes(fromHex((BigInt('-1') * v).toString(16))));\n      }\n    }\n  }]);\n\n  return BigIntEncoder;\n}();\n\nvar serializer = SelfDescribeCborSerializer.withDefaultEncoders(true);\nserializer.addEncoder(new PrincipalEncoder());\nserializer.addEncoder(new BufferEncoder());\nserializer.addEncoder(new BigIntEncoder());\nexport var CborTag;\n\n(function (CborTag) {\n  CborTag[CborTag[\"Uint64LittleEndian\"] = 71] = \"Uint64LittleEndian\";\n  CborTag[CborTag[\"Semantic\"] = 55799] = \"Semantic\";\n})(CborTag || (CborTag = {}));\n/**\n * Encode a JavaScript value into CBOR.\n */\n\n\nexport function encode(value) {\n  return serializer.serialize(value);\n}\n\nfunction decodePositiveBigInt(buf) {\n  var len = buf.byteLength;\n  var res = BigInt(0);\n\n  for (var i = 0; i < len; i++) {\n    // tslint:disable-next-line:no-bitwise\n    res = res * BigInt(0x100) + BigInt(buf[i]);\n  }\n\n  return res;\n} // A BORC subclass that decodes byte strings to ArrayBuffer instead of the Buffer class.\n\n\nvar Uint8ArrayDecoder = /*#__PURE__*/function (_borc$Decoder) {\n  _inherits(Uint8ArrayDecoder, _borc$Decoder);\n\n  var _super = _createSuper(Uint8ArrayDecoder);\n\n  function Uint8ArrayDecoder() {\n    _classCallCheck(this, Uint8ArrayDecoder);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Uint8ArrayDecoder, [{\n    key: \"createByteString\",\n    value: function createByteString(raw) {\n      return concat.apply(void 0, _toConsumableArray(raw));\n    }\n  }, {\n    key: \"createByteStringFromHeap\",\n    value: function createByteStringFromHeap(start, end) {\n      if (start === end) {\n        return new ArrayBuffer(0);\n      }\n\n      return new Uint8Array(this._heap.slice(start, end));\n    }\n  }]);\n\n  return Uint8ArrayDecoder;\n}(borc.Decoder);\n\nexport function decode(input) {\n  var buffer = new Uint8Array(input);\n  var decoder = new Uint8ArrayDecoder({\n    size: buffer.byteLength,\n    tags: _defineProperty({\n      // Override tags 2 and 3 for BigInt support (borc supports only BigNumber).\n      2: function _(val) {\n        return decodePositiveBigInt(val);\n      },\n      3: function _(val) {\n        return -decodePositiveBigInt(val);\n      }\n    }, CborTag.Semantic, function (value) {\n      return value;\n    })\n  });\n  return decoder.decodeFirst(buffer);\n}","map":{"version":3,"sources":["../../src/cbor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// tslint:disable:max-classes-per-file\n// This file is based on:\n// tslint:disable-next-line: max-line-length\n// https://github.com/dfinity-lab/dfinity/blob/9bca65f8edd65701ea6bdb00e0752f9186bbc893/docs/spec/public/index.adoc#cbor-encoding-of-requests-and-responses\nimport borc from 'borc';\nimport * as cbor from 'simple-cbor';\nimport { SelfDescribeCborSerializer } from 'simple-cbor';\nimport { concat, fromHex } from './utils/buffer';\n// We are using hansl/simple-cbor for CBOR serialization, to avoid issues with\n// encoding the uint64 values that the HTTP handler of the client expects for\n// canister IDs. However, simple-cbor does not yet provide deserialization so\n// we are using `Uint8Array` so that we can use the dignifiedquire/borc CBOR\n// decoder.\nclass PrincipalEncoder {\n    get name() {\n        return 'Principal';\n    }\n    get priority() {\n        return 0;\n    }\n    match(value) {\n        return value && value._isPrincipal === true;\n    }\n    encode(v) {\n        return cbor.value.bytes(v.toUint8Array());\n    }\n}\nclass BufferEncoder {\n    get name() {\n        return 'Buffer';\n    }\n    get priority() {\n        return 1;\n    }\n    match(value) {\n        return value instanceof ArrayBuffer || ArrayBuffer.isView(value);\n    }\n    encode(v) {\n        return cbor.value.bytes(new Uint8Array(v));\n    }\n}\nclass BigIntEncoder {\n    get name() {\n        return 'BigInt';\n    }\n    get priority() {\n        return 1;\n    }\n    match(value) {\n        return typeof value === `bigint`;\n    }\n    encode(v) {\n        // Always use a bigint encoding.\n        if (v > BigInt(0)) {\n            return cbor.value.tagged(2, cbor.value.bytes(fromHex(v.toString(16))));\n        }\n        else {\n            return cbor.value.tagged(3, cbor.value.bytes(fromHex((BigInt('-1') * v).toString(16))));\n        }\n    }\n}\nconst serializer = SelfDescribeCborSerializer.withDefaultEncoders(true);\nserializer.addEncoder(new PrincipalEncoder());\nserializer.addEncoder(new BufferEncoder());\nserializer.addEncoder(new BigIntEncoder());\nexport var CborTag;\n(function (CborTag) {\n    CborTag[CborTag[\"Uint64LittleEndian\"] = 71] = \"Uint64LittleEndian\";\n    CborTag[CborTag[\"Semantic\"] = 55799] = \"Semantic\";\n})(CborTag || (CborTag = {}));\n/**\n * Encode a JavaScript value into CBOR.\n */\nexport function encode(value) {\n    return serializer.serialize(value);\n}\nfunction decodePositiveBigInt(buf) {\n    const len = buf.byteLength;\n    let res = BigInt(0);\n    for (let i = 0; i < len; i++) {\n        // tslint:disable-next-line:no-bitwise\n        res = res * BigInt(0x100) + BigInt(buf[i]);\n    }\n    return res;\n}\n// A BORC subclass that decodes byte strings to ArrayBuffer instead of the Buffer class.\nclass Uint8ArrayDecoder extends borc.Decoder {\n    createByteString(raw) {\n        return concat(...raw);\n    }\n    createByteStringFromHeap(start, end) {\n        if (start === end) {\n            return new ArrayBuffer(0);\n        }\n        return new Uint8Array(this._heap.slice(start, end));\n    }\n}\nexport function decode(input) {\n    const buffer = new Uint8Array(input);\n    const decoder = new Uint8ArrayDecoder({\n        size: buffer.byteLength,\n        tags: {\n            // Override tags 2 and 3 for BigInt support (borc supports only BigNumber).\n            2: val => decodePositiveBigInt(val),\n            3: val => -decodePositiveBigInt(val),\n            [CborTag.Semantic]: (value) => value,\n        },\n    });\n    return decoder.decodeFirst(buffer);\n}\n//# sourceMappingURL=cbor.js.map"]},"metadata":{},"sourceType":"module"}