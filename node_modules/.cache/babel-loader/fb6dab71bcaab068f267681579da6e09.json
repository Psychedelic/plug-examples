{"ast":null,"code":"import _classCallCheck from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * Concatenate multiple array buffers.\n * @param buffers The buffers to concatenate.\n */\nexport function concat() {\n  for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) {\n    buffers[_key] = arguments[_key];\n  }\n\n  var result = new Uint8Array(buffers.reduce(function (acc, curr) {\n    return acc + curr.byteLength;\n  }, 0));\n  var index = 0;\n\n  for (var _i = 0, _buffers = buffers; _i < _buffers.length; _i++) {\n    var b = _buffers[_i];\n    result.set(new Uint8Array(b), index);\n    index += b.byteLength;\n  }\n\n  return result;\n}\n/**\n * Returns an hexadecimal representation of an array buffer.\n * @param bytes The array buffer.\n */\n\nexport function toHexString(bytes) {\n  return new Uint8Array(bytes).reduce(function (str, byte) {\n    return str + byte.toString(16).padStart(2, '0');\n  }, '');\n}\n/**\n * Return an array buffer from its hexadecimal representation.\n * @param hexString The hexadecimal string.\n */\n\nexport function fromHexString(hexString) {\n  var _a;\n\n  return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== void 0 ? _a : []).map(function (byte) {\n    return parseInt(byte, 16);\n  }));\n}\n/**\n * A class that abstracts a pipe-like ArrayBuffer.\n */\n\nexport var PipeArrayBuffer = /*#__PURE__*/function () {\n  /**\n   * Creates a new instance of a pipe\n   * @param buffer an optional buffer to start with\n   * @param length an optional amount of bytes to use for the length.\n   */\n  function PipeArrayBuffer(buffer) {\n    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (buffer === null || buffer === void 0 ? void 0 : buffer.byteLength) || 0;\n\n    _classCallCheck(this, PipeArrayBuffer);\n\n    this._buffer = buffer || new ArrayBuffer(0);\n    this._view = new Uint8Array(this._buffer, 0, length);\n  }\n\n  _createClass(PipeArrayBuffer, [{\n    key: \"buffer\",\n    get: function get() {\n      // Return a copy of the buffer.\n      return this._view.slice();\n    }\n  }, {\n    key: \"byteLength\",\n    get: function get() {\n      return this._view.byteLength;\n    }\n    /**\n     * Read `num` number of bytes from the front of the pipe.\n     * @param num The number of bytes to read.\n     */\n\n  }, {\n    key: \"read\",\n    value: function read(num) {\n      var result = this._view.subarray(0, num);\n\n      this._view = this._view.subarray(num);\n      return result.slice().buffer;\n    }\n  }, {\n    key: \"readUint8\",\n    value: function readUint8() {\n      var result = this._view[0];\n      this._view = this._view.subarray(1);\n      return result;\n    }\n    /**\n     * Write a buffer to the end of the pipe.\n     * @param buf The bytes to write.\n     */\n\n  }, {\n    key: \"write\",\n    value: function write(buf) {\n      var b = new Uint8Array(buf);\n      var offset = this._view.byteLength;\n\n      if (this._view.byteOffset + this._view.byteLength + b.byteLength >= this._buffer.byteLength) {\n        // Alloc grow the view to include the new bytes.\n        this.alloc(b.byteLength);\n      } else {\n        // Update the view to include the new bytes.\n        this._view = new Uint8Array(this._buffer, this._view.byteOffset, this._view.byteLength + b.byteLength);\n      }\n\n      this._view.set(b, offset);\n    }\n    /**\n     * Whether or not there is more data to read from the buffer\n     */\n\n  }, {\n    key: \"end\",\n    get: function get() {\n      return this._view.byteLength === 0;\n    }\n    /**\n     * Allocate a fixed amount of memory in the buffer. This does not affect the view.\n     * @param amount A number of bytes to add to the buffer.\n     */\n\n  }, {\n    key: \"alloc\",\n    value: function alloc(amount) {\n      // Add a little bit of exponential growth.\n      // tslint:disable-next-line:no-bitwise\n      var b = new ArrayBuffer((this._buffer.byteLength + amount) * 1.2 | 0);\n      var v = new Uint8Array(b, 0, this._view.byteLength + amount);\n      v.set(this._view);\n      this._buffer = b;\n      this._view = v;\n    }\n  }]);\n\n  return PipeArrayBuffer;\n}();","map":{"version":3,"sources":["../../../src/utils/buffer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * Concatenate multiple array buffers.\n * @param buffers The buffers to concatenate.\n */\nexport function concat(...buffers) {\n    const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));\n    let index = 0;\n    for (const b of buffers) {\n        result.set(new Uint8Array(b), index);\n        index += b.byteLength;\n    }\n    return result;\n}\n/**\n * Returns an hexadecimal representation of an array buffer.\n * @param bytes The array buffer.\n */\nexport function toHexString(bytes) {\n    return new Uint8Array(bytes).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n/**\n * Return an array buffer from its hexadecimal representation.\n * @param hexString The hexadecimal string.\n */\nexport function fromHexString(hexString) {\n    var _a;\n    return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== void 0 ? _a : []).map(byte => parseInt(byte, 16)));\n}\n/**\n * A class that abstracts a pipe-like ArrayBuffer.\n */\nexport class PipeArrayBuffer {\n    /**\n     * Creates a new instance of a pipe\n     * @param buffer an optional buffer to start with\n     * @param length an optional amount of bytes to use for the length.\n     */\n    constructor(buffer, length = (buffer === null || buffer === void 0 ? void 0 : buffer.byteLength) || 0) {\n        this._buffer = buffer || new ArrayBuffer(0);\n        this._view = new Uint8Array(this._buffer, 0, length);\n    }\n    get buffer() {\n        // Return a copy of the buffer.\n        return this._view.slice();\n    }\n    get byteLength() {\n        return this._view.byteLength;\n    }\n    /**\n     * Read `num` number of bytes from the front of the pipe.\n     * @param num The number of bytes to read.\n     */\n    read(num) {\n        const result = this._view.subarray(0, num);\n        this._view = this._view.subarray(num);\n        return result.slice().buffer;\n    }\n    readUint8() {\n        const result = this._view[0];\n        this._view = this._view.subarray(1);\n        return result;\n    }\n    /**\n     * Write a buffer to the end of the pipe.\n     * @param buf The bytes to write.\n     */\n    write(buf) {\n        const b = new Uint8Array(buf);\n        const offset = this._view.byteLength;\n        if (this._view.byteOffset + this._view.byteLength + b.byteLength >= this._buffer.byteLength) {\n            // Alloc grow the view to include the new bytes.\n            this.alloc(b.byteLength);\n        }\n        else {\n            // Update the view to include the new bytes.\n            this._view = new Uint8Array(this._buffer, this._view.byteOffset, this._view.byteLength + b.byteLength);\n        }\n        this._view.set(b, offset);\n    }\n    /**\n     * Whether or not there is more data to read from the buffer\n     */\n    get end() {\n        return this._view.byteLength === 0;\n    }\n    /**\n     * Allocate a fixed amount of memory in the buffer. This does not affect the view.\n     * @param amount A number of bytes to add to the buffer.\n     */\n    alloc(amount) {\n        // Add a little bit of exponential growth.\n        // tslint:disable-next-line:no-bitwise\n        const b = new ArrayBuffer(((this._buffer.byteLength + amount) * 1.2) | 0);\n        const v = new Uint8Array(b, 0, this._view.byteLength + amount);\n        v.set(this._view);\n        this._buffer = b;\n        this._view = v;\n    }\n}\n//# sourceMappingURL=buffer.js.map"]},"metadata":{},"sourceType":"module"}