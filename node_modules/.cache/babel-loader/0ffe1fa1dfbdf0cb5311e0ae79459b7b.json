{"ast":null,"code":"// tslint:disable:max-classes-per-file\nimport { Principal as PrincipalId } from '@dfinity/principal';\nimport { concat, PipeArrayBuffer as Pipe } from './utils/buffer';\nimport { idlLabelToId } from './utils/hash';\nimport { lebDecode, lebEncode, safeRead, safeReadUint8, slebDecode, slebEncode } from './utils/leb128';\nimport { readIntLE, readUIntLE, writeIntLE, writeUIntLE } from './utils/leb128';\nconst magicNumber = 'DIDL';\n\nfunction zipWith(xs, ys, f) {\n  return xs.map((x, i) => f(x, ys[i]));\n}\n/**\n * An IDL Type Table, which precedes the data in the stream.\n */\n\n\nclass TypeTable {\n  constructor() {\n    // List of types. Needs to be an array as the index needs to be stable.\n    this._typs = [];\n    this._idx = new Map();\n  }\n\n  has(obj) {\n    return this._idx.has(obj.name);\n  }\n\n  add(type, buf) {\n    const idx = this._typs.length;\n\n    this._idx.set(type.name, idx);\n\n    this._typs.push(buf);\n  }\n\n  merge(obj, knot) {\n    const idx = this._idx.get(obj.name);\n\n    const knotIdx = this._idx.get(knot);\n\n    if (idx === undefined) {\n      throw new Error('Missing type index for ' + obj);\n    }\n\n    if (knotIdx === undefined) {\n      throw new Error('Missing type index for ' + knot);\n    }\n\n    this._typs[idx] = this._typs[knotIdx]; // Delete the type.\n\n    this._typs.splice(knotIdx, 1);\n\n    this._idx.delete(knot);\n  }\n\n  encode() {\n    const len = lebEncode(this._typs.length);\n    const buf = concat(...this._typs);\n    return concat(len, buf);\n  }\n\n  indexOf(typeName) {\n    if (!this._idx.has(typeName)) {\n      throw new Error('Missing type index for ' + typeName);\n    }\n\n    return slebEncode(this._idx.get(typeName) || 0);\n  }\n\n}\n\nexport class Visitor {\n  visitType(t, data) {\n    throw new Error('Not implemented');\n  }\n\n  visitPrimitive(t, data) {\n    return this.visitType(t, data);\n  }\n\n  visitEmpty(t, data) {\n    return this.visitPrimitive(t, data);\n  }\n\n  visitBool(t, data) {\n    return this.visitPrimitive(t, data);\n  }\n\n  visitNull(t, data) {\n    return this.visitPrimitive(t, data);\n  }\n\n  visitReserved(t, data) {\n    return this.visitPrimitive(t, data);\n  }\n\n  visitText(t, data) {\n    return this.visitPrimitive(t, data);\n  }\n\n  visitNumber(t, data) {\n    return this.visitPrimitive(t, data);\n  }\n\n  visitInt(t, data) {\n    return this.visitNumber(t, data);\n  }\n\n  visitNat(t, data) {\n    return this.visitNumber(t, data);\n  }\n\n  visitFloat(t, data) {\n    return this.visitPrimitive(t, data);\n  }\n\n  visitFixedInt(t, data) {\n    return this.visitNumber(t, data);\n  }\n\n  visitFixedNat(t, data) {\n    return this.visitNumber(t, data);\n  }\n\n  visitPrincipal(t, data) {\n    return this.visitPrimitive(t, data);\n  }\n\n  visitConstruct(t, data) {\n    return this.visitType(t, data);\n  }\n\n  visitVec(t, ty, data) {\n    return this.visitConstruct(t, data);\n  }\n\n  visitOpt(t, ty, data) {\n    return this.visitConstruct(t, data);\n  }\n\n  visitRecord(t, fields, data) {\n    return this.visitConstruct(t, data);\n  }\n\n  visitTuple(t, components, data) {\n    const fields = components.map((ty, i) => [`_${i}_`, ty]);\n    return this.visitRecord(t, fields, data);\n  }\n\n  visitVariant(t, fields, data) {\n    return this.visitConstruct(t, data);\n  }\n\n  visitRec(t, ty, data) {\n    return this.visitConstruct(ty, data);\n  }\n\n  visitFunc(t, data) {\n    return this.visitConstruct(t, data);\n  }\n\n  visitService(t, data) {\n    return this.visitConstruct(t, data);\n  }\n\n}\n/**\n * Represents an IDL type.\n */\n\nexport class Type {\n  /* Display type name */\n  display() {\n    return this.name;\n  }\n\n  valueToString(x) {\n    return toReadableString(x);\n  }\n  /* Implement `T` in the IDL spec, only needed for non-primitive types */\n\n\n  buildTypeTable(typeTable) {\n    if (!typeTable.has(this)) {\n      this._buildTypeTableImpl(typeTable);\n    }\n  }\n\n}\nexport class PrimitiveType extends Type {\n  checkType(t) {\n    if (this.name !== t.name) {\n      throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n    }\n\n    return t;\n  }\n\n  _buildTypeTableImpl(typeTable) {\n    // No type table encoding for Primitive types.\n    return;\n  }\n\n}\nexport class ConstructType extends Type {\n  checkType(t) {\n    if (t instanceof RecClass) {\n      const ty = t.getType();\n\n      if (typeof ty === 'undefined') {\n        throw new Error('type mismatch with uninitialized type');\n      }\n\n      return ty;\n    }\n\n    throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n  }\n\n  encodeType(typeTable) {\n    return typeTable.indexOf(this.name);\n  }\n\n}\n/**\n * Represents an IDL Empty, a type which has no inhabitants.\n * Since no values exist for this type, it cannot be serialised or deserialised.\n * Result types like `Result<Text, Empty>` should always succeed.\n */\n\nexport class EmptyClass extends PrimitiveType {\n  accept(v, d) {\n    return v.visitEmpty(this, d);\n  }\n\n  covariant(x) {\n    return false;\n  }\n\n  encodeValue() {\n    throw new Error('Empty cannot appear as a function argument');\n  }\n\n  valueToString() {\n    throw new Error('Empty cannot appear as a value');\n  }\n\n  encodeType() {\n    return slebEncode(-17\n    /* Empty */\n    );\n  }\n\n  decodeValue() {\n    throw new Error('Empty cannot appear as an output');\n  }\n\n  get name() {\n    return 'empty';\n  }\n\n}\n/**\n * Represents an IDL Bool\n */\n\nexport class BoolClass extends PrimitiveType {\n  accept(v, d) {\n    return v.visitBool(this, d);\n  }\n\n  covariant(x) {\n    return typeof x === 'boolean';\n  }\n\n  encodeValue(x) {\n    return new Uint8Array([x ? 1 : 0]);\n  }\n\n  encodeType() {\n    return slebEncode(-2\n    /* Bool */\n    );\n  }\n\n  decodeValue(b, t) {\n    this.checkType(t);\n\n    switch (safeReadUint8(b)) {\n      case 0:\n        return false;\n\n      case 1:\n        return true;\n\n      default:\n        throw new Error('Boolean value out of range');\n    }\n  }\n\n  get name() {\n    return 'bool';\n  }\n\n}\n/**\n * Represents an IDL Null\n */\n\nexport class NullClass extends PrimitiveType {\n  accept(v, d) {\n    return v.visitNull(this, d);\n  }\n\n  covariant(x) {\n    return x === null;\n  }\n\n  encodeValue() {\n    return new ArrayBuffer(0);\n  }\n\n  encodeType() {\n    return slebEncode(-1\n    /* Null */\n    );\n  }\n\n  decodeValue(b, t) {\n    this.checkType(t);\n    return null;\n  }\n\n  get name() {\n    return 'null';\n  }\n\n}\n/**\n * Represents an IDL Reserved\n */\n\nexport class ReservedClass extends PrimitiveType {\n  accept(v, d) {\n    return v.visitReserved(this, d);\n  }\n\n  covariant(x) {\n    return true;\n  }\n\n  encodeValue() {\n    return new ArrayBuffer(0);\n  }\n\n  encodeType() {\n    return slebEncode(-16\n    /* Reserved */\n    );\n  }\n\n  decodeValue(b, t) {\n    if (t.name !== this.name) {\n      t.decodeValue(b, t);\n    }\n\n    return null;\n  }\n\n  get name() {\n    return 'reserved';\n  }\n\n}\n/**\n * Represents an IDL Text\n */\n\nexport class TextClass extends PrimitiveType {\n  accept(v, d) {\n    return v.visitText(this, d);\n  }\n\n  covariant(x) {\n    return typeof x === 'string';\n  }\n\n  encodeValue(x) {\n    const buf = new TextEncoder().encode(x);\n    const len = lebEncode(buf.byteLength);\n    return concat(len, buf);\n  }\n\n  encodeType() {\n    return slebEncode(-15\n    /* Text */\n    );\n  }\n\n  decodeValue(b, t) {\n    this.checkType(t);\n    const len = lebDecode(b);\n    const buf = safeRead(b, Number(len));\n    const decoder = new TextDecoder('utf8', {\n      fatal: true\n    });\n    return decoder.decode(buf);\n  }\n\n  get name() {\n    return 'text';\n  }\n\n  valueToString(x) {\n    return '\"' + x + '\"';\n  }\n\n}\n/**\n * Represents an IDL Int\n */\n\nexport class IntClass extends PrimitiveType {\n  accept(v, d) {\n    return v.visitInt(this, d);\n  }\n\n  covariant(x) {\n    // We allow encoding of JavaScript plain numbers.\n    // But we will always decode to bigint.\n    return typeof x === 'bigint' || Number.isInteger(x);\n  }\n\n  encodeValue(x) {\n    return slebEncode(x);\n  }\n\n  encodeType() {\n    return slebEncode(-4\n    /* Int */\n    );\n  }\n\n  decodeValue(b, t) {\n    this.checkType(t);\n    return slebDecode(b);\n  }\n\n  get name() {\n    return 'int';\n  }\n\n  valueToString(x) {\n    return x.toString();\n  }\n\n}\n/**\n * Represents an IDL Nat\n */\n\nexport class NatClass extends PrimitiveType {\n  accept(v, d) {\n    return v.visitNat(this, d);\n  }\n\n  covariant(x) {\n    // We allow encoding of JavaScript plain numbers.\n    // But we will always decode to bigint.\n    return typeof x === 'bigint' && x >= BigInt(0) || Number.isInteger(x) && x >= 0;\n  }\n\n  encodeValue(x) {\n    return lebEncode(x);\n  }\n\n  encodeType() {\n    return slebEncode(-3\n    /* Nat */\n    );\n  }\n\n  decodeValue(b, t) {\n    this.checkType(t);\n    return lebDecode(b);\n  }\n\n  get name() {\n    return 'nat';\n  }\n\n  valueToString(x) {\n    return x.toString();\n  }\n\n}\n/**\n * Represents an IDL Float\n */\n\nexport class FloatClass extends PrimitiveType {\n  constructor(_bits) {\n    super();\n    this._bits = _bits;\n\n    if (_bits !== 32 && _bits !== 64) {\n      throw new Error('not a valid float type');\n    }\n  }\n\n  accept(v, d) {\n    return v.visitFloat(this, d);\n  }\n\n  covariant(x) {\n    return typeof x === 'number' || x instanceof Number;\n  }\n\n  encodeValue(x) {\n    const buf = new ArrayBuffer(this._bits / 8);\n    const view = new DataView(buf);\n\n    if (this._bits === 32) {\n      view.setFloat32(0, x, true);\n    } else {\n      view.setFloat64(0, x, true);\n    }\n\n    return buf;\n  }\n\n  encodeType() {\n    const opcode = this._bits === 32 ? -13\n    /* Float32 */\n    : -14\n    /* Float64 */\n    ;\n    return slebEncode(opcode);\n  }\n\n  decodeValue(b, t) {\n    this.checkType(t);\n    const bytes = safeRead(b, this._bits / 8);\n    const view = new DataView(bytes);\n\n    if (this._bits === 32) {\n      return view.getFloat32(0, true);\n    } else {\n      return view.getFloat64(0, true);\n    }\n  }\n\n  get name() {\n    return 'float' + this._bits;\n  }\n\n  valueToString(x) {\n    return x.toString();\n  }\n\n}\n/**\n * Represents an IDL fixed-width Int(n)\n */\n\nexport class FixedIntClass extends PrimitiveType {\n  constructor(_bits) {\n    super();\n    this._bits = _bits;\n  }\n\n  accept(v, d) {\n    return v.visitFixedInt(this, d);\n  }\n\n  covariant(x) {\n    const min = BigInt(2) ** BigInt(this._bits - 1) * BigInt(-1);\n    const max = BigInt(2) ** BigInt(this._bits - 1) - BigInt(1);\n\n    if (typeof x === 'bigint') {\n      return x >= min && x <= max;\n    } else if (Number.isInteger(x)) {\n      const v = BigInt(x);\n      return v >= min && v <= max;\n    } else {\n      return false;\n    }\n  }\n\n  encodeValue(x) {\n    return writeIntLE(x, this._bits / 8);\n  }\n\n  encodeType() {\n    const offset = Math.log2(this._bits) - 3;\n    return slebEncode(-9 - offset);\n  }\n\n  decodeValue(b, t) {\n    this.checkType(t);\n    const num = readIntLE(b, this._bits / 8);\n\n    if (this._bits <= 32) {\n      return Number(num);\n    } else {\n      return num;\n    }\n  }\n\n  get name() {\n    return `int${this._bits}`;\n  }\n\n  valueToString(x) {\n    return x.toString();\n  }\n\n}\n/**\n * Represents an IDL fixed-width Nat(n)\n */\n\nexport class FixedNatClass extends PrimitiveType {\n  constructor(bits) {\n    super();\n    this.bits = bits;\n  }\n\n  accept(v, d) {\n    return v.visitFixedNat(this, d);\n  }\n\n  covariant(x) {\n    const max = BigInt(2) ** BigInt(this.bits);\n\n    if (typeof x === 'bigint' && x >= BigInt(0)) {\n      return x < max;\n    } else if (Number.isInteger(x) && x >= 0) {\n      const v = BigInt(x);\n      return v < max;\n    } else {\n      return false;\n    }\n  }\n\n  encodeValue(x) {\n    return writeUIntLE(x, this.bits / 8);\n  }\n\n  encodeType() {\n    const offset = Math.log2(this.bits) - 3;\n    return slebEncode(-5 - offset);\n  }\n\n  decodeValue(b, t) {\n    this.checkType(t);\n    const num = readUIntLE(b, this.bits / 8);\n\n    if (this.bits <= 32) {\n      return Number(num);\n    } else {\n      return num;\n    }\n  }\n\n  get name() {\n    return `nat${this.bits}`;\n  }\n\n  valueToString(x) {\n    return x.toString();\n  }\n\n}\n/**\n * Represents an IDL Array\n * @param {Type} t\n */\n\nexport class VecClass extends ConstructType {\n  constructor(_type) {\n    super();\n    this._type = _type; // If true, this vector is really a blob and we can just use memcpy.\n\n    this._blobOptimization = false;\n\n    if (_type instanceof FixedNatClass && _type.bits === 8) {\n      this._blobOptimization = true;\n    }\n  }\n\n  accept(v, d) {\n    return v.visitVec(this, this._type, d);\n  }\n\n  covariant(x) {\n    return Array.isArray(x) && x.every(v => this._type.covariant(v));\n  }\n\n  encodeValue(x) {\n    const len = lebEncode(x.length);\n\n    if (this._blobOptimization) {\n      return concat(len, new Uint8Array(x));\n    }\n\n    return concat(len, ...x.map(d => this._type.encodeValue(d)));\n  }\n\n  _buildTypeTableImpl(typeTable) {\n    this._type.buildTypeTable(typeTable);\n\n    const opCode = slebEncode(-19\n    /* Vector */\n    );\n\n    const buffer = this._type.encodeType(typeTable);\n\n    typeTable.add(this, concat(opCode, buffer));\n  }\n\n  decodeValue(b, t) {\n    const vec = this.checkType(t);\n\n    if (!(vec instanceof VecClass)) {\n      throw new Error('Not a vector type');\n    }\n\n    const len = Number(lebDecode(b));\n\n    if (this._blobOptimization) {\n      return [...new Uint8Array(b.read(len))];\n    }\n\n    const rets = [];\n\n    for (let i = 0; i < len; i++) {\n      rets.push(this._type.decodeValue(b, vec._type));\n    }\n\n    return rets;\n  }\n\n  get name() {\n    return `vec ${this._type.name}`;\n  }\n\n  display() {\n    return `vec ${this._type.display()}`;\n  }\n\n  valueToString(x) {\n    const elements = x.map(e => this._type.valueToString(e));\n    return 'vec {' + elements.join('; ') + '}';\n  }\n\n}\n/**\n * Represents an IDL Option\n * @param {Type} t\n */\n\nexport class OptClass extends ConstructType {\n  constructor(_type) {\n    super();\n    this._type = _type;\n  }\n\n  accept(v, d) {\n    return v.visitOpt(this, this._type, d);\n  }\n\n  covariant(x) {\n    return Array.isArray(x) && (x.length === 0 || x.length === 1 && this._type.covariant(x[0]));\n  }\n\n  encodeValue(x) {\n    if (x.length === 0) {\n      return new Uint8Array([0]);\n    } else {\n      return concat(new Uint8Array([1]), this._type.encodeValue(x[0]));\n    }\n  }\n\n  _buildTypeTableImpl(typeTable) {\n    this._type.buildTypeTable(typeTable);\n\n    const opCode = slebEncode(-18\n    /* Opt */\n    );\n\n    const buffer = this._type.encodeType(typeTable);\n\n    typeTable.add(this, concat(opCode, buffer));\n  }\n\n  decodeValue(b, t) {\n    const opt = this.checkType(t);\n\n    if (!(opt instanceof OptClass)) {\n      throw new Error('Not an option type');\n    }\n\n    switch (safeReadUint8(b)) {\n      case 0:\n        return [];\n\n      case 1:\n        return [this._type.decodeValue(b, opt._type)];\n\n      default:\n        throw new Error('Not an option value');\n    }\n  }\n\n  get name() {\n    return `opt ${this._type.name}`;\n  }\n\n  display() {\n    return `opt ${this._type.display()}`;\n  }\n\n  valueToString(x) {\n    if (x.length === 0) {\n      return 'null';\n    } else {\n      return `opt ${this._type.valueToString(x[0])}`;\n    }\n  }\n\n}\n/**\n * Represents an IDL Record\n * @param {Object} [fields] - mapping of function name to Type\n */\n\nexport class RecordClass extends ConstructType {\n  constructor(fields = {}) {\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));\n  }\n\n  accept(v, d) {\n    return v.visitRecord(this, this._fields, d);\n  }\n\n  tryAsTuple() {\n    const res = [];\n\n    for (let i = 0; i < this._fields.length; i++) {\n      const [key, type] = this._fields[i];\n\n      if (key !== `_${i}_`) {\n        return null;\n      }\n\n      res.push(type);\n    }\n\n    return res;\n  }\n\n  covariant(x) {\n    return typeof x === 'object' && this._fields.every(([k, t]) => {\n      // eslint-disable-next-line\n      if (!x.hasOwnProperty(k)) {\n        throw new Error(`Record is missing key \"${k}\".`);\n      }\n\n      return t.covariant(x[k]);\n    });\n  }\n\n  encodeValue(x) {\n    const values = this._fields.map(([key]) => x[key]);\n\n    const bufs = zipWith(this._fields, values, ([, c], d) => c.encodeValue(d));\n    return concat(...bufs);\n  }\n\n  _buildTypeTableImpl(T) {\n    this._fields.forEach(([_, value]) => value.buildTypeTable(T));\n\n    const opCode = slebEncode(-20\n    /* Record */\n    );\n    const len = lebEncode(this._fields.length);\n\n    const fields = this._fields.map(([key, value]) => concat(lebEncode(idlLabelToId(key)), value.encodeType(T)));\n\n    T.add(this, concat(opCode, len, concat(...fields)));\n  }\n\n  decodeValue(b, t) {\n    const record = this.checkType(t);\n\n    if (!(record instanceof RecordClass)) {\n      throw new Error('Not a record type');\n    }\n\n    const x = {};\n    let idx = 0;\n\n    for (const [hash, type] of record._fields) {\n      if (idx >= this._fields.length || idlLabelToId(this._fields[idx][0]) !== idlLabelToId(hash)) {\n        // skip field\n        type.decodeValue(b, type);\n        continue;\n      }\n\n      const [expectKey, expectType] = this._fields[idx];\n      x[expectKey] = expectType.decodeValue(b, type);\n      idx++;\n    }\n\n    if (idx < this._fields.length) {\n      throw new Error('Cannot find field ' + this._fields[idx][0]);\n    }\n\n    return x;\n  }\n\n  get name() {\n    const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n\n    return `record {${fields.join('; ')}}`;\n  }\n\n  display() {\n    const fields = this._fields.map(([key, value]) => key + ':' + value.display());\n\n    return `record {${fields.join('; ')}}`;\n  }\n\n  valueToString(x) {\n    const values = this._fields.map(([key]) => x[key]);\n\n    const fields = zipWith(this._fields, values, ([k, c], d) => k + '=' + c.valueToString(d));\n    return `record {${fields.join('; ')}}`;\n  }\n\n}\n/**\n * Represents Tuple, a syntactic sugar for Record.\n * @param {Type} components\n */\n\nexport class TupleClass extends RecordClass {\n  constructor(_components) {\n    const x = {};\n\n    _components.forEach((e, i) => x['_' + i + '_'] = e);\n\n    super(x);\n    this._components = _components;\n  }\n\n  accept(v, d) {\n    return v.visitTuple(this, this._components, d);\n  }\n\n  covariant(x) {\n    // `>=` because tuples can be covariant when encoded.\n    return Array.isArray(x) && x.length >= this._fields.length && this._components.every((t, i) => t.covariant(x[i]));\n  }\n\n  encodeValue(x) {\n    const bufs = zipWith(this._components, x, (c, d) => c.encodeValue(d));\n    return concat(...bufs);\n  }\n\n  decodeValue(b, t) {\n    const tuple = this.checkType(t);\n\n    if (!(tuple instanceof TupleClass)) {\n      throw new Error('not a tuple type');\n    }\n\n    if (tuple._components.length < this._components.length) {\n      throw new Error('tuple mismatch');\n    }\n\n    const res = [];\n\n    for (const [i, wireType] of tuple._components.entries()) {\n      if (i >= this._components.length) {\n        // skip value\n        wireType.decodeValue(b, wireType);\n      } else {\n        res.push(this._components[i].decodeValue(b, wireType));\n      }\n    }\n\n    return res;\n  }\n\n  display() {\n    const fields = this._components.map(value => value.display());\n\n    return `record {${fields.join('; ')}}`;\n  }\n\n  valueToString(values) {\n    const fields = zipWith(this._components, values, (c, d) => c.valueToString(d));\n    return `record {${fields.join('; ')}}`;\n  }\n\n}\n/**\n * Represents an IDL Variant\n * @param {Object} [fields] - mapping of function name to Type\n */\n\nexport class VariantClass extends ConstructType {\n  constructor(fields = {}) {\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));\n  }\n\n  accept(v, d) {\n    return v.visitVariant(this, this._fields, d);\n  }\n\n  covariant(x) {\n    return typeof x === 'object' && Object.entries(x).length === 1 && this._fields.every(([k, v]) => {\n      // eslint-disable-next-line\n      return !x.hasOwnProperty(k) || v.covariant(x[k]);\n    });\n  }\n\n  encodeValue(x) {\n    for (let i = 0; i < this._fields.length; i++) {\n      const [name, type] = this._fields[i]; // eslint-disable-next-line\n\n      if (x.hasOwnProperty(name)) {\n        const idx = lebEncode(i);\n        const buf = type.encodeValue(x[name]);\n        return concat(idx, buf);\n      }\n    }\n\n    throw Error('Variant has no data: ' + x);\n  }\n\n  _buildTypeTableImpl(typeTable) {\n    this._fields.forEach(([, type]) => {\n      type.buildTypeTable(typeTable);\n    });\n\n    const opCode = slebEncode(-21\n    /* Variant */\n    );\n    const len = lebEncode(this._fields.length);\n\n    const fields = this._fields.map(([key, value]) => concat(lebEncode(idlLabelToId(key)), value.encodeType(typeTable)));\n\n    typeTable.add(this, concat(opCode, len, ...fields));\n  }\n\n  decodeValue(b, t) {\n    const variant = this.checkType(t);\n\n    if (!(variant instanceof VariantClass)) {\n      throw new Error('Not a variant type');\n    }\n\n    const idx = Number(lebDecode(b));\n\n    if (idx >= variant._fields.length) {\n      throw Error('Invalid variant index: ' + idx);\n    }\n\n    const [wireHash, wireType] = variant._fields[idx];\n\n    for (const [key, expectType] of this._fields) {\n      if (idlLabelToId(wireHash) === idlLabelToId(key)) {\n        const value = expectType.decodeValue(b, wireType);\n        return {\n          [key]: value\n        };\n      }\n    }\n\n    throw new Error('Cannot find field hash ' + wireHash);\n  }\n\n  get name() {\n    const fields = this._fields.map(([key, type]) => key + ':' + type.name);\n\n    return `variant {${fields.join('; ')}}`;\n  }\n\n  display() {\n    const fields = this._fields.map(([key, type]) => key + (type.name === 'null' ? '' : `:${type.display()}`));\n\n    return `variant {${fields.join('; ')}}`;\n  }\n\n  valueToString(x) {\n    for (const [name, type] of this._fields) {\n      // eslint-disable-next-line\n      if (x.hasOwnProperty(name)) {\n        const value = type.valueToString(x[name]);\n\n        if (value === 'null') {\n          return `variant {${name}}`;\n        } else {\n          return `variant {${name}=${value}}`;\n        }\n      }\n    }\n\n    throw new Error('Variant has no data: ' + x);\n  }\n\n}\n/**\n * Represents a reference to an IDL type, used for defining recursive data\n * types.\n */\n\nexport class RecClass extends ConstructType {\n  constructor() {\n    super(...arguments);\n    this._id = RecClass._counter++;\n    this._type = undefined;\n  }\n\n  accept(v, d) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n\n    return v.visitRec(this, this._type, d);\n  }\n\n  fill(t) {\n    this._type = t;\n  }\n\n  getType() {\n    return this._type;\n  }\n\n  covariant(x) {\n    return this._type ? this._type.covariant(x) : false;\n  }\n\n  encodeValue(x) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n\n    return this._type.encodeValue(x);\n  }\n\n  _buildTypeTableImpl(typeTable) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n\n    typeTable.add(this, new Uint8Array([]));\n\n    this._type.buildTypeTable(typeTable);\n\n    typeTable.merge(this, this._type.name);\n  }\n\n  decodeValue(b, t) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n\n    return this._type.decodeValue(b, t);\n  }\n\n  get name() {\n    return `rec_${this._id}`;\n  }\n\n  display() {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n\n    return `μ${this.name}.${this._type.name}`;\n  }\n\n  valueToString(x) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n\n    return this._type.valueToString(x);\n  }\n\n}\nRecClass._counter = 0;\n\nfunction decodePrincipalId(b) {\n  const x = safeReadUint8(b);\n\n  if (x !== 1) {\n    throw new Error('Cannot decode principal');\n  }\n\n  const len = Number(lebDecode(b));\n  return PrincipalId.fromUint8Array(new Uint8Array(safeRead(b, len)));\n}\n/**\n * Represents an IDL principal reference\n */\n\n\nexport class PrincipalClass extends PrimitiveType {\n  accept(v, d) {\n    return v.visitPrincipal(this, d);\n  }\n\n  covariant(x) {\n    return x && x._isPrincipal;\n  }\n\n  encodeValue(x) {\n    const buf = x.toUint8Array();\n    const len = lebEncode(buf.byteLength);\n    return concat(new Uint8Array([1]), len, buf);\n  }\n\n  encodeType() {\n    return slebEncode(-24\n    /* Principal */\n    );\n  }\n\n  decodeValue(b, t) {\n    this.checkType(t);\n    return decodePrincipalId(b);\n  }\n\n  get name() {\n    return 'principal';\n  }\n\n  valueToString(x) {\n    return `${this.name} \"${x.toText()}\"`;\n  }\n\n}\n/**\n * Represents an IDL function reference.\n * @param argTypes Argument types.\n * @param retTypes Return types.\n * @param annotations Function annotations.\n */\n\nexport class FuncClass extends ConstructType {\n  constructor(argTypes, retTypes, annotations = []) {\n    super();\n    this.argTypes = argTypes;\n    this.retTypes = retTypes;\n    this.annotations = annotations;\n  }\n\n  static argsToString(types, v) {\n    if (types.length !== v.length) {\n      throw new Error('arity mismatch');\n    }\n\n    return '(' + types.map((t, i) => t.valueToString(v[i])).join(', ') + ')';\n  }\n\n  accept(v, d) {\n    return v.visitFunc(this, d);\n  }\n\n  covariant(x) {\n    return Array.isArray(x) && x.length === 2 && x[0] && x[0]._isPrincipal && typeof x[1] === 'string';\n  }\n\n  encodeValue([principal, methodName]) {\n    const buf = principal.toUint8Array();\n    const len = lebEncode(buf.byteLength);\n    const canister = concat(new Uint8Array([1]), len, buf);\n    const method = new TextEncoder().encode(methodName);\n    const methodLen = lebEncode(method.byteLength);\n    return concat(new Uint8Array([1]), canister, methodLen, method);\n  }\n\n  _buildTypeTableImpl(T) {\n    this.argTypes.forEach(arg => arg.buildTypeTable(T));\n    this.retTypes.forEach(arg => arg.buildTypeTable(T));\n    const opCode = slebEncode(-22\n    /* Func */\n    );\n    const argLen = lebEncode(this.argTypes.length);\n    const args = concat(...this.argTypes.map(arg => arg.encodeType(T)));\n    const retLen = lebEncode(this.retTypes.length);\n    const rets = concat(...this.retTypes.map(arg => arg.encodeType(T)));\n    const annLen = lebEncode(this.annotations.length);\n    const anns = concat(...this.annotations.map(a => this.encodeAnnotation(a)));\n    T.add(this, concat(opCode, argLen, args, retLen, rets, annLen, anns));\n  }\n\n  decodeValue(b) {\n    const x = safeReadUint8(b);\n\n    if (x !== 1) {\n      throw new Error('Cannot decode function reference');\n    }\n\n    const canister = decodePrincipalId(b);\n    const mLen = Number(lebDecode(b));\n    const buf = safeRead(b, mLen);\n    const decoder = new TextDecoder('utf8', {\n      fatal: true\n    });\n    const method = decoder.decode(buf);\n    return [canister, method];\n  }\n\n  get name() {\n    const args = this.argTypes.map(arg => arg.name).join(', ');\n    const rets = this.retTypes.map(arg => arg.name).join(', ');\n    const annon = ' ' + this.annotations.join(' ');\n    return `(${args}) -> (${rets})${annon}`;\n  }\n\n  valueToString([principal, str]) {\n    return `func \"${principal.toText()}\".${str}`;\n  }\n\n  display() {\n    const args = this.argTypes.map(arg => arg.display()).join(', ');\n    const rets = this.retTypes.map(arg => arg.display()).join(', ');\n    const annon = ' ' + this.annotations.join(' ');\n    return `(${args}) → (${rets})${annon}`;\n  }\n\n  encodeAnnotation(ann) {\n    if (ann === 'query') {\n      return new Uint8Array([1]);\n    } else if (ann === 'oneway') {\n      return new Uint8Array([2]);\n    } else {\n      throw new Error('Illeagal function annotation');\n    }\n  }\n\n}\nexport class ServiceClass extends ConstructType {\n  constructor(fields) {\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));\n  }\n\n  accept(v, d) {\n    return v.visitService(this, d);\n  }\n\n  covariant(x) {\n    return x && x._isPrincipal;\n  }\n\n  encodeValue(x) {\n    const buf = x.toUint8Array();\n    const len = lebEncode(buf.length);\n    return concat(new Uint8Array([1]), len, buf);\n  }\n\n  _buildTypeTableImpl(T) {\n    this._fields.forEach(([_, func]) => func.buildTypeTable(T));\n\n    const opCode = slebEncode(-23\n    /* Service */\n    );\n    const len = lebEncode(this._fields.length);\n\n    const meths = this._fields.map(([label, func]) => {\n      const labelBuf = new TextEncoder().encode(label);\n      const labelLen = lebEncode(labelBuf.length);\n      return concat(labelLen, labelBuf, func.encodeType(T));\n    });\n\n    T.add(this, concat(opCode, len, ...meths));\n  }\n\n  decodeValue(b) {\n    return decodePrincipalId(b);\n  }\n\n  get name() {\n    const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n\n    return `service {${fields.join('; ')}}`;\n  }\n\n  valueToString(x) {\n    return `service \"${x.toText()}\"`;\n  }\n\n}\n/**\n *\n * @param x\n * @returns {string}\n */\n\nfunction toReadableString(x) {\n  return JSON.stringify(x, (_key, value) => typeof value === 'bigint' ? `BigInt(${value})` : value);\n}\n/**\n * Encode a array of values\n * @param argTypes\n * @param args\n * @returns {Buffer} serialised value\n */\n\n\nexport function encode(argTypes, args) {\n  if (args.length < argTypes.length) {\n    throw Error('Wrong number of message arguments');\n  }\n\n  const typeTable = new TypeTable();\n  argTypes.forEach(t => t.buildTypeTable(typeTable));\n  const magic = new TextEncoder().encode(magicNumber);\n  const table = typeTable.encode();\n  const len = lebEncode(args.length);\n  const typs = concat(...argTypes.map(t => t.encodeType(typeTable)));\n  const vals = concat(...zipWith(argTypes, args, (t, x) => {\n    if (!t.covariant(x)) {\n      throw new Error(`Invalid ${t.display()} argument: ${toReadableString(x)}`);\n    }\n\n    return t.encodeValue(x);\n  }));\n  return concat(magic, table, len, typs, vals);\n}\n/**\n * Decode a binary value\n * @param retTypes - Types expected in the buffer.\n * @param bytes - hex-encoded string, or buffer.\n * @returns Value deserialised to JS type\n */\n\nexport function decode(retTypes, bytes) {\n  const b = new Pipe(bytes);\n\n  if (bytes.byteLength < magicNumber.length) {\n    throw new Error('Message length smaller than magic number');\n  }\n\n  const magicBuffer = safeRead(b, magicNumber.length);\n  const magic = new TextDecoder().decode(magicBuffer);\n\n  if (magic !== magicNumber) {\n    throw new Error('Wrong magic number: ' + JSON.stringify(magic));\n  }\n\n  function readTypeTable(pipe) {\n    const typeTable = [];\n    const len = Number(lebDecode(pipe));\n\n    for (let i = 0; i < len; i++) {\n      const ty = Number(slebDecode(pipe));\n\n      switch (ty) {\n        case -18\n        /* Opt */\n        :\n        case -19\n        /* Vector */\n        :\n          {\n            const t = Number(slebDecode(pipe));\n            typeTable.push([ty, t]);\n            break;\n          }\n\n        case -20\n        /* Record */\n        :\n        case -21\n        /* Variant */\n        :\n          {\n            const fields = [];\n            let objectLength = Number(lebDecode(pipe));\n            let prevHash;\n\n            while (objectLength--) {\n              const hash = Number(lebDecode(pipe));\n\n              if (hash >= Math.pow(2, 32)) {\n                throw new Error('field id out of 32-bit range');\n              }\n\n              if (typeof prevHash === 'number' && prevHash >= hash) {\n                throw new Error('field id collision or not sorted');\n              }\n\n              prevHash = hash;\n              const t = Number(slebDecode(pipe));\n              fields.push([hash, t]);\n            }\n\n            typeTable.push([ty, fields]);\n            break;\n          }\n\n        case -22\n        /* Func */\n        :\n          {\n            for (let k = 0; k < 2; k++) {\n              let funcLength = Number(lebDecode(pipe));\n\n              while (funcLength--) {\n                slebDecode(pipe);\n              }\n            }\n\n            const annLen = Number(lebDecode(pipe));\n            safeRead(pipe, annLen);\n            typeTable.push([ty, undefined]);\n            break;\n          }\n\n        case -23\n        /* Service */\n        :\n          {\n            let servLength = Number(lebDecode(pipe));\n\n            while (servLength--) {\n              const l = Number(lebDecode(pipe));\n              safeRead(pipe, l);\n              slebDecode(pipe);\n            }\n\n            typeTable.push([ty, undefined]);\n            break;\n          }\n\n        default:\n          throw new Error('Illegal op_code: ' + ty);\n      }\n    }\n\n    const rawList = [];\n    const length = Number(lebDecode(pipe));\n\n    for (let i = 0; i < length; i++) {\n      rawList.push(Number(slebDecode(pipe)));\n    }\n\n    return [typeTable, rawList];\n  }\n\n  const [rawTable, rawTypes] = readTypeTable(b);\n\n  if (rawTypes.length < retTypes.length) {\n    throw new Error('Wrong number of return values');\n  }\n\n  const table = rawTable.map(_ => Rec());\n\n  function getType(t) {\n    if (t < -24) {\n      throw new Error('future value not supported');\n    }\n\n    if (t < 0) {\n      switch (t) {\n        case -1:\n          return Null;\n\n        case -2:\n          return Bool;\n\n        case -3:\n          return Nat;\n\n        case -4:\n          return Int;\n\n        case -5:\n          return Nat8;\n\n        case -6:\n          return Nat16;\n\n        case -7:\n          return Nat32;\n\n        case -8:\n          return Nat64;\n\n        case -9:\n          return Int8;\n\n        case -10:\n          return Int16;\n\n        case -11:\n          return Int32;\n\n        case -12:\n          return Int64;\n\n        case -13:\n          return Float32;\n\n        case -14:\n          return Float64;\n\n        case -15:\n          return Text;\n\n        case -16:\n          return Reserved;\n\n        case -17:\n          return Empty;\n\n        case -24:\n          return Principal;\n\n        default:\n          throw new Error('Illegal op_code: ' + t);\n      }\n    }\n\n    if (t >= rawTable.length) {\n      throw new Error('type index out of range');\n    }\n\n    return table[t];\n  }\n\n  function buildType(entry) {\n    switch (entry[0]) {\n      case -19\n      /* Vector */\n      :\n        {\n          const ty = getType(entry[1]);\n          return Vec(ty);\n        }\n\n      case -18\n      /* Opt */\n      :\n        {\n          const ty = getType(entry[1]);\n          return Opt(ty);\n        }\n\n      case -20\n      /* Record */\n      :\n        {\n          const fields = {};\n\n          for (const [hash, ty] of entry[1]) {\n            const name = `_${hash}_`;\n            fields[name] = getType(ty);\n          }\n\n          const record = Record(fields);\n          const tuple = record.tryAsTuple();\n\n          if (Array.isArray(tuple)) {\n            return Tuple(...tuple);\n          } else {\n            return record;\n          }\n        }\n\n      case -21\n      /* Variant */\n      :\n        {\n          const fields = {};\n\n          for (const [hash, ty] of entry[1]) {\n            const name = `_${hash}_`;\n            fields[name] = getType(ty);\n          }\n\n          return Variant(fields);\n        }\n\n      case -22\n      /* Func */\n      :\n        {\n          return Func([], [], []);\n        }\n\n      case -23\n      /* Service */\n      :\n        {\n          return Service({});\n        }\n\n      default:\n        throw new Error('Illegal op_code: ' + entry[0]);\n    }\n  }\n\n  rawTable.forEach((entry, i) => {\n    const t = buildType(entry);\n    table[i].fill(t);\n  });\n  const types = rawTypes.map(t => getType(t));\n  const output = retTypes.map((t, i) => {\n    return t.decodeValue(b, types[i]);\n  }); // skip unused values\n\n  for (let ind = retTypes.length; ind < types.length; ind++) {\n    types[ind].decodeValue(b, types[ind]);\n  }\n\n  if (b.byteLength > 0) {\n    throw new Error('decode: Left-over bytes');\n  }\n\n  return output;\n} // Export Types instances.\n\nexport const Empty = new EmptyClass();\nexport const Reserved = new ReservedClass();\nexport const Bool = new BoolClass();\nexport const Null = new NullClass();\nexport const Text = new TextClass();\nexport const Int = new IntClass();\nexport const Nat = new NatClass();\nexport const Float32 = new FloatClass(32);\nexport const Float64 = new FloatClass(64);\nexport const Int8 = new FixedIntClass(8);\nexport const Int16 = new FixedIntClass(16);\nexport const Int32 = new FixedIntClass(32);\nexport const Int64 = new FixedIntClass(64);\nexport const Nat8 = new FixedNatClass(8);\nexport const Nat16 = new FixedNatClass(16);\nexport const Nat32 = new FixedNatClass(32);\nexport const Nat64 = new FixedNatClass(64);\nexport const Principal = new PrincipalClass();\n/**\n *\n * @param types array of any types\n * @returns TupleClass from those types\n */\n\nexport function Tuple(...types) {\n  return new TupleClass(types);\n}\n/**\n *\n * @param t IDL Type\n * @returns VecClass from that type\n */\n\nexport function Vec(t) {\n  return new VecClass(t);\n}\n/**\n *\n * @param t IDL Type\n * @returns OptClass of Type\n */\n\nexport function Opt(t) {\n  return new OptClass(t);\n}\n/**\n *\n * @param t Record of string and IDL Type\n * @returns RecordClass of string and Type\n */\n\nexport function Record(t) {\n  return new RecordClass(t);\n}\n/**\n *\n * @param fields Record of string and IDL Type\n * @returns VariantClass\n */\n\nexport function Variant(fields) {\n  return new VariantClass(fields);\n}\n/**\n *\n * @returns new RecClass\n */\n\nexport function Rec() {\n  return new RecClass();\n}\n/**\n *\n * @param args array of IDL Types\n * @param ret array of IDL Types\n * @param annotations array of strings, [] by default\n * @returns new FuncClass\n */\n\nexport function Func(args, ret, annotations = []) {\n  return new FuncClass(args, ret, annotations);\n}\n/**\n *\n * @param t Record of string and FuncClass\n * @returns ServiceClass\n */\n\nexport function Service(t) {\n  return new ServiceClass(t);\n}","map":{"version":3,"sources":["../../src/idl.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// tslint:disable:max-classes-per-file\nimport { Principal as PrincipalId } from '@dfinity/principal';\nimport { concat, PipeArrayBuffer as Pipe } from './utils/buffer';\nimport { idlLabelToId } from './utils/hash';\nimport { lebDecode, lebEncode, safeRead, safeReadUint8, slebDecode, slebEncode, } from './utils/leb128';\nimport { readIntLE, readUIntLE, writeIntLE, writeUIntLE } from './utils/leb128';\nconst magicNumber = 'DIDL';\nfunction zipWith(xs, ys, f) {\n    return xs.map((x, i) => f(x, ys[i]));\n}\n/**\n * An IDL Type Table, which precedes the data in the stream.\n */\nclass TypeTable {\n    constructor() {\n        // List of types. Needs to be an array as the index needs to be stable.\n        this._typs = [];\n        this._idx = new Map();\n    }\n    has(obj) {\n        return this._idx.has(obj.name);\n    }\n    add(type, buf) {\n        const idx = this._typs.length;\n        this._idx.set(type.name, idx);\n        this._typs.push(buf);\n    }\n    merge(obj, knot) {\n        const idx = this._idx.get(obj.name);\n        const knotIdx = this._idx.get(knot);\n        if (idx === undefined) {\n            throw new Error('Missing type index for ' + obj);\n        }\n        if (knotIdx === undefined) {\n            throw new Error('Missing type index for ' + knot);\n        }\n        this._typs[idx] = this._typs[knotIdx];\n        // Delete the type.\n        this._typs.splice(knotIdx, 1);\n        this._idx.delete(knot);\n    }\n    encode() {\n        const len = lebEncode(this._typs.length);\n        const buf = concat(...this._typs);\n        return concat(len, buf);\n    }\n    indexOf(typeName) {\n        if (!this._idx.has(typeName)) {\n            throw new Error('Missing type index for ' + typeName);\n        }\n        return slebEncode(this._idx.get(typeName) || 0);\n    }\n}\nexport class Visitor {\n    visitType(t, data) {\n        throw new Error('Not implemented');\n    }\n    visitPrimitive(t, data) {\n        return this.visitType(t, data);\n    }\n    visitEmpty(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitBool(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitNull(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitReserved(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitText(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitNumber(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitInt(t, data) {\n        return this.visitNumber(t, data);\n    }\n    visitNat(t, data) {\n        return this.visitNumber(t, data);\n    }\n    visitFloat(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitFixedInt(t, data) {\n        return this.visitNumber(t, data);\n    }\n    visitFixedNat(t, data) {\n        return this.visitNumber(t, data);\n    }\n    visitPrincipal(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitConstruct(t, data) {\n        return this.visitType(t, data);\n    }\n    visitVec(t, ty, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitOpt(t, ty, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitRecord(t, fields, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitTuple(t, components, data) {\n        const fields = components.map((ty, i) => [`_${i}_`, ty]);\n        return this.visitRecord(t, fields, data);\n    }\n    visitVariant(t, fields, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitRec(t, ty, data) {\n        return this.visitConstruct(ty, data);\n    }\n    visitFunc(t, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitService(t, data) {\n        return this.visitConstruct(t, data);\n    }\n}\n/**\n * Represents an IDL type.\n */\nexport class Type {\n    /* Display type name */\n    display() {\n        return this.name;\n    }\n    valueToString(x) {\n        return toReadableString(x);\n    }\n    /* Implement `T` in the IDL spec, only needed for non-primitive types */\n    buildTypeTable(typeTable) {\n        if (!typeTable.has(this)) {\n            this._buildTypeTableImpl(typeTable);\n        }\n    }\n}\nexport class PrimitiveType extends Type {\n    checkType(t) {\n        if (this.name !== t.name) {\n            throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n        }\n        return t;\n    }\n    _buildTypeTableImpl(typeTable) {\n        // No type table encoding for Primitive types.\n        return;\n    }\n}\nexport class ConstructType extends Type {\n    checkType(t) {\n        if (t instanceof RecClass) {\n            const ty = t.getType();\n            if (typeof ty === 'undefined') {\n                throw new Error('type mismatch with uninitialized type');\n            }\n            return ty;\n        }\n        throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n    }\n    encodeType(typeTable) {\n        return typeTable.indexOf(this.name);\n    }\n}\n/**\n * Represents an IDL Empty, a type which has no inhabitants.\n * Since no values exist for this type, it cannot be serialised or deserialised.\n * Result types like `Result<Text, Empty>` should always succeed.\n */\nexport class EmptyClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitEmpty(this, d);\n    }\n    covariant(x) {\n        return false;\n    }\n    encodeValue() {\n        throw new Error('Empty cannot appear as a function argument');\n    }\n    valueToString() {\n        throw new Error('Empty cannot appear as a value');\n    }\n    encodeType() {\n        return slebEncode(-17 /* Empty */);\n    }\n    decodeValue() {\n        throw new Error('Empty cannot appear as an output');\n    }\n    get name() {\n        return 'empty';\n    }\n}\n/**\n * Represents an IDL Bool\n */\nexport class BoolClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitBool(this, d);\n    }\n    covariant(x) {\n        return typeof x === 'boolean';\n    }\n    encodeValue(x) {\n        return new Uint8Array([x ? 1 : 0]);\n    }\n    encodeType() {\n        return slebEncode(-2 /* Bool */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        switch (safeReadUint8(b)) {\n            case 0:\n                return false;\n            case 1:\n                return true;\n            default:\n                throw new Error('Boolean value out of range');\n        }\n    }\n    get name() {\n        return 'bool';\n    }\n}\n/**\n * Represents an IDL Null\n */\nexport class NullClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitNull(this, d);\n    }\n    covariant(x) {\n        return x === null;\n    }\n    encodeValue() {\n        return new ArrayBuffer(0);\n    }\n    encodeType() {\n        return slebEncode(-1 /* Null */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        return null;\n    }\n    get name() {\n        return 'null';\n    }\n}\n/**\n * Represents an IDL Reserved\n */\nexport class ReservedClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitReserved(this, d);\n    }\n    covariant(x) {\n        return true;\n    }\n    encodeValue() {\n        return new ArrayBuffer(0);\n    }\n    encodeType() {\n        return slebEncode(-16 /* Reserved */);\n    }\n    decodeValue(b, t) {\n        if (t.name !== this.name) {\n            t.decodeValue(b, t);\n        }\n        return null;\n    }\n    get name() {\n        return 'reserved';\n    }\n}\n/**\n * Represents an IDL Text\n */\nexport class TextClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitText(this, d);\n    }\n    covariant(x) {\n        return typeof x === 'string';\n    }\n    encodeValue(x) {\n        const buf = new TextEncoder().encode(x);\n        const len = lebEncode(buf.byteLength);\n        return concat(len, buf);\n    }\n    encodeType() {\n        return slebEncode(-15 /* Text */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        const len = lebDecode(b);\n        const buf = safeRead(b, Number(len));\n        const decoder = new TextDecoder('utf8', { fatal: true });\n        return decoder.decode(buf);\n    }\n    get name() {\n        return 'text';\n    }\n    valueToString(x) {\n        return '\"' + x + '\"';\n    }\n}\n/**\n * Represents an IDL Int\n */\nexport class IntClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitInt(this, d);\n    }\n    covariant(x) {\n        // We allow encoding of JavaScript plain numbers.\n        // But we will always decode to bigint.\n        return typeof x === 'bigint' || Number.isInteger(x);\n    }\n    encodeValue(x) {\n        return slebEncode(x);\n    }\n    encodeType() {\n        return slebEncode(-4 /* Int */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        return slebDecode(b);\n    }\n    get name() {\n        return 'int';\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL Nat\n */\nexport class NatClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitNat(this, d);\n    }\n    covariant(x) {\n        // We allow encoding of JavaScript plain numbers.\n        // But we will always decode to bigint.\n        return (typeof x === 'bigint' && x >= BigInt(0)) || (Number.isInteger(x) && x >= 0);\n    }\n    encodeValue(x) {\n        return lebEncode(x);\n    }\n    encodeType() {\n        return slebEncode(-3 /* Nat */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        return lebDecode(b);\n    }\n    get name() {\n        return 'nat';\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL Float\n */\nexport class FloatClass extends PrimitiveType {\n    constructor(_bits) {\n        super();\n        this._bits = _bits;\n        if (_bits !== 32 && _bits !== 64) {\n            throw new Error('not a valid float type');\n        }\n    }\n    accept(v, d) {\n        return v.visitFloat(this, d);\n    }\n    covariant(x) {\n        return typeof x === 'number' || x instanceof Number;\n    }\n    encodeValue(x) {\n        const buf = new ArrayBuffer(this._bits / 8);\n        const view = new DataView(buf);\n        if (this._bits === 32) {\n            view.setFloat32(0, x, true);\n        }\n        else {\n            view.setFloat64(0, x, true);\n        }\n        return buf;\n    }\n    encodeType() {\n        const opcode = this._bits === 32 ? -13 /* Float32 */ : -14 /* Float64 */;\n        return slebEncode(opcode);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        const bytes = safeRead(b, this._bits / 8);\n        const view = new DataView(bytes);\n        if (this._bits === 32) {\n            return view.getFloat32(0, true);\n        }\n        else {\n            return view.getFloat64(0, true);\n        }\n    }\n    get name() {\n        return 'float' + this._bits;\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL fixed-width Int(n)\n */\nexport class FixedIntClass extends PrimitiveType {\n    constructor(_bits) {\n        super();\n        this._bits = _bits;\n    }\n    accept(v, d) {\n        return v.visitFixedInt(this, d);\n    }\n    covariant(x) {\n        const min = BigInt(2) ** BigInt(this._bits - 1) * BigInt(-1);\n        const max = BigInt(2) ** BigInt(this._bits - 1) - BigInt(1);\n        if (typeof x === 'bigint') {\n            return x >= min && x <= max;\n        }\n        else if (Number.isInteger(x)) {\n            const v = BigInt(x);\n            return v >= min && v <= max;\n        }\n        else {\n            return false;\n        }\n    }\n    encodeValue(x) {\n        return writeIntLE(x, this._bits / 8);\n    }\n    encodeType() {\n        const offset = Math.log2(this._bits) - 3;\n        return slebEncode(-9 - offset);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        const num = readIntLE(b, this._bits / 8);\n        if (this._bits <= 32) {\n            return Number(num);\n        }\n        else {\n            return num;\n        }\n    }\n    get name() {\n        return `int${this._bits}`;\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL fixed-width Nat(n)\n */\nexport class FixedNatClass extends PrimitiveType {\n    constructor(bits) {\n        super();\n        this.bits = bits;\n    }\n    accept(v, d) {\n        return v.visitFixedNat(this, d);\n    }\n    covariant(x) {\n        const max = BigInt(2) ** BigInt(this.bits);\n        if (typeof x === 'bigint' && x >= BigInt(0)) {\n            return x < max;\n        }\n        else if (Number.isInteger(x) && x >= 0) {\n            const v = BigInt(x);\n            return v < max;\n        }\n        else {\n            return false;\n        }\n    }\n    encodeValue(x) {\n        return writeUIntLE(x, this.bits / 8);\n    }\n    encodeType() {\n        const offset = Math.log2(this.bits) - 3;\n        return slebEncode(-5 - offset);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        const num = readUIntLE(b, this.bits / 8);\n        if (this.bits <= 32) {\n            return Number(num);\n        }\n        else {\n            return num;\n        }\n    }\n    get name() {\n        return `nat${this.bits}`;\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL Array\n * @param {Type} t\n */\nexport class VecClass extends ConstructType {\n    constructor(_type) {\n        super();\n        this._type = _type;\n        // If true, this vector is really a blob and we can just use memcpy.\n        this._blobOptimization = false;\n        if (_type instanceof FixedNatClass && _type.bits === 8) {\n            this._blobOptimization = true;\n        }\n    }\n    accept(v, d) {\n        return v.visitVec(this, this._type, d);\n    }\n    covariant(x) {\n        return Array.isArray(x) && x.every(v => this._type.covariant(v));\n    }\n    encodeValue(x) {\n        const len = lebEncode(x.length);\n        if (this._blobOptimization) {\n            return concat(len, new Uint8Array(x));\n        }\n        return concat(len, ...x.map(d => this._type.encodeValue(d)));\n    }\n    _buildTypeTableImpl(typeTable) {\n        this._type.buildTypeTable(typeTable);\n        const opCode = slebEncode(-19 /* Vector */);\n        const buffer = this._type.encodeType(typeTable);\n        typeTable.add(this, concat(opCode, buffer));\n    }\n    decodeValue(b, t) {\n        const vec = this.checkType(t);\n        if (!(vec instanceof VecClass)) {\n            throw new Error('Not a vector type');\n        }\n        const len = Number(lebDecode(b));\n        if (this._blobOptimization) {\n            return [...new Uint8Array(b.read(len))];\n        }\n        const rets = [];\n        for (let i = 0; i < len; i++) {\n            rets.push(this._type.decodeValue(b, vec._type));\n        }\n        return rets;\n    }\n    get name() {\n        return `vec ${this._type.name}`;\n    }\n    display() {\n        return `vec ${this._type.display()}`;\n    }\n    valueToString(x) {\n        const elements = x.map(e => this._type.valueToString(e));\n        return 'vec {' + elements.join('; ') + '}';\n    }\n}\n/**\n * Represents an IDL Option\n * @param {Type} t\n */\nexport class OptClass extends ConstructType {\n    constructor(_type) {\n        super();\n        this._type = _type;\n    }\n    accept(v, d) {\n        return v.visitOpt(this, this._type, d);\n    }\n    covariant(x) {\n        return Array.isArray(x) && (x.length === 0 || (x.length === 1 && this._type.covariant(x[0])));\n    }\n    encodeValue(x) {\n        if (x.length === 0) {\n            return new Uint8Array([0]);\n        }\n        else {\n            return concat(new Uint8Array([1]), this._type.encodeValue(x[0]));\n        }\n    }\n    _buildTypeTableImpl(typeTable) {\n        this._type.buildTypeTable(typeTable);\n        const opCode = slebEncode(-18 /* Opt */);\n        const buffer = this._type.encodeType(typeTable);\n        typeTable.add(this, concat(opCode, buffer));\n    }\n    decodeValue(b, t) {\n        const opt = this.checkType(t);\n        if (!(opt instanceof OptClass)) {\n            throw new Error('Not an option type');\n        }\n        switch (safeReadUint8(b)) {\n            case 0:\n                return [];\n            case 1:\n                return [this._type.decodeValue(b, opt._type)];\n            default:\n                throw new Error('Not an option value');\n        }\n    }\n    get name() {\n        return `opt ${this._type.name}`;\n    }\n    display() {\n        return `opt ${this._type.display()}`;\n    }\n    valueToString(x) {\n        if (x.length === 0) {\n            return 'null';\n        }\n        else {\n            return `opt ${this._type.valueToString(x[0])}`;\n        }\n    }\n}\n/**\n * Represents an IDL Record\n * @param {Object} [fields] - mapping of function name to Type\n */\nexport class RecordClass extends ConstructType {\n    constructor(fields = {}) {\n        super();\n        this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));\n    }\n    accept(v, d) {\n        return v.visitRecord(this, this._fields, d);\n    }\n    tryAsTuple() {\n        const res = [];\n        for (let i = 0; i < this._fields.length; i++) {\n            const [key, type] = this._fields[i];\n            if (key !== `_${i}_`) {\n                return null;\n            }\n            res.push(type);\n        }\n        return res;\n    }\n    covariant(x) {\n        return (typeof x === 'object' &&\n            this._fields.every(([k, t]) => {\n                // eslint-disable-next-line\n                if (!x.hasOwnProperty(k)) {\n                    throw new Error(`Record is missing key \"${k}\".`);\n                }\n                return t.covariant(x[k]);\n            }));\n    }\n    encodeValue(x) {\n        const values = this._fields.map(([key]) => x[key]);\n        const bufs = zipWith(this._fields, values, ([, c], d) => c.encodeValue(d));\n        return concat(...bufs);\n    }\n    _buildTypeTableImpl(T) {\n        this._fields.forEach(([_, value]) => value.buildTypeTable(T));\n        const opCode = slebEncode(-20 /* Record */);\n        const len = lebEncode(this._fields.length);\n        const fields = this._fields.map(([key, value]) => concat(lebEncode(idlLabelToId(key)), value.encodeType(T)));\n        T.add(this, concat(opCode, len, concat(...fields)));\n    }\n    decodeValue(b, t) {\n        const record = this.checkType(t);\n        if (!(record instanceof RecordClass)) {\n            throw new Error('Not a record type');\n        }\n        const x = {};\n        let idx = 0;\n        for (const [hash, type] of record._fields) {\n            if (idx >= this._fields.length || idlLabelToId(this._fields[idx][0]) !== idlLabelToId(hash)) {\n                // skip field\n                type.decodeValue(b, type);\n                continue;\n            }\n            const [expectKey, expectType] = this._fields[idx];\n            x[expectKey] = expectType.decodeValue(b, type);\n            idx++;\n        }\n        if (idx < this._fields.length) {\n            throw new Error('Cannot find field ' + this._fields[idx][0]);\n        }\n        return x;\n    }\n    get name() {\n        const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n        return `record {${fields.join('; ')}}`;\n    }\n    display() {\n        const fields = this._fields.map(([key, value]) => key + ':' + value.display());\n        return `record {${fields.join('; ')}}`;\n    }\n    valueToString(x) {\n        const values = this._fields.map(([key]) => x[key]);\n        const fields = zipWith(this._fields, values, ([k, c], d) => k + '=' + c.valueToString(d));\n        return `record {${fields.join('; ')}}`;\n    }\n}\n/**\n * Represents Tuple, a syntactic sugar for Record.\n * @param {Type} components\n */\nexport class TupleClass extends RecordClass {\n    constructor(_components) {\n        const x = {};\n        _components.forEach((e, i) => (x['_' + i + '_'] = e));\n        super(x);\n        this._components = _components;\n    }\n    accept(v, d) {\n        return v.visitTuple(this, this._components, d);\n    }\n    covariant(x) {\n        // `>=` because tuples can be covariant when encoded.\n        return (Array.isArray(x) &&\n            x.length >= this._fields.length &&\n            this._components.every((t, i) => t.covariant(x[i])));\n    }\n    encodeValue(x) {\n        const bufs = zipWith(this._components, x, (c, d) => c.encodeValue(d));\n        return concat(...bufs);\n    }\n    decodeValue(b, t) {\n        const tuple = this.checkType(t);\n        if (!(tuple instanceof TupleClass)) {\n            throw new Error('not a tuple type');\n        }\n        if (tuple._components.length < this._components.length) {\n            throw new Error('tuple mismatch');\n        }\n        const res = [];\n        for (const [i, wireType] of tuple._components.entries()) {\n            if (i >= this._components.length) {\n                // skip value\n                wireType.decodeValue(b, wireType);\n            }\n            else {\n                res.push(this._components[i].decodeValue(b, wireType));\n            }\n        }\n        return res;\n    }\n    display() {\n        const fields = this._components.map(value => value.display());\n        return `record {${fields.join('; ')}}`;\n    }\n    valueToString(values) {\n        const fields = zipWith(this._components, values, (c, d) => c.valueToString(d));\n        return `record {${fields.join('; ')}}`;\n    }\n}\n/**\n * Represents an IDL Variant\n * @param {Object} [fields] - mapping of function name to Type\n */\nexport class VariantClass extends ConstructType {\n    constructor(fields = {}) {\n        super();\n        this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));\n    }\n    accept(v, d) {\n        return v.visitVariant(this, this._fields, d);\n    }\n    covariant(x) {\n        return (typeof x === 'object' &&\n            Object.entries(x).length === 1 &&\n            this._fields.every(([k, v]) => {\n                // eslint-disable-next-line\n                return !x.hasOwnProperty(k) || v.covariant(x[k]);\n            }));\n    }\n    encodeValue(x) {\n        for (let i = 0; i < this._fields.length; i++) {\n            const [name, type] = this._fields[i];\n            // eslint-disable-next-line\n            if (x.hasOwnProperty(name)) {\n                const idx = lebEncode(i);\n                const buf = type.encodeValue(x[name]);\n                return concat(idx, buf);\n            }\n        }\n        throw Error('Variant has no data: ' + x);\n    }\n    _buildTypeTableImpl(typeTable) {\n        this._fields.forEach(([, type]) => {\n            type.buildTypeTable(typeTable);\n        });\n        const opCode = slebEncode(-21 /* Variant */);\n        const len = lebEncode(this._fields.length);\n        const fields = this._fields.map(([key, value]) => concat(lebEncode(idlLabelToId(key)), value.encodeType(typeTable)));\n        typeTable.add(this, concat(opCode, len, ...fields));\n    }\n    decodeValue(b, t) {\n        const variant = this.checkType(t);\n        if (!(variant instanceof VariantClass)) {\n            throw new Error('Not a variant type');\n        }\n        const idx = Number(lebDecode(b));\n        if (idx >= variant._fields.length) {\n            throw Error('Invalid variant index: ' + idx);\n        }\n        const [wireHash, wireType] = variant._fields[idx];\n        for (const [key, expectType] of this._fields) {\n            if (idlLabelToId(wireHash) === idlLabelToId(key)) {\n                const value = expectType.decodeValue(b, wireType);\n                return { [key]: value };\n            }\n        }\n        throw new Error('Cannot find field hash ' + wireHash);\n    }\n    get name() {\n        const fields = this._fields.map(([key, type]) => key + ':' + type.name);\n        return `variant {${fields.join('; ')}}`;\n    }\n    display() {\n        const fields = this._fields.map(([key, type]) => key + (type.name === 'null' ? '' : `:${type.display()}`));\n        return `variant {${fields.join('; ')}}`;\n    }\n    valueToString(x) {\n        for (const [name, type] of this._fields) {\n            // eslint-disable-next-line\n            if (x.hasOwnProperty(name)) {\n                const value = type.valueToString(x[name]);\n                if (value === 'null') {\n                    return `variant {${name}}`;\n                }\n                else {\n                    return `variant {${name}=${value}}`;\n                }\n            }\n        }\n        throw new Error('Variant has no data: ' + x);\n    }\n}\n/**\n * Represents a reference to an IDL type, used for defining recursive data\n * types.\n */\nexport class RecClass extends ConstructType {\n    constructor() {\n        super(...arguments);\n        this._id = RecClass._counter++;\n        this._type = undefined;\n    }\n    accept(v, d) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return v.visitRec(this, this._type, d);\n    }\n    fill(t) {\n        this._type = t;\n    }\n    getType() {\n        return this._type;\n    }\n    covariant(x) {\n        return this._type ? this._type.covariant(x) : false;\n    }\n    encodeValue(x) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return this._type.encodeValue(x);\n    }\n    _buildTypeTableImpl(typeTable) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        typeTable.add(this, new Uint8Array([]));\n        this._type.buildTypeTable(typeTable);\n        typeTable.merge(this, this._type.name);\n    }\n    decodeValue(b, t) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return this._type.decodeValue(b, t);\n    }\n    get name() {\n        return `rec_${this._id}`;\n    }\n    display() {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return `μ${this.name}.${this._type.name}`;\n    }\n    valueToString(x) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return this._type.valueToString(x);\n    }\n}\nRecClass._counter = 0;\nfunction decodePrincipalId(b) {\n    const x = safeReadUint8(b);\n    if (x !== 1) {\n        throw new Error('Cannot decode principal');\n    }\n    const len = Number(lebDecode(b));\n    return PrincipalId.fromUint8Array(new Uint8Array(safeRead(b, len)));\n}\n/**\n * Represents an IDL principal reference\n */\nexport class PrincipalClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitPrincipal(this, d);\n    }\n    covariant(x) {\n        return x && x._isPrincipal;\n    }\n    encodeValue(x) {\n        const buf = x.toUint8Array();\n        const len = lebEncode(buf.byteLength);\n        return concat(new Uint8Array([1]), len, buf);\n    }\n    encodeType() {\n        return slebEncode(-24 /* Principal */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        return decodePrincipalId(b);\n    }\n    get name() {\n        return 'principal';\n    }\n    valueToString(x) {\n        return `${this.name} \"${x.toText()}\"`;\n    }\n}\n/**\n * Represents an IDL function reference.\n * @param argTypes Argument types.\n * @param retTypes Return types.\n * @param annotations Function annotations.\n */\nexport class FuncClass extends ConstructType {\n    constructor(argTypes, retTypes, annotations = []) {\n        super();\n        this.argTypes = argTypes;\n        this.retTypes = retTypes;\n        this.annotations = annotations;\n    }\n    static argsToString(types, v) {\n        if (types.length !== v.length) {\n            throw new Error('arity mismatch');\n        }\n        return '(' + types.map((t, i) => t.valueToString(v[i])).join(', ') + ')';\n    }\n    accept(v, d) {\n        return v.visitFunc(this, d);\n    }\n    covariant(x) {\n        return (Array.isArray(x) && x.length === 2 && x[0] && x[0]._isPrincipal && typeof x[1] === 'string');\n    }\n    encodeValue([principal, methodName]) {\n        const buf = principal.toUint8Array();\n        const len = lebEncode(buf.byteLength);\n        const canister = concat(new Uint8Array([1]), len, buf);\n        const method = new TextEncoder().encode(methodName);\n        const methodLen = lebEncode(method.byteLength);\n        return concat(new Uint8Array([1]), canister, methodLen, method);\n    }\n    _buildTypeTableImpl(T) {\n        this.argTypes.forEach(arg => arg.buildTypeTable(T));\n        this.retTypes.forEach(arg => arg.buildTypeTable(T));\n        const opCode = slebEncode(-22 /* Func */);\n        const argLen = lebEncode(this.argTypes.length);\n        const args = concat(...this.argTypes.map(arg => arg.encodeType(T)));\n        const retLen = lebEncode(this.retTypes.length);\n        const rets = concat(...this.retTypes.map(arg => arg.encodeType(T)));\n        const annLen = lebEncode(this.annotations.length);\n        const anns = concat(...this.annotations.map(a => this.encodeAnnotation(a)));\n        T.add(this, concat(opCode, argLen, args, retLen, rets, annLen, anns));\n    }\n    decodeValue(b) {\n        const x = safeReadUint8(b);\n        if (x !== 1) {\n            throw new Error('Cannot decode function reference');\n        }\n        const canister = decodePrincipalId(b);\n        const mLen = Number(lebDecode(b));\n        const buf = safeRead(b, mLen);\n        const decoder = new TextDecoder('utf8', { fatal: true });\n        const method = decoder.decode(buf);\n        return [canister, method];\n    }\n    get name() {\n        const args = this.argTypes.map(arg => arg.name).join(', ');\n        const rets = this.retTypes.map(arg => arg.name).join(', ');\n        const annon = ' ' + this.annotations.join(' ');\n        return `(${args}) -> (${rets})${annon}`;\n    }\n    valueToString([principal, str]) {\n        return `func \"${principal.toText()}\".${str}`;\n    }\n    display() {\n        const args = this.argTypes.map(arg => arg.display()).join(', ');\n        const rets = this.retTypes.map(arg => arg.display()).join(', ');\n        const annon = ' ' + this.annotations.join(' ');\n        return `(${args}) → (${rets})${annon}`;\n    }\n    encodeAnnotation(ann) {\n        if (ann === 'query') {\n            return new Uint8Array([1]);\n        }\n        else if (ann === 'oneway') {\n            return new Uint8Array([2]);\n        }\n        else {\n            throw new Error('Illeagal function annotation');\n        }\n    }\n}\nexport class ServiceClass extends ConstructType {\n    constructor(fields) {\n        super();\n        this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));\n    }\n    accept(v, d) {\n        return v.visitService(this, d);\n    }\n    covariant(x) {\n        return x && x._isPrincipal;\n    }\n    encodeValue(x) {\n        const buf = x.toUint8Array();\n        const len = lebEncode(buf.length);\n        return concat(new Uint8Array([1]), len, buf);\n    }\n    _buildTypeTableImpl(T) {\n        this._fields.forEach(([_, func]) => func.buildTypeTable(T));\n        const opCode = slebEncode(-23 /* Service */);\n        const len = lebEncode(this._fields.length);\n        const meths = this._fields.map(([label, func]) => {\n            const labelBuf = new TextEncoder().encode(label);\n            const labelLen = lebEncode(labelBuf.length);\n            return concat(labelLen, labelBuf, func.encodeType(T));\n        });\n        T.add(this, concat(opCode, len, ...meths));\n    }\n    decodeValue(b) {\n        return decodePrincipalId(b);\n    }\n    get name() {\n        const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n        return `service {${fields.join('; ')}}`;\n    }\n    valueToString(x) {\n        return `service \"${x.toText()}\"`;\n    }\n}\n/**\n *\n * @param x\n * @returns {string}\n */\nfunction toReadableString(x) {\n    return JSON.stringify(x, (_key, value) => typeof value === 'bigint' ? `BigInt(${value})` : value);\n}\n/**\n * Encode a array of values\n * @param argTypes\n * @param args\n * @returns {Buffer} serialised value\n */\nexport function encode(argTypes, args) {\n    if (args.length < argTypes.length) {\n        throw Error('Wrong number of message arguments');\n    }\n    const typeTable = new TypeTable();\n    argTypes.forEach(t => t.buildTypeTable(typeTable));\n    const magic = new TextEncoder().encode(magicNumber);\n    const table = typeTable.encode();\n    const len = lebEncode(args.length);\n    const typs = concat(...argTypes.map(t => t.encodeType(typeTable)));\n    const vals = concat(...zipWith(argTypes, args, (t, x) => {\n        if (!t.covariant(x)) {\n            throw new Error(`Invalid ${t.display()} argument: ${toReadableString(x)}`);\n        }\n        return t.encodeValue(x);\n    }));\n    return concat(magic, table, len, typs, vals);\n}\n/**\n * Decode a binary value\n * @param retTypes - Types expected in the buffer.\n * @param bytes - hex-encoded string, or buffer.\n * @returns Value deserialised to JS type\n */\nexport function decode(retTypes, bytes) {\n    const b = new Pipe(bytes);\n    if (bytes.byteLength < magicNumber.length) {\n        throw new Error('Message length smaller than magic number');\n    }\n    const magicBuffer = safeRead(b, magicNumber.length);\n    const magic = new TextDecoder().decode(magicBuffer);\n    if (magic !== magicNumber) {\n        throw new Error('Wrong magic number: ' + JSON.stringify(magic));\n    }\n    function readTypeTable(pipe) {\n        const typeTable = [];\n        const len = Number(lebDecode(pipe));\n        for (let i = 0; i < len; i++) {\n            const ty = Number(slebDecode(pipe));\n            switch (ty) {\n                case -18 /* Opt */:\n                case -19 /* Vector */: {\n                    const t = Number(slebDecode(pipe));\n                    typeTable.push([ty, t]);\n                    break;\n                }\n                case -20 /* Record */:\n                case -21 /* Variant */: {\n                    const fields = [];\n                    let objectLength = Number(lebDecode(pipe));\n                    let prevHash;\n                    while (objectLength--) {\n                        const hash = Number(lebDecode(pipe));\n                        if (hash >= Math.pow(2, 32)) {\n                            throw new Error('field id out of 32-bit range');\n                        }\n                        if (typeof prevHash === 'number' && prevHash >= hash) {\n                            throw new Error('field id collision or not sorted');\n                        }\n                        prevHash = hash;\n                        const t = Number(slebDecode(pipe));\n                        fields.push([hash, t]);\n                    }\n                    typeTable.push([ty, fields]);\n                    break;\n                }\n                case -22 /* Func */: {\n                    for (let k = 0; k < 2; k++) {\n                        let funcLength = Number(lebDecode(pipe));\n                        while (funcLength--) {\n                            slebDecode(pipe);\n                        }\n                    }\n                    const annLen = Number(lebDecode(pipe));\n                    safeRead(pipe, annLen);\n                    typeTable.push([ty, undefined]);\n                    break;\n                }\n                case -23 /* Service */: {\n                    let servLength = Number(lebDecode(pipe));\n                    while (servLength--) {\n                        const l = Number(lebDecode(pipe));\n                        safeRead(pipe, l);\n                        slebDecode(pipe);\n                    }\n                    typeTable.push([ty, undefined]);\n                    break;\n                }\n                default:\n                    throw new Error('Illegal op_code: ' + ty);\n            }\n        }\n        const rawList = [];\n        const length = Number(lebDecode(pipe));\n        for (let i = 0; i < length; i++) {\n            rawList.push(Number(slebDecode(pipe)));\n        }\n        return [typeTable, rawList];\n    }\n    const [rawTable, rawTypes] = readTypeTable(b);\n    if (rawTypes.length < retTypes.length) {\n        throw new Error('Wrong number of return values');\n    }\n    const table = rawTable.map(_ => Rec());\n    function getType(t) {\n        if (t < -24) {\n            throw new Error('future value not supported');\n        }\n        if (t < 0) {\n            switch (t) {\n                case -1:\n                    return Null;\n                case -2:\n                    return Bool;\n                case -3:\n                    return Nat;\n                case -4:\n                    return Int;\n                case -5:\n                    return Nat8;\n                case -6:\n                    return Nat16;\n                case -7:\n                    return Nat32;\n                case -8:\n                    return Nat64;\n                case -9:\n                    return Int8;\n                case -10:\n                    return Int16;\n                case -11:\n                    return Int32;\n                case -12:\n                    return Int64;\n                case -13:\n                    return Float32;\n                case -14:\n                    return Float64;\n                case -15:\n                    return Text;\n                case -16:\n                    return Reserved;\n                case -17:\n                    return Empty;\n                case -24:\n                    return Principal;\n                default:\n                    throw new Error('Illegal op_code: ' + t);\n            }\n        }\n        if (t >= rawTable.length) {\n            throw new Error('type index out of range');\n        }\n        return table[t];\n    }\n    function buildType(entry) {\n        switch (entry[0]) {\n            case -19 /* Vector */: {\n                const ty = getType(entry[1]);\n                return Vec(ty);\n            }\n            case -18 /* Opt */: {\n                const ty = getType(entry[1]);\n                return Opt(ty);\n            }\n            case -20 /* Record */: {\n                const fields = {};\n                for (const [hash, ty] of entry[1]) {\n                    const name = `_${hash}_`;\n                    fields[name] = getType(ty);\n                }\n                const record = Record(fields);\n                const tuple = record.tryAsTuple();\n                if (Array.isArray(tuple)) {\n                    return Tuple(...tuple);\n                }\n                else {\n                    return record;\n                }\n            }\n            case -21 /* Variant */: {\n                const fields = {};\n                for (const [hash, ty] of entry[1]) {\n                    const name = `_${hash}_`;\n                    fields[name] = getType(ty);\n                }\n                return Variant(fields);\n            }\n            case -22 /* Func */: {\n                return Func([], [], []);\n            }\n            case -23 /* Service */: {\n                return Service({});\n            }\n            default:\n                throw new Error('Illegal op_code: ' + entry[0]);\n        }\n    }\n    rawTable.forEach((entry, i) => {\n        const t = buildType(entry);\n        table[i].fill(t);\n    });\n    const types = rawTypes.map(t => getType(t));\n    const output = retTypes.map((t, i) => {\n        return t.decodeValue(b, types[i]);\n    });\n    // skip unused values\n    for (let ind = retTypes.length; ind < types.length; ind++) {\n        types[ind].decodeValue(b, types[ind]);\n    }\n    if (b.byteLength > 0) {\n        throw new Error('decode: Left-over bytes');\n    }\n    return output;\n}\n// Export Types instances.\nexport const Empty = new EmptyClass();\nexport const Reserved = new ReservedClass();\nexport const Bool = new BoolClass();\nexport const Null = new NullClass();\nexport const Text = new TextClass();\nexport const Int = new IntClass();\nexport const Nat = new NatClass();\nexport const Float32 = new FloatClass(32);\nexport const Float64 = new FloatClass(64);\nexport const Int8 = new FixedIntClass(8);\nexport const Int16 = new FixedIntClass(16);\nexport const Int32 = new FixedIntClass(32);\nexport const Int64 = new FixedIntClass(64);\nexport const Nat8 = new FixedNatClass(8);\nexport const Nat16 = new FixedNatClass(16);\nexport const Nat32 = new FixedNatClass(32);\nexport const Nat64 = new FixedNatClass(64);\nexport const Principal = new PrincipalClass();\n/**\n *\n * @param types array of any types\n * @returns TupleClass from those types\n */\nexport function Tuple(...types) {\n    return new TupleClass(types);\n}\n/**\n *\n * @param t IDL Type\n * @returns VecClass from that type\n */\nexport function Vec(t) {\n    return new VecClass(t);\n}\n/**\n *\n * @param t IDL Type\n * @returns OptClass of Type\n */\nexport function Opt(t) {\n    return new OptClass(t);\n}\n/**\n *\n * @param t Record of string and IDL Type\n * @returns RecordClass of string and Type\n */\nexport function Record(t) {\n    return new RecordClass(t);\n}\n/**\n *\n * @param fields Record of string and IDL Type\n * @returns VariantClass\n */\nexport function Variant(fields) {\n    return new VariantClass(fields);\n}\n/**\n *\n * @returns new RecClass\n */\nexport function Rec() {\n    return new RecClass();\n}\n/**\n *\n * @param args array of IDL Types\n * @param ret array of IDL Types\n * @param annotations array of strings, [] by default\n * @returns new FuncClass\n */\nexport function Func(args, ret, annotations = []) {\n    return new FuncClass(args, ret, annotations);\n}\n/**\n *\n * @param t Record of string and FuncClass\n * @returns ServiceClass\n */\nexport function Service(t) {\n    return new ServiceClass(t);\n}\n//# sourceMappingURL=idl.js.map"]},"metadata":{},"sourceType":"module"}