{"ast":null,"code":"\"use strict\";\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst cbor = __importStar(require(\"./value\"));\n\nconst BufferClasses = [ArrayBuffer, Uint8Array, Uint16Array, Uint32Array, Int8Array, Int16Array, Int32Array, Float32Array, Float64Array];\n\nclass JsonDefaultCborEncoder {\n  // @param _serializer The CBOR Serializer to use.\n  // @param _stable Whether or not keys from objects should be sorted (stable). This is\n  //     particularly useful when testing encodings between JSON objects.\n  constructor(_serializer, _stable = false) {\n    this._serializer = _serializer;\n    this._stable = _stable;\n    this.name = \"jsonDefault\";\n    this.priority = -100;\n  }\n\n  match(value) {\n    return [\"undefined\", \"boolean\", \"number\", \"string\", \"object\"].indexOf(typeof value) != -1;\n  }\n\n  encode(value) {\n    switch (typeof value) {\n      case \"undefined\":\n        return cbor.undefined_();\n\n      case \"boolean\":\n        return cbor.bool(value);\n\n      case \"number\":\n        if (Math.floor(value) === value) {\n          return cbor.number(value);\n        } else {\n          return cbor.doubleFloat(value);\n        }\n\n      case \"string\":\n        return cbor.string(value);\n\n      case \"object\":\n        if (value === null) {\n          return cbor.null_();\n        } else if (Array.isArray(value)) {\n          return cbor.array(value.map(x => this._serializer.serializeValue(x)));\n        } else if (BufferClasses.find(x => value instanceof x)) {\n          return cbor.bytes(value.buffer);\n        } else if (Object.getOwnPropertyNames(value).indexOf(\"toJSON\") !== -1) {\n          return this.encode(value.toJSON());\n        } else if (value instanceof Map) {\n          const m = new Map();\n\n          for (const [key, item] of value.entries()) {\n            m.set(key, this._serializer.serializeValue(item));\n          }\n\n          return cbor.map(m, this._stable);\n        } else {\n          const m = new Map();\n\n          for (const [key, item] of Object.entries(value)) {\n            m.set(key, this._serializer.serializeValue(item));\n          }\n\n          return cbor.map(m, this._stable);\n        }\n\n      default:\n        throw new Error(\"Invalid value.\");\n    }\n  }\n\n}\n\nexports.JsonDefaultCborEncoder = JsonDefaultCborEncoder;\n\nclass ToCborEncoder {\n  constructor() {\n    this.name = \"cborEncoder\";\n    this.priority = -90;\n  }\n\n  match(value) {\n    return typeof value == \"object\" && typeof value[\"toCBOR\"] == \"function\";\n  }\n\n  encode(value) {\n    return value.toCBOR();\n  }\n\n}\n\nexports.ToCborEncoder = ToCborEncoder;\n\nclass CborSerializer {\n  constructor() {\n    this._encoders = new Set();\n  }\n\n  static withDefaultEncoders(stable = false) {\n    const s = new this();\n    s.addEncoder(new JsonDefaultCborEncoder(s, stable));\n    s.addEncoder(new ToCborEncoder());\n    return s;\n  }\n\n  removeEncoder(name) {\n    // Has to make an extra call to values() to ensure it doesn't break on iteration.\n    for (const encoder of this._encoders.values()) {\n      if (encoder.name == name) {\n        this._encoders.delete(encoder);\n      }\n    }\n  }\n\n  addEncoder(encoder) {\n    this._encoders.add(encoder);\n  }\n\n  getEncoderFor(value) {\n    let chosenEncoder = null;\n\n    for (const encoder of this._encoders) {\n      if (!chosenEncoder || encoder.priority > chosenEncoder.priority) {\n        if (encoder.match(value)) {\n          chosenEncoder = encoder;\n        }\n      }\n    }\n\n    if (chosenEncoder === null) {\n      throw new Error(\"Could not find an encoder for value.\");\n    }\n\n    return chosenEncoder;\n  }\n\n  serializeValue(value) {\n    return this.getEncoderFor(value).encode(value);\n  }\n\n  serialize(value) {\n    return this.serializeValue(value);\n  }\n\n}\n\nexports.CborSerializer = CborSerializer;\n\nclass SelfDescribeCborSerializer extends CborSerializer {\n  serialize(value) {\n    return cbor.raw(new Uint8Array([// Self describe CBOR.\n    ...new Uint8Array([0xd9, 0xd9, 0xf7]), ...new Uint8Array(super.serializeValue(value))]));\n  }\n\n}\n\nexports.SelfDescribeCborSerializer = SelfDescribeCborSerializer;","map":{"version":3,"sources":["serializer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst cbor = __importStar(require(\"./value\"));\nconst BufferClasses = [\n    ArrayBuffer,\n    Uint8Array,\n    Uint16Array,\n    Uint32Array,\n    Int8Array,\n    Int16Array,\n    Int32Array,\n    Float32Array,\n    Float64Array,\n];\nclass JsonDefaultCborEncoder {\n    // @param _serializer The CBOR Serializer to use.\n    // @param _stable Whether or not keys from objects should be sorted (stable). This is\n    //     particularly useful when testing encodings between JSON objects.\n    constructor(_serializer, _stable = false) {\n        this._serializer = _serializer;\n        this._stable = _stable;\n        this.name = \"jsonDefault\";\n        this.priority = -100;\n    }\n    match(value) {\n        return [\"undefined\", \"boolean\", \"number\", \"string\", \"object\"].indexOf(typeof value) != -1;\n    }\n    encode(value) {\n        switch (typeof value) {\n            case \"undefined\":\n                return cbor.undefined_();\n            case \"boolean\":\n                return cbor.bool(value);\n            case \"number\":\n                if (Math.floor(value) === value) {\n                    return cbor.number(value);\n                }\n                else {\n                    return cbor.doubleFloat(value);\n                }\n            case \"string\":\n                return cbor.string(value);\n            case \"object\":\n                if (value === null) {\n                    return cbor.null_();\n                }\n                else if (Array.isArray(value)) {\n                    return cbor.array(value.map((x) => this._serializer.serializeValue(x)));\n                }\n                else if (BufferClasses.find((x) => value instanceof x)) {\n                    return cbor.bytes(value.buffer);\n                }\n                else if (Object.getOwnPropertyNames(value).indexOf(\"toJSON\") !== -1) {\n                    return this.encode(value.toJSON());\n                }\n                else if (value instanceof Map) {\n                    const m = new Map();\n                    for (const [key, item] of value.entries()) {\n                        m.set(key, this._serializer.serializeValue(item));\n                    }\n                    return cbor.map(m, this._stable);\n                }\n                else {\n                    const m = new Map();\n                    for (const [key, item] of Object.entries(value)) {\n                        m.set(key, this._serializer.serializeValue(item));\n                    }\n                    return cbor.map(m, this._stable);\n                }\n            default:\n                throw new Error(\"Invalid value.\");\n        }\n    }\n}\nexports.JsonDefaultCborEncoder = JsonDefaultCborEncoder;\nclass ToCborEncoder {\n    constructor() {\n        this.name = \"cborEncoder\";\n        this.priority = -90;\n    }\n    match(value) {\n        return typeof value == \"object\" && typeof value[\"toCBOR\"] == \"function\";\n    }\n    encode(value) {\n        return value.toCBOR();\n    }\n}\nexports.ToCborEncoder = ToCborEncoder;\nclass CborSerializer {\n    constructor() {\n        this._encoders = new Set();\n    }\n    static withDefaultEncoders(stable = false) {\n        const s = new this();\n        s.addEncoder(new JsonDefaultCborEncoder(s, stable));\n        s.addEncoder(new ToCborEncoder());\n        return s;\n    }\n    removeEncoder(name) {\n        // Has to make an extra call to values() to ensure it doesn't break on iteration.\n        for (const encoder of this._encoders.values()) {\n            if (encoder.name == name) {\n                this._encoders.delete(encoder);\n            }\n        }\n    }\n    addEncoder(encoder) {\n        this._encoders.add(encoder);\n    }\n    getEncoderFor(value) {\n        let chosenEncoder = null;\n        for (const encoder of this._encoders) {\n            if (!chosenEncoder || encoder.priority > chosenEncoder.priority) {\n                if (encoder.match(value)) {\n                    chosenEncoder = encoder;\n                }\n            }\n        }\n        if (chosenEncoder === null) {\n            throw new Error(\"Could not find an encoder for value.\");\n        }\n        return chosenEncoder;\n    }\n    serializeValue(value) {\n        return this.getEncoderFor(value).encode(value);\n    }\n    serialize(value) {\n        return this.serializeValue(value);\n    }\n}\nexports.CborSerializer = CborSerializer;\nclass SelfDescribeCborSerializer extends CborSerializer {\n    serialize(value) {\n        return cbor.raw(new Uint8Array([\n            // Self describe CBOR.\n            ...new Uint8Array([0xd9, 0xd9, 0xf7]),\n            ...new Uint8Array(super.serializeValue(value)),\n        ]));\n    }\n}\nexports.SelfDescribeCborSerializer = SelfDescribeCborSerializer;\n//# sourceMappingURL=serializer.js.map"]},"metadata":{},"sourceType":"script"}