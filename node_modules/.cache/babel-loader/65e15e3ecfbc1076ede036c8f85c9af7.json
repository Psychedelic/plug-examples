{"ast":null,"code":"import _toConsumableArray from \"/Users/tomasrocchi/Documents/fleek/plug-examples/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\n/**\n * Concatenate multiple array buffers.\n * @param buffers The buffers to concatenate.\n */\nexport function concat() {\n  for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) {\n    buffers[_key] = arguments[_key];\n  }\n\n  var result = new Uint8Array(buffers.reduce(function (acc, curr) {\n    return acc + curr.byteLength;\n  }, 0));\n  var index = 0;\n\n  for (var _i = 0, _buffers = buffers; _i < _buffers.length; _i++) {\n    var b = _buffers[_i];\n    result.set(new Uint8Array(b), index);\n    index += b.byteLength;\n  }\n\n  return result.buffer;\n}\n/**\n * Transforms a buffer to an hexadecimal string. This will use the buffer as an Uint8Array.\n * @param buffer The buffer to return the hexadecimal string of.\n */\n\nexport function toHex(buffer) {\n  return _toConsumableArray(new Uint8Array(buffer)).map(function (x) {\n    return x.toString(16).padStart(2, '0');\n  }).join('');\n}\nvar hexRe = /^([0-9A-F]{2})*$/i.compile();\n/**\n * Transforms a hexadecimal string into an array buffer.\n * @param hex The hexadecimal string to use.\n */\n\nexport function fromHex(hex) {\n  if (!hexRe.test(hex)) {\n    throw new Error('Invalid hexadecimal string.');\n  }\n\n  var buffer = _toConsumableArray(hex).reduce(function (acc, curr, i) {\n    // tslint:disable-next-line:no-bitwise\n    acc[i / 2 | 0] = (acc[i / 2 | 0] || '') + curr;\n    return acc;\n  }, []).map(function (x) {\n    return Number.parseInt(x, 16);\n  });\n\n  return new Uint8Array(buffer).buffer;\n}\nexport function compare(b1, b2) {\n  if (b1.byteLength !== b2.byteLength) {\n    return b1.byteLength - b2.byteLength;\n  }\n\n  var u1 = new Uint8Array(b1);\n  var u2 = new Uint8Array(b2);\n\n  for (var i = 0; i < u1.length; i++) {\n    if (u1[i] !== u2[i]) {\n      return u1[i] - u2[i];\n    }\n  }\n\n  return 0;\n}","map":{"version":3,"sources":["../../../src/utils/buffer.ts"],"names":[],"mappings":";;AAAA;;;AAGG;AACH,OAAM,SAAU,MAAV,GAA0C;AAAA,oCAAtB,OAAsB;AAAtB,IAAA,OAAsB;AAAA;;AAC9C,MAAM,MAAM,GAAG,IAAI,UAAJ,CAAe,OAAO,CAAC,MAAR,CAAe,UAAC,GAAD,EAAM,IAAN;AAAA,WAAe,GAAG,GAAG,IAAI,CAAC,UAA1B;AAAA,GAAf,EAAqD,CAArD,CAAf,CAAf;AACA,MAAI,KAAK,GAAG,CAAZ;;AACA,8BAAgB,OAAhB,8BAAyB;AAApB,QAAM,CAAC,eAAP;AACH,IAAA,MAAM,CAAC,GAAP,CAAW,IAAI,UAAJ,CAAe,CAAf,CAAX,EAA8B,KAA9B;AACA,IAAA,KAAK,IAAI,CAAC,CAAC,UAAX;AACD;;AACD,SAAO,MAAM,CAAC,MAAd;AACD;AAED;;;AAGG;;AACH,OAAM,SAAU,KAAV,CAAgB,MAAhB,EAAmC;AACvC,SAAO,mBAAI,IAAI,UAAJ,CAAe,MAAf,CAAJ,EAA4B,GAA5B,CAAgC,UAAA,CAAC;AAAA,WAAI,CAAC,CAAC,QAAF,CAAW,EAAX,EAAe,QAAf,CAAwB,CAAxB,EAA2B,GAA3B,CAAJ;AAAA,GAAjC,EAAsE,IAAtE,CAA2E,EAA3E,CAAP;AACD;AAED,IAAM,KAAK,GAAG,oBAAoB,OAApB,EAAd;AAEA;;;AAGG;;AACH,OAAM,SAAU,OAAV,CAAkB,GAAlB,EAA6B;AACjC,MAAI,CAAC,KAAK,CAAC,IAAN,CAAW,GAAX,CAAL,EAAsB;AACpB,UAAM,IAAI,KAAJ,CAAU,6BAAV,CAAN;AACD;;AACD,MAAM,MAAM,GAAG,mBAAI,GAAJ,EACZ,MADY,CACL,UAAC,GAAD,EAAM,IAAN,EAAY,CAAZ,EAAiB;AACvB;AACA,IAAA,GAAG,CAAE,CAAC,GAAG,CAAL,GAAU,CAAX,CAAH,GAAmB,CAAC,GAAG,CAAE,CAAC,GAAG,CAAL,GAAU,CAAX,CAAH,IAAoB,EAArB,IAA2B,IAA9C;AACA,WAAO,GAAP;AACD,GALY,EAKV,EALU,EAMZ,GANY,CAMR,UAAA,CAAC;AAAA,WAAI,MAAM,CAAC,QAAP,CAAgB,CAAhB,EAAmB,EAAnB,CAAJ;AAAA,GANO,CAAf;;AAQA,SAAO,IAAI,UAAJ,CAAe,MAAf,EAAuB,MAA9B;AACD;AAED,OAAM,SAAU,OAAV,CAAkB,EAAlB,EAAmC,EAAnC,EAAkD;AACtD,MAAI,EAAE,CAAC,UAAH,KAAkB,EAAE,CAAC,UAAzB,EAAqC;AACnC,WAAO,EAAE,CAAC,UAAH,GAAgB,EAAE,CAAC,UAA1B;AACD;;AAED,MAAM,EAAE,GAAG,IAAI,UAAJ,CAAe,EAAf,CAAX;AACA,MAAM,EAAE,GAAG,IAAI,UAAJ,CAAe,EAAf,CAAX;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,EAAE,CAAC,MAAvB,EAA+B,CAAC,EAAhC,EAAoC;AAClC,QAAI,EAAE,CAAC,CAAD,CAAF,KAAU,EAAE,CAAC,CAAD,CAAhB,EAAqB;AACnB,aAAO,EAAE,CAAC,CAAD,CAAF,GAAQ,EAAE,CAAC,CAAD,CAAjB;AACD;AACF;;AACD,SAAO,CAAP;AACD","sourceRoot":"","sourcesContent":["/**\n * Concatenate multiple array buffers.\n * @param buffers The buffers to concatenate.\n */\nexport function concat(...buffers) {\n    const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));\n    let index = 0;\n    for (const b of buffers) {\n        result.set(new Uint8Array(b), index);\n        index += b.byteLength;\n    }\n    return result.buffer;\n}\n/**\n * Transforms a buffer to an hexadecimal string. This will use the buffer as an Uint8Array.\n * @param buffer The buffer to return the hexadecimal string of.\n */\nexport function toHex(buffer) {\n    return [...new Uint8Array(buffer)].map(x => x.toString(16).padStart(2, '0')).join('');\n}\nconst hexRe = /^([0-9A-F]{2})*$/i.compile();\n/**\n * Transforms a hexadecimal string into an array buffer.\n * @param hex The hexadecimal string to use.\n */\nexport function fromHex(hex) {\n    if (!hexRe.test(hex)) {\n        throw new Error('Invalid hexadecimal string.');\n    }\n    const buffer = [...hex]\n        .reduce((acc, curr, i) => {\n        // tslint:disable-next-line:no-bitwise\n        acc[(i / 2) | 0] = (acc[(i / 2) | 0] || '') + curr;\n        return acc;\n    }, [])\n        .map(x => Number.parseInt(x, 16));\n    return new Uint8Array(buffer).buffer;\n}\nexport function compare(b1, b2) {\n    if (b1.byteLength !== b2.byteLength) {\n        return b1.byteLength - b2.byteLength;\n    }\n    const u1 = new Uint8Array(b1);\n    const u2 = new Uint8Array(b2);\n    for (let i = 0; i < u1.length; i++) {\n        if (u1[i] !== u2[i]) {\n            return u1[i] - u2[i];\n        }\n    }\n    return 0;\n}\n//# sourceMappingURL=buffer.js.map"]},"metadata":{},"sourceType":"module"}